# Javascript算法

##### 闭包

内部函数总是可以访问其外部函数中声明的变量。

好处：

1. 缓存。将变量隐藏起来不被 GC 回收。
2. 实现柯里化。利用闭包特性完成柯里化。

坏处：

1. 内存消耗。闭包产生的变量无法被销毁。
2. 性能问题。由于闭包内部变量优先级高于外部变量，所以需要多查找作用域链的一个层次，一定程度影响查找速度。

##### 柯里化函数

柯里化（Currying）是把接受多个参数的函数转变为单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。

简单来说：1、通过闭包管理；2、支持链式调用；3、每次运行返回一个function

柯里化函数的好处：

- 参数提前复用

```javascript
// 校验数字
let numberReg = /[0-9]+/g;
// 校验小写字母
let stringReg = /[a-z]+/g;
// currying 后
function curryingCheck(reg) {
  return function(txt) {
    return reg.test(txt);
  }
}
// 校验数字
let checkNumber = curryingCheck(numberReg);
let checkString = curryingCheck(stringReg);
// 使用
console.log(checkNumber('13888888888')); // true
console.log(checkString('jsliang')); // true
```

- 提前确认

```javascript
var on = function(element, event, handler) {
    if (document.addEventListener) {
        if (element && event && handler) {
            element.addEventListener(event, handler, false);
        }
    } else {
        if (element && event && handler) {
            element.attachEvent('on' + event, handler);
        }
    }
}

var on = (function() {
    if (document.addEventListener) {
        return function(element, event, handler) {
            if (element && event && handler) {
                element.addEventListener(event, handler, false);
            }
        };
    } else {
        return function(element, event, handler) {
            if (element && event && handler) {
                element.attachEvent('on' + event, handler);
            }
        };
    }
})();
//换一种写法可能比较好理解一点，上面就是把isSupport这个参数给先确定下来了
var on = function(isSupport, element, event, handler) {
    isSupport = isSupport || document.addEventListener;
    if (isSupport) {
        return element.addEventListener(event, handler, false);
    } else {
        return element.attachEvent('on' + event, handler);
    }
}
```

- 延迟执行

```javascript
Function.prototype.bind = function (context) {
    var _this = this
    var args = Array.prototype.slice.call(arguments, 1)
 
    return function() {
        return _this.apply(context, args)
    }
}
```

##### 手写柯里化函数

```javascript
function createAddKer(fn) { // fn表示一个普通函数，将要被转换成柯里化形式
  // console.log(fn.length,"fn.length");
  let argLen = fn.length; // 总共有三个参数
  let argsAll = [];
  return function addKer2() {
    // 两种返回结果
    let args = Array.from(arguments); // 把接收到的参数转换成数组
    // console.log(args,"args");
    argsAll = argsAll.concat(args); // 把接收到的参数记录下来
    // console.log(argsAll,"argsAll");
    if (argsAll.length < argLen) {
      // 当参数没接收完的时候，返回函数
      return addKer2;
    } else if (argsAll.length === argLen) {
      // 当参数接收完的时候，返回最终的结果
      let result = fn(...argsAll);
      // 清空缓存
      argsAll = []
      return result
    }
  }
}
let addNow = createAddKer(add)
console.log(addNow(1)(2)(3));
console.log(addNow(1,2)(3));
console.log(addNow(1,2,3));

 function curry(fn) {
    // 保存预置参数
    const presetArgs = [].slice.call(arguments, 1)
    // 返回一个新函数
    function curried() {
      // 新函数调用时会继续传参
      const restArgs = [].slice.call(arguments
      const allArgs = [...presetArgs, ...restArgs]
      // 下面这个相当于 return currl(fn, ...allArgs)
      return curry( fn, ...allArgs)
    }
    // 重写toString
    curried.toString = function () {
      return fn(...arguments)
      // 下面这个是一样的
      // return fn.call(null, ...presetArgs)
    }
    return curried
  }
```

##### 手写call，bind，apply

```javascript
Function.prototype.myCall = function(context = globalThis) {
  // 设置 fn 为调用 myCall 的方法
  context.fn = this;
  // 获取剩余参数
  const otherArg = Array.from(arguments).slice(1);
  // 调用这个方法，将剩余参数传递进去
  context.fn(otherArg);
  // 将这个方法的执行结果传给 result
  let result = context.fn();
  // 删除这个变量
  delete context.fn;
  // 返回 result 结果
  return result;
};

Function.prototype.myApply = function(context = globalThis, arr) {
  // 设置 fn 为调用 myCall 的方法
  context.fn = this;
  let result;
  // 如果存在参数，则传递进去
  // 将结果返回给 result
  if (arr) {
    result = context.fn(arr);
  } else { // 否则不传
    result = context.fn();
  }
  // 删除这个变量
  delete context.fn;
  // 返回 result 结果
  return result;
};

Function.prototype.myBind = function(context = globalThis) {
  // 设置 fn 为调用 myCall 的方法
  const fn = this;
  // 获取该方法剩余参数
  const otherArg = [...arguments].slice(1);
  // 设置返回的一个新方法
  const result = function() {
    // 获取返回方法体的参数
    const resultArg = [...arguments];
    // 如果是通过 new 调用的，绑定 this 为实例对象
    if (this instanceof result) {
      fn.apply(this, otherArg.concat(resultArg));
    } else { // 否则普通函数形式绑定 context
      fn.apply(context, otherArg.concat(resultArg));
    }
  }
  // 绑定原型链
  result.prototype = Object.create(fn.prototype);
  // 返回结果
  return result;
};

//my call apply bind
Function.prototype.mycall = function (myobj, ...args) {
    if (typeof myobj === 'function') throw typeError('error')
    let fn = Symbol('fn')//唯一值
    myobj = myobj || window  //若没有对象，则绑定到window上
    myobj[fn] = this //把函数赋值到对象的某个属性
    let result = myobj[fn](...args)
    delete myobj[fn]  //删除fn声明
    return result
  }	
Function.prototype.mybind=function(myobj,...args){
       if(typeof myobj==='Function'){
             throw new TypeError('error')
       }
      let self=this
      let fnNop = function () {} // 定义一个空函数
      let fnBound=function(){
          // 检测 New , 如果当前函数的this指向的是构造函数中的this 则判定为new 操作
           let _this=this instanceof self?this:myobj
           self.apply(_this,args.concat(Array.prototype.slice.call(arguments)))   
      }
 
    if (this.prototype) {
       fnNop.prototype = this.prototype;
   }
 
   fnBound.prototype = new fnNop();
   return fnBound
}
```

##### 	手写new

**第一个参数必须是个函数**。`const person = new Person()`，但是我们搞不了原汁原味的，那就变成 `const person = myNew(Person)`。

**原型链继承**。我们新建一个对象 `obj`，这个 `obj` 的 `__proto__` 指向 `func` 的原型 `prototype`，即 `obj.__proto__ === func.prototype`。

**修正 `this` 指向**。通过 `apply` 绑定 `obj` 和 `func` 的关系，并且将参数作为一个数组传递进去（方法体定义已经将剩余参数解构为数组）

**判断构造函数是否返回 `Object` 或者 `Function`**。`typeof` 判断 `object` 需要排除 `null`，因为 `typeof null === object`。

**非函数和对象返回新创建的对象，否则返回构造函数的 `return` 值**。

```javascript
function myNew(func,...args){
  // 1. 判断方法体
  if (typeof func !== 'function') {
    throw '第一个参数必须是方法体';
  }
  // 2. 创建新对象
  const obj = {};
  // 3. 这个对象的 __proto__ 指向 func 这个类的原型对象
  // 即实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性
  obj.__proto__ = Object.create(func.prototype);
  // 为了兼容 IE 可以让步骤 2 和 步骤 3 合并
  // const obj = Object.create(func.prototype);
  
  // 4. 通过 apply 绑定 this 执行并且获取运行后的结果
  let result = func.apply(obj, args);
  
  // 5.优先返回构造函数返回的对象 ,如果构造函数返回的结果是引用数据类型，则返回运行后的结果 
  //否则返回新创建的 obj
    return result instanceof Object ? result : obj;
}
function create () {
    
  // 1. 获取构造函数，并且删除 arguments 中的第一项
  var Con = [].shift.call(arguments);
  // 2. 创建一个空的对象并链接到构造函数的原型，使它能访问原型中的属性
  var obj = Object.create(Con.prototype);
  // 3. 使用apply改变构造函数中this的指向实现继承，使obj能访问到构造函数中的属性
  var ret = Con.apply(obj, arguments);
  // 4. 优先返回构造函数返回的对象
  return ret instanceof Object ? ret : obj;
}


function Person(name){
  this.name = name;
  // 用来测试第 5 点
  return function(){
    console.log('返回引用数据类型')
  };
}
// 用来测试第 2 点和第 3 点
Person.prototype.sayName = function() {
  console.log(`My name is ${this.name}`);
}
const me = myNew(Person, 'yl'); // 用来测试第 4 点
me.sayName();
console.log(me);
// 测试第 5 点
// me()
```

##### 原型链和原型对象

原型:每个函数都有 prototype 属性，该属性指向原型对象；

原型链：主要解决的继承问题，每个对象都拥有一个原型对象，通过__proto__ 指针指向其原型对象，并从中继承方法和属性。

[深入理解 JavaScript 原型](https://mp.weixin.qq.com/s/1UDILezroK5wrcK-Z5bHOg)【阅读建议：1h】

[详解JS原型链与继承](http://louiszhai.github.io/2015/12/15/prototypeChain/)【阅读建议：30min】

[从proto和prototype来深入理解JS对象和原型链](https://github.com/creeperyang/blog/issues/9)【阅读建议：10min】

[最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一）](https://www.jianshu.com/p/dee9f8b14771)【阅读建议：内容有些误导】

[最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二）](https://www.jianshu.com/p/652991a67186)【阅读建议：高程书摘取，经第一篇后不继续往后看】

[最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）](https://www.jianshu.com/p/a4e1e7b6f4f8)【阅读建议：高程书摘取，经第一篇后不继续往后看】

##### 手写Promise

```javascript
class MyPromise {
  constructor(executor) {
    //初始化 state 为等待状态
    this.state = 'pending';
    // 成功的值
    this.value = undefined;
    // 失败的值
    this.reason = undefined;
    // 成功存放的数组
    this.onResolvedCallbacks = [];
    // 失败存放的数组
    this.onRejectedCallbacks = [];
    // 成功
    let resolve = (value) => {
      // state 改变 , resolve 调用会失败
      if (this.state === 'pending') {
        this.state = 'fulfilled';// 调用 resolve后,state转化为成功状态
        this.value = value;// 存储成功的值
        // 一旦resolve 执行, 调用成功数组的函数
        this.onResolvedCallbacks.forEach(fn => fn());
      }
    }
    // 失败
    let reject = (reason) => {
      //state 改变后, reject 调用就会失败
      if (this.state === 'pending') {
        // reject 调用后, state 转化为失败状态
        this.state = 'rejected';
        this.reason = reason;// 存储失败的原因
        // 一旦 resolve执行 , 调用失败数组的函数
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    }
    try {
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }
  then(onFulfilled, onRejected) {
    // 声明返回的 promise2
    let promise2 = new Promise((resolve, reject) => {
      // 状态为 fulfilled ， 执行 onFulfilled , 传入成功的值
      if (this.state === 'fulfilled') {
        let x = onFulfilled(this.value);
        // resolvePromise 函数 , 处理自己 return 的 promise和 默认的 promise2的关系
        resolvePromise(promise2, x, resolve, reject);
      };
      // 状态为rejected , 执行onRejected , 传入失败的原因
      if (this.state === 'rejected') {
        let x = onRejected(this.reason);
        resolvePromise(promise2, x, resolve, reject);
      }
      // 当状态为 pending时
      if (this.state === 'pending') {
        // onFulfilled 传入到成功数组中
        this.onResolvedCallbacks.push(() => {
          let x = onFulfilled(this.value);
          resolvePromise(promise2, x, resolve, reject);
        })
        // onRejected 传入到失败数组
        this.onRejectedCallbacks.push(() => {
          let x = onRejected(this.reason);
          resolvePromise(promise2, x, resolve, reject);
        })
      }
    })
    // 返回promise2,完成链式
    return promise2
  }
}
// 完成 resolvePromise函数
function resolvePromise(promise2, x, resolve, reject) {
  // 循环引用报错
  if (x === promise2) {
    return reject(new TypeError('Chaining cycle detected for promise'));
  }
  //防止多次调用
  let called;
  // x不是null 并且 x是对象或者函数
  if (x != null && (typeof x === 'object' || typeof x === 'function')) {
    try {
      // A+ 规定 , 声明 then = x 的 then 方法
      let then = x.then;
      //如果 then 是函数 , 就默认是promise 了
      if (typeof then === 'function') {
        // 就让 then 执行 第一个参数是 this 后面是成功的回调 和失败的回调
        then.call(x, y => {
          // 成功和失败只能调用一个
          if (called) return;
          called = true;
          // resolve 就结果依旧是 promise 那就继续解析
          resolvePromise(promise2, y, resolve, reject);
        }, err => {
          // 成功和失败只能调用一个
          if (called) return;
          called = true;
          reject(err);
        })
      } else {
        resolve(x); // 直接成功即可
      }
    } catch (e) {
      // 也属于失败
      if (called) return;
      called = true;
      reject(e);
    }
  } else {
    resolve(x);
  }
}
```

##### 手写防抖和截流

```javascript
--- 防抖 debounce 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。
1. 监听拖拽滚动条，然后频繁向下滚动信息，会变得很慢，很迟钝。
2. 点击提交表单后，用户在结果还没出来的时候重复触发。

实现步骤：
1. 设置定时器
2. 设置一个闭包，返回一个方法
3. 如果反复进来，清空前面的定时器，再重新设置一遍
function debounce(fn) {
  let timer = null;
  return function() {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this,arguments);
    }, 1000);
  }
}
--- 节流 throttle 指定时间间隔内只会执行一次任务
1. 防止过快拖动滚动条，导致 JS 跟不上拖动频率，通过节流限制每秒触发监听的次数（固定时间固定频率）

实现步骤:
1. 设置一个标记
2. 设置一个闭包，返回一个方法
3. 如果重复进去的时候，标记已经动了，那就组织程序进一步运行
4. 如果定时器执行完了，设置这个标记为没动，允许下一次执行
function throttle(fn) {
  let timer = true;
  return function() {
    if (!timer) {
      return;
    }
    timer = false;
    setTimeout(() => {
      fn.call(this, arguments);
      timer = true;
    }, 1000);
  }
}
```

> 防抖实例

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>防抖</title>
</head>
<body>
  <button id="debounce">点我防抖！</button>
  <script>
    window.onload = function() {
      // 1、获取这个按钮，并绑定事件
      var myDebounce = document.getElementById("debounce");
      myDebounce.addEventListener("click", debounce(sayDebounce));
    }
    // 2、防抖功能函数，接受传参
    function debounce(fn) {
      // 4、创建一个标记用来存放定时器的返回值
      let timeout = null;
      return function() {
        // 5、每次当用户点击/输入的时候，把前一个定时器清除
        clearTimeout(timeout);
        // 6、然后创建一个新的 setTimeout，
        // 这样就能保证点击按钮后的 1000 毫秒间隔内
        // 如果用户还点击了的话，就不会执行 fn 函数
        timeout = setTimeout(() => {
          fn.call(this, arguments); // 修正 this 指向问题
        }, 1000);
      };
    }
    // 3、需要进行防抖的事件处理
    function sayDebounce() {
      console.log(this);
      // ... 有些需要防抖的工作，在这里执行
      console.log("防抖成功！");
    }
  </script>
</body>
</html>
```

> 节流实例

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>节流</title>
</head>
<body>
  <button id="throttle">点我节流！</button>
  <script>
    window.onload = function() {
      // 1、获取按钮，绑定点击事件
      var myThrottle = document.getElementById("throttle");
      myThrottle.addEventListener("click", throttle(sayThrottle));
    }

    // 2、节流函数体
    function throttle(fn) {
      // 4、通过闭包保存一个标记
      let canRun = true;
      return function() {
        // 5、在函数开头判断标志是否为 true，不为 true 则中断函数
        if(!canRun) {
          return;
        }
        // 6、将 canRun 设置为 false，防止执行之前再被执行
        canRun = false;
        // 7、定时器
        setTimeout( () => {
          fn.call(this, arguments);
          // 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true
          canRun = true;
        }, 1000);
      };
    }
    // 3、需要节流的事件
    function sayThrottle() {
      console.log("节流成功！");
    }
  </script>
</body>
</html>
```

> 防抖➕截流  比如希望固定的时间必定给用户一个响应

```javascript
步骤：
1. 设置last记录定时器开始的时间
2. 设置timer表示一个定时器
3. 获取当前时间now
4. 如果当前时间 - 开始时间小于延迟时间，那么就防抖
5. 否则设置时间到了，执行函数
function throttle(fn, delay) {
  let last = 0, timer = null;
  return function (arguments) {
    let now = new Date();
    if (now - last < delay){
      clearTimeout(timer);
      timer = setTimeout(()=> {
        last = now;
        fn.apply(this, arguments);
      }, delay);
    } else {
      // 这个时候表示时间到了，必须给响应
      last = now;
      //fn.apply(this, args); 不加时 第一次就执行一次
    }
  }
}

```

##### 手写深浅拷贝

```javascript
--- 浅拷贝
const checkedType = (target) => {
  return Object.prototype.toString.call(target).slice(8, -1);
}
const shallowClone = (target) => {
  // 设置结果
  let result;
  // 如果目标是对象，那么设置成对象
  if (checkedType(target) === 'Object') {
    result = {};
  } else if (checkedType(target) === 'Array') { // 如果目标是数组，那么设置成数组
    result = [];
  }
  // 通过 let...in... 遍历数组或者对象
  // 并通过 hasOwnProperty 判断是否为自身的属性
  for (let i in target) {
    if (target.hasOwnProperty(i)) {
      result[i] = target[i];
    }
  }
  // 返回拷贝结果
  return result;
};
//
  
--- 深拷贝
// 定义检测数据类型的功能函数
const checkedType = (target) => {
  return Object.prototype.toString.call(target).slice(8, -1);
}
// 实现深度克隆对象或者数组
   const deepClone = (target) => {
    // 判断拷贝的数据类型
    // 初始化变量 result 成为最终数据
    let result, targetType = checkedType(target);
    if (targetType === 'Object') {
      result = {};
    } else if (targetType === 'Array') {
      result = [];
    } else {
      return target;
    }
    // 遍历目标数据
    for (let i in target) {
      // 获取遍历数据结构的每一项值
      if (Object.hasOwnProperty.call(target, i)) {
        // 判断目标结构里的每一项值是否存在对象或者数组
        if (checkedType(target[i]) === 'Object' || checkedType(target[i]) === 'Array') {
          // 如果对象或者数组中还嵌套了对象或者数组，那么继续遍历
          result[i] = deepClone(target[i]);
        } else {
          // 否则直接赋值
          result[i] = target[i];
        }
      }
    }
    // 返回最终值
    return result;
  }

--- JSON.parse(JSON.stringfy())的局限性
1、不能存放函数或者 Undefined，否则会丢失函数或者 Undefined；
2、不要存放时间对象，否则会变成字符串形式；  
3、不能存放 RegExp、Error 对象，否则会变成空对象；  
4、不能存放 NaN、Infinity、-Infinity，否则会变成 null；
```

##### 手写JSONP

```javascript
// 简单实现
const JSONP = ({
  url,
  params = {},
  callBackkey = 'cb',
  callback,
}) => {
  params[callBackkey] = callBackkey;
  window[callBackkey] = callback;
  const newParam = Object.keys(params).map((key) => `${key}=${params[key]}`).join('&');
  const script = document.createElement('script');
  script.setAttribute('src', `${url}?${newParam}`);
  document.body.appendChild(script);
}
JSONP({
  url: 'https://www.baidu.com/s',
  params: { wd: 'jsliang' },
  callBackkey: 'cb',
  callback(res) {
    console.log(res);
  }
})
// 优化后
function JSONP({
  url,
  params = {},
  callbackKey = "cb",
  callback,
}) {
  // 定义本地的唯一 callBackId，防止多次调用的时候出问题
  JSONP.callBackId = JSONP.callBackId || 1; // 默认为 1
  // 拿到这个 id
  const callBackId = JSONP.callBackId;
  // 将要执行的回调假如到 JSONP 对象中，避免污染 window
  JSONP.callbacks = JSONP.callbacks || [];
  JSONP.callbacks[callBackId] = callback;
  // 把这个名称加入到参数中：`cb = JSONP.callbacks[1]`
  params[callbackKey] = `JSONP.callbacks[${callBackId}]`;
  // 组合 params：'id=1&cb=JSONP.callbacks[1]'
  const paramString = Object.keys(params).map((key) => `${key}=${params[key]}`);
  // 动态创建 script 标签
  const script = document.createElement("script");
  script.setAttribute("src", `${url}?${paramString}`);
  document.body.appendChild(script);
  // id 自增，保证唯一
  JSONP.callBackId++;
}

JSONP({
  url: "http://localhost:8080/api/jsonp",
  params: { id: 1 },
  callbackKey: "cb",
  callback(res) {
    console.log(res);
  },
});
JSONP({
  url: "http://localhost:8080/api/jsonp",
  params: { id: 2 },
  callbackKey: "cb",
  callback(res) {
    console.log(res);
  },
});
```

##### 手写instanceOf

```javascript
function instanceOf(a, b) {
  let proto = a.__proto__;
  const prototype = b.prototype;

  // 从当前 __proto__ 开始查找
  while (proto) {
    
    // 如果找到 null 还没有找到，返回 false
    if (proto === null) {
      return false;
    }

    // 如果 a.__proto__.xxx === b.prototype，返回 true
    if (proto === prototype) {
      return true;
    }

    // 进一步迭代
    proto = proto.__proto__;
  }
}
const Father = function() {
  this.bigName = '爸爸';
};
Father.prototype.sayHello = function() {
  console.log(`我是你${this.bigName}`);
}
const Child = function() {
  Father.call(this);
  this.smallName = '儿子';
}
Child.prototype = Object.create(Father.prototype);
Child.prototype.constructor = Child;
const child = new Child();
child.sayHello(); // 我是你爸爸
console.log(instanceOf(child, Child)); // true
console.log(instanceOf(child, Father)); // true
console.log(instanceOf(child, Object)); // true
```

##### 迭代器

```javascript
// 在数据获取的时候没有选择深拷贝内容
// 对于引用类型进行处理会有问题
// 这里只是演示简化了一点
function Iterdtor(arr) {
  let data = [];
  if (!Array.isArray(arr)) {
    data = [arr];
  } else {
    data = arr;
  }
  let length = data.length;
  let index = 0;
  // 迭代器的核心 next
  // 当调用 next 的时候会开始输出内部对象的下一项
  this.next = function () {
    let result = {};
    result.value = data[index];
    result.done = index === length - 1 ? true : false;
    if (index !== length) {
      index++;
      return result;
    }
    // 当内容已经没有了的时候返回一个字符串提示
    return 'data is all done';
  };
}
const arr = [1, 2, 3];
// 生成一个迭代器对象
const iterdtor = new Iterdtor(arr);
console.log(iterdtor.next()); // { value: 1, done: false }
console.log(iterdtor.next()); // { value: 2, done: false }
console.log(iterdtor.next()); // { value: 2, done: true }
console.log(iterdtor.next()); // data is all done
```



##### this指向问题

[this：从JavaScript执行上下文的视角讲清楚this](https://time.geekbang.org/column/article/128427)【阅读建议：2h】

[再来40道this面试题酸爽继续](https://juejin.im/post/6844904083707396109)【阅读建议：1h】

##### 渐进式网络应用(PWA)

渐进式网络应用（PWA）是谷歌在 2015 年底提出的概念，支持 PWA 的网站可以提供脱机工作、推送通知和设备硬件访问等功能。

[[译] 送你 43 道 JavaScript 面试题](https://juejin.im/post/6844903869378461710)【阅读建议：1h】

##### LRU 

least recently used 最近最少使用原则 -- 模拟keepAlive

```javascript
class LRUCache{
  constructor(max){
    // 缓存的最大值
    this.max = max
    // 存储key值
    this.keys = []
    // 创建map对象 用来缓存数据 浏览器的缓存记录 {key,value}
    this.cache = new Map()
  }
  get(key){
    // 查询当前的缓存中是否包含key值
    if(this.cache.has(key)){
      // this.keys && this.keys.splice(this.keys.indexOf(key),1)
      this.remove(this.keys, key)
      this.keys.push(key)
      return this.cache.get(key)
    }else{
      return -1
    }
  }
  put(key,val){
    // 判断加入的key是否已经存在
    if(this.cache.get(key)){
      // 如果存在改变value值
      this.cache.set(key,val)
      return
    }
    // 删除最早存储的缓存
    if(this.keys.length > this.max){
      // map数据结构中包含delete方法,删除keys数组中的第一个
      // 删除缓存中的数据
      this.cache.delete(this.keys[0])
      // 删除keys数组中的数据
      this.keys.shift()
    }
    // 存储新的缓存
    this.keys.push(key)
    this.cache.set(key,val)
  }
  remove(arr, key){
    if(arr.length){
      const i = arr.indexOf(key)
      if(i > -1){
        // 删除当前访问的key值
        return arr.splice(i,1)
      }
    }
  }
}
const cache = new LRUCache(2); 
// keep-alive 里面的 max cache = {2,"b"}
// keys = [2,5,3,4]
cache.put(1, "a"); 
cache.put(2, "b");
console.log(cache.get(1));      // 返回  "a"
cache.put(1, "c");    // 该操作会使得密钥 2 作废
console.log(cache.get(2));       // 返回 -1 (未找到)
cache.put(4, "d");    // 该操作会使得密钥 1 作废
console.log(cache.get(1));       // 返回 -1 (未找到)
console.log(cache.get(3));       // 返回  3
console.log(cache.get(4));       // 返回  4
```

# Html



# Css



#Http

 

# Tcp



# Dom

##### 创建自定义事件

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>自定义事件</title>
</head>
<body>
  <button class="btn">点我</button>
  
  <script>
    window.onload = function() {
      // 方法 1
      const myEvent = new Event('myEvent');

      // 方法 2
      // const myEvent = new CustomEvent('myEvent', {
      //   detail: {
      //     name: 'jsliang',
      //   },
      // });

      // 方法 3
      // const myEvent = document.createEvent('CustomEvent');
      // myEvent.initEvent('myEvent', true, true);

      const btn = document.querySelector('.btn');
      btn.addEventListener('myEvent', function(e) {
        console.log(e);
      })
      setTimeout(() => {
        btn.dispatchEvent(myEvent);
      }, 2000);
    };
  </script>
</body>
</html>
```



# 

# 前端工程化

### Babel

>  定义：`Babel` 是一个 `JavaScript` 编译器

##### Babel 编译的三个阶段

- 解析（Parsing）：将代码字符串解析成抽象语法树。
- 转换（Transformation）：对抽象语法树进行转换操作。
- 生成（Code Generation）: 根据变换后的抽象语法树再生成代码字符串。

babel转译官网 https://astexplorer.net/

[.babelrc文档](https://www.babeljs.cn/docs/config-files#file-relative-configuration)

##### 相关文献

[前端工程师需要了解的 Babel 知识](https://www.zoo.team/article/babel)【阅读建议：30min】

[不容错过的 Babel7 知识](https://juejin.im/post/5ddff3abe51d4502d56bd143)【阅读建议：30min】

[前端工程师的自我修养-关于 Babel 那些事儿](https://juejin.im/post/5e5b488af265da574112089f)【阅读建议：20min】

##### 重点了解

[入门babel--实现一个es6的class转换器](https://juejin.im/post/6844903586950807560)【阅读建议：10min】

[深入浅出 Babel 上篇：架构和原理 + 实战](https://juejin.im/post/5d94bfbf5188256db95589be)【阅读建议：30min】

[深入浅出 Babel 下篇：既生 Plugin 何生 Macros](https://juejin.im/post/5da12397e51d4578364f6ffa)【阅读建议：30min】

### Webpack

### Glup

# 前端安全



# Nodejs

nvm 管理 nodejs 和 npm 的版本
npm 可以管理 nodejs 的第三方插件

[一篇文章构建你的 NodeJS 知识体系](https://juejin.im/post/5c4c0ee8f265da61117aa527)

[200 多行代码实现 Websocket 协议](https://segmentfault.com/a/1190000016467409)

[如何通过饿了么 Node.js 面试](https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn)

[深入理解 Node.js 进程与线程](https://mp.weixin.qq.com/s/VzXnnfn4gCBMd5wea3LRIg)

[聊聊 Node.js RPC](https://www.yuque.com/egg/nodejs/dklip5)

[JavaScript 中的多线程 -- Web Worker](https://zhuanlan.zhihu.com/p/25184390)【阅读建议：30min】

##### express中间件原理

```javascript
var http = require('http');
// var express = require('express')

/**
 * 仿express实现中间件机制
 *
 * @return {app}
 */
function express() {
  var funcs = []; // 待执行的函数数组
  var app = function (req, res) {
    var i = 0;
    function next() {
      var task = funcs[i++];  // 取出函数数组里的下一个函数
      if (!task) {    // 如果函数不存在,return
        return;
      }
      task(req, res, next);   // 否则,执行下一个函数
    }
    next();
  }
  /**
   * use方法就是把函数添加到函数数组中
   * @param task
   */
  app.use = function (task) {
    funcs.push(task);
  }
  return app;    // 返回实例
}
var app = express();
function middlewareA(req, res, next) {
  console.log('middlewareA before next()');
  setTimeout(()=>{
    next();
  },0)
  console.log('middlewareA after next()');
}
function middlewareB(req, res, next) {
  console.log('middlewareB before next()');
  setTimeout(()=>{
    next();
  },0)
  console.log('middlewareB after next()');
}
function middlewareC(req, res, next) {
  console.log('middlewareC before next()');
  setTimeout(()=>{
    next();
  },0)
  console.log('middlewareC after next()');
}
app.use(middlewareA);
app.use(middlewareB);
app.use(middlewareC);
http.createServer(app).listen('3000', function () {
  console.log('listening 3000....');
});
```

##### Koa中间件原理

```javascript
(async function () {
  function wait(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms || 1));
  }
  const stack = [];
  stack.push(async (context, next) => {
    console.log("第1层的开始");
    await wait(1000);
    await next();
    await wait(1000);
    console.log("第1层的结束");
  });
  stack.push(async (context, next) => {
    console.log("第2层的开始");
    // await wait(1);
    await next();
    // await wait(1);
    console.log("第2层的结束");
  });
  stack.push(async (context, next) => {
    console.log("第3层的开始");
    // await wait(1);
    await next();
    // await wait(1);
    console.log("第3层的结束");
  });
  await compose(stack)({});
})()
function compose(middleware) {
  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')
  for (const fn of middleware) {
    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')
  }
  return function (context, next) {
    let index = -1
    return dispatch(0)
    function dispatch(i) {
      if (i <= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      let fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}
```





# Promise的异步控制流程

[要就来 45 道 Promise 面试题一次爽到底](https://juejin.im/post/6844904077537574919)【阅读建议：8h】

[面试精选之 Promise](https://juejin.im/post/6844903625609707534)【阅读建议：20min】

```javascript
// 给定一个 URL 数组，如何实现接口的继发和并发？
// 继发一
async function loadData() {
  var res1 = await fetch(url1);
  var res2 = await fetch(url2);
  var res3 = await fetch(url3);
  return "when all done";
}
// 继发二
async function loadData(urls) {
  for (const url of urls) {
    const response = await fetch(url);
    console.log(await response.text());
  }
}
/********/
// 并发一
async function loadData() {
  var res = await Promise.all([fetch(url1), fetch(url2), fetch(url3)]);
  return "when all done";
}
// 并发二
async function loadData(urls) {
  // 并发读取 url
  const textPromises = urls.map(async url => {
    const response = await fetch(url);
    return response.text();
  });
  // 按次序输出
  for (const textPromise of textPromises) {
    console.log(await textPromise);
  }
}
```



```javascript
假设目前有1000个url下载链接，已经存储在数组url[1000]中（即url = ['http://example.com/video1.mp3', ...., 'http://example.com/video1000.mp3']）,而且已经有一个函数function download，输入一个url链接，返回一个Promise，该Promise在链接下载完成的时候resolve，下载失败则reject。但是我们要求，任意时刻，同时下载的链接数量不可以超过10个。请写一段代码实现这个需求，要求尽可能快速地将该1000个链接下载完成。

const TotalTaskCount = 1000; // 一共有1000个链接
const MaxConcurrency = 10; // 同时下载的链接数最大不超过10
const url = [...]; // 1000个下载链接组成的数组
const download = function (urlStr) {
  // 返回Promise, 当下载完成的时候resolve
}

Answer:
let todolist = [] // 存储同步下载的链接
let nextIndex = 0; // 记录数组中已经下载的下标
for (let j = 0; j < MaxConcurrency; j++) {
  // 注意这里resolve的值是任务在todoList的脚标，
  // 方便我们在Promise.race之后找到完成的任务脚标
  let task = download(url[nextIndex]).then(() => {return j}); 
  todoList.push(task);
  nextIndex++;
}
const run = async function (todo){
 // 这里index等于Promise.race第一个完成的任务的脚标
 let index = await Promise.race(todo) 
 if(nextIndex < TotalTaskCount){
    // 一旦有一个任务完成，马上把他替换成一个新的任务，继续下载
    todo[index] = download(url[nextIndex]).then(() => {return index;});
    nextIndex++;
 }
 await run(todo) 
}
run(todoList)
```

# 算法

```javascript
class Stack {
  constructor() {
    this.items = []
  }
  push(element) {
    this.items.push(element)
  }
  pop() {
    return this.items.pop();
  }
  isEmpty() {
    return this.items.length === 0
  }
}
// function decimalToBinary(decNumber) {
//   const remStack = new Stack();
//   let number = decNumber;
//   let rem;
//   let binaryString = '';
//   while (number > 0) {
//     rem = Math.floor(number % 2); 
//     remStack.push(rem);
//     number = Math.floor(number / 2); 
//   }
//   while (!remStack.isEmpty()) {
//     binaryString += remStack.pop()
//   }
//   return binaryString;
// }
// console.log(decimalToBinary(3));

function baseConverter(decNumber, base) {
  const remStack = new Stack();
  const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
  let number = decNumber;
  let rem;
  let baseString = '';
  if (!(base >= 2 && base <= 36)) {
    return '';
  }
  while (number > 0) {
    rem = Math.floor(number % base);
    remStack.push(rem);
    number = Math.floor(number / base);
  }
  while (!remStack.isEmpty()) {
    baseString += digits[remStack.pop()];
  }
  return baseString;
}
console.log(baseConverter(100345, 16));
```

