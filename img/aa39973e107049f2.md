# 初级

## 结构样式

### HTML

#### HTML

> 标签是实现网页的内容类型；搭建了一个网页的基本结构

#### 语义化标签

##### 基础

**定义**

+ 标签具备一定的实际含义；

**作用**

+ 非常直观的告诉计算机，写的内容是一种什么样的表现形式；提高计算机的执行能力

##### 标签

###### 标题类标签：h1-h6

+ 表现形式
  + 每一个标签独占一行 
  + 起到警示的作用，主要用于大标题文章题目，一段文字的总结性语言
+ 语法：

```html
<h1><h1>
```

###### 段落类标签

+ 表现形式**（p）**
  + 讲一段文字独立为一个段落
+ 特征
  + 每个标签独占一行；里面放的内容一般都是文本内容/文字或者图片
+ 语法

```html
<p></p>
```

###### 链接标签

+ 表现形式**（a）**
  + 需要配合属性href实现跳转功能
+ 主要表现
  + 标签自带字体颜色（蓝色）
  + 标签自带文本修饰（下划线）
+ 表现特征
  + 多个a标签的内容可以共处一行的
+ 标签作用
  + 实现点击标签的内容，从而实现跳转到另外一个网页
    + href配合实现
      + 本地地址：绝对路径：C:\Program Files (x86)
      + 在线地址：通讯协议：http://;后面再去加上百度的地址：www.baidu.com;
    + 锚点跳转：
      + 在同一页面，页面上点击区跳转到页面另外部分的目标区
      + 在同一页面的目标区，使用<a name="a1>目标区</a>"
    + 页面跳转方式
      + a标签跳转的默认是，新页面覆盖旧页面
        + target：新页面旧页面并存
        + _blank：以新的页面形式打开

###### **图片类标签**

+ 表现形式**（img）**

  + 需要通过属性src 配合实现对图片文件的调用

+ 表现特征

  + 多个img标签输出的内容可以共处一行的

+ 与src配合使用

  + src直接指向我们图片的存储空间img的一个路径

+ 路径：

  + **绝对路径写法**

    + 从本地电脑的硬盘盘符---到文件所处的位置

    `c:/window/desktop/user/day02/img/1.png>`

  + **相对路径**

    + 相对于调用图片的HTML文件的位置关系

    `<img src="img/text.png"/`

    + 三大类

      + 01.index.html 和存放图片的文件夹处在同一级别上

        `存放图片的目录名/图片名称.jpg;`

      + 02,index.html和图片直接存在一个级别上

        `图片名`

      + 03,存放图片的文件夹处在index.html的上一级；如果出现在网页文件的上级目录处

        ` ../../01.jpg;`

      + ../一次代表后退一级；../../后退两级；

+ 标签作用：说明这类标签内容是图片

+ 标签属性

  + title：当网民鼠标悬停在图片上时，用来给用户提供弹窗提示图片信息
  + alt：当图片无法正常显示内容时；用来提示网民图片内容
  + _blank：以新的页面打开

```html
<--绝对路径-->
<img src="./img/1.jpg">

<--相对路径-->
<img src="../../01.jpg">

```

###### **列表类标签**

> **每个标签都是独占一行，不能和其他标签共处一行**

+ 无序列表:ul和li
  + li表示列表中的某各项
  + 一个列表中可以拥有多个li
  + il中也可以嵌套ol或者ul

+  有序列表：ol和li
  + 其中无序列表和有序列表可以用来做导航内容；

+ 自定义列表：dl,dt（图），dd（文）相互配合（上图下文）
  + 用来实现上图下文的结构内容

```html
<div class="box">
    无序列表
    <ul>
        <li></li>
        <li></li>
    </ul>
    有序列表
    <ol>
        <li></li>
        <li></li>
    </ol>
    自定义列表
    <dl>
        <dt></dt>
        <dd></dd>
    </dl>
</div>
```

###### **表格标签**

+ 表现形式
  + ul/li；ol/li；dl/dd/dt
  + 主要实现数据表类的内容；同时有属性：colspan,rowspan;
+ 表现特征

  + table ,tr每个标签都独处一行；td可以实现多个标签共处一行
+ 标签属性
  + 组成部分
    + 标签：table；表格行：tr；表格列：td；表头：caption
  + 全局属性
    + 宽度：width；高度：height；
    + 对齐方式：align
      + 水平居中：center
      + 垂直居中：valign
        + top，left，right，bottom，middle（默认）
    + 边框设置：border
      + 单位：px
  + 单元格的合并
    + 跨列合并
      + colspan（左右合并）
    + 跨行合并
      + rowspan（上下合并）

###### 表单类标签

> **提供填写、选择功能的标签**

+ 表现形式
  + form，input，select，textarea，label;
+ 表现特征：
  + input，select，textarea都是可以共处一行；
+ 标签属性
  + 表单标签：from
    + 提供输入、点击、选择的标签：input
    + 下拉菜单：select
    + 多文本标签：textarea
    + 扩展点击区标签：lable
      + 用户名：<label for="user"></label>
    + 焦点获取：点击input或者select，textarea，都会有一个效果
+ 标签内容

```html
	<label for="user">用户名：</label>

    text单行输入文本

    <input type="text" value="请输入你的用户名" id="user"/><!--单行输入文本-->

    .password 支持单行输入的密码框

    <input type="password" value="请输入你的mima"/><!--加密文本-->

    radio单选

    <input type="radio" name="sex"/>男<!--单选-->
    <input type="radio" name="sex"/>女

    <!--单选 想要互相排斥 name=“sex-->

    checkbox 复选按钮

    <input type="checkbox" name="like"/>旅游
    <input type="checkbox" name="like"/>美食
    <input type="checkbox" name="like"/>游泳
    <input type="checkbox" name="like"/>户外

    reset重置按钮

    <input type="reset" value="重置"/>
    value：默认值
    按当前from表单，回复成默认值 

    submit 提交按钮

    <input type="submit" value="提交"/>

    button按钮：没有效果

    <input type="button" value="按钮"/>

    textarea:多行文本

    <textarea cols="60" rows="30"></textarea>
    
	下拉菜单：select

	<select>
        <option>--请选择你的国籍--</option>
        <option value="zh" selected>中国</option>
        <option value="jp">日本</option>
        <option value="hg">韩国</option>
        <option value="yd">印度</option>
        <option value="usa">美国</option>
        <option value="uk">英国</option>
	</select>
```

#### 结构类标签

##### 基础

+ 定义
  + 构建一个网页的主体结构；将所有的语义化标签打包，形成一个整体；
  + 不代表任何具体的内容形态
+ 作用
  + 语义化标签打包为一个整体
+ 区分
  + 按照内容的类型划分：在同一行内容中，表现特征比较统一的划分为一个块；
  + 看同一行内容中，两部分内容之间的间隔是否具有唯一性；
  + 要看内容是否有边框

##### 标签

###### div

+ 表现形式
  + 块标签：div；
  + 每一个div都会独占一行；
+ 表现特征：
  + 容器，包裹，将语义化标签打包为一个整体，做分割布局作用

###### span

+ 表现形式
  + 行标签：span；
  + 所有span标签都会共处一行
+ 表现特征：
  + 容器，包裹，将语义化标签打包为一个整体，做分割布局作用

#### 格式化标签

##### 基础

+ 定义
  +   就是自带样式；一旦使用这种标签，网页的内容外观会发生变化   

##### 标签

###### 加粗标签：strong

###### 斜体标签：em

###### 下标标签：sub

###### 上标标签sup

###### 实体符号

> 实体符号实体符号就是用一些键盘无法输入的或输入完成以后无法识别的

**空格：&nbsp**

> &nbsp三个空格符号代表的是一个汉字

**版权符号：&copy；**

> 每个网站都会有的版权符号

#### 框架类标签

##### 基础

**定义**

+ 使用在当前使用这个标签的页面，直接通过src引用到另外的网页

##### 标签

###### iframe（常用于后端）

```html
<iframe src="2.html" ></iframe>
<iframe src="3.html" frameborder="0"></iframe>
```

#### 标签的嵌套

##### 行标签

> **块标签内部可以放所有标签；但是h系列标签，p标签内部只能放行和行内块；**

##### 块标签	

> **行标签，内部只能放行标签或者行内块标签；不允许放块标签；**

#### 标签输出特征

> **标签输出始终都是独占一行**

##### 块标签：block

+ 表现形式
  + 始终都独占一行的
  + margin padding 四个方向都起作用
+ 表现特征：
  + 默认的标签实际占位宽度，等于父级的宽度；
+ 标签属性：
  + h1-h6；p；ul；li；ol；dl；dd；dt；table；tr；form,

##### 行标签：inline

+ 表现形式
  + 网页呈现一行输出状态：
  + margin padding 在垂直方向不占位
+ 表现特征：
  + 该类型标签默认的宽度是：标签的内容宽度
  + 默认不能直接设置宽高属性（没有宽高属性）
+ 标签属性：
  + a；span

##### 行内块标签：inline-block

+ 表现形式
  + 行标签输出；又如块标签一样，设置宽度属性；
  + margin padding 四个方向都起作用
+ 表现特征：
  + 默认的标签实际占位宽度，等于父级的宽度
+ 标签属性：
  + img,input,select,textarea;

### CSS

> **主要在网页结构的基础上，做样式；做外观**

#### css的语法

`  select{属性:属性值;}   `

```css
slector{property:value};property
```

#### css的用法

##### 引入方法

**内部样式表**

`<style></style>`

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    内部样式表
</style>
<body>
    
</body>
</html>
```

**内联样式表**

` <p style="background:red;">`

```html
<body>
    **内联样式表**
    <p style="background:red;">
</body>
```

**外部样式表**

`<link rel="stylesheet" href="style.css">`

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
    **外部样式表**
    <link rel="stylesheet" href="style.css">
<style>

</style>
<body>
</body>
</html>
```

##### 引入作用

​	**将css的样式设置，精准的加载到HTML标签**

##### 引入优先级

​	**内联>内部>外部**

#### css的选择器

##### 选择器

  **通配符选择器（通用选择器）**  

+ 语法
  + 使用通配符（*）当做选择器
  +   *{color:red;}   
+ 权重
  + 权重系数：1

**标签选择器** 

+ 语法
  + 标签名做选择器
  +   div{color:red;}   
+ 权重
  + 权重系数：1

**id属性选择器**

+ 语法

  + 通过”id“给标签命名

    `<p id="text"></p>  #text{};权重100`

+ 权重

  + 权重系数：100

**class类选择器**

+ 语法

  + 给标签通过clss属性命名

    `<div class="padd">   .padd{}`

+ 权重

  + 权重系数：10

**派生（包含）选择器**

+ 语法

  + 凡是包含在父级标签内的一类子级都会被选中；跨子级

  + 无视父级下的标签级别

    `.subnav li{}`

    ```html
    <div class="subnav">
        <ul>
            <li>1</li>
            <li>2</li>
            <li>3</li>
        </ul>
    </div>
    ```

    

+ 权重

  +   权重需要计算   

**相邻子代选择器 **

+ 语法

  + 首先确定父级位置利用父级标签下紧挨着的自己标签

    `.subnav > p{color:red;}  `

    ```html
    <div class="subnav">
        <p></p>
        <ul>
            <li>1</li>
            <li>2</li>
            <li>3</li>
        </ul>
        <div>
        	<p></p>
        </div>
    </div>
    ```

    

+ 权重

  + 权重需要计算 

**兄弟元素选择器**

+ 语法

  + 兄+弟 控制元素目标的是：弟弟

    `.subnav+ol li`

    ```
    <div class="subnav">
       <ol>
            <li>1</li>//被选中
            <li>2</li>
            <li>3</li>
        </ol>
        <ul>
            <li>1</li>
            <li>2</li>
            <li>3</li>
        </ul>
    </div>
    ```

    

+ 权重

  + 权重需要计算

**最高权重**

​	  **!important提高权重，并且权重最高，也就是优先级最高**     

##### css3选择器

+ **:first-child**   
  +   择器父级的第一个子级元素   
+   **:last-child**   
  +   择器父级的最后一个子级元素   
+   **:nth-child(n)**   
  +   择器父级的第n个子级元素   
+   **:nth-last-child(n)**   
  +   择器父级的第n个子级元素(从最后一元素开始计数）   

+   **p:first-of-type**
  +  择器父级的第一个子级p元素   
+   **p:last-of-type**     
  +   择器父级的最后一个子级p元素   
+   **p:nth-of-type(n)**   
  +   择器父级的第n个子级p元素   
+   **p:nth-last-of-type(n)**   
  +   择器父级的第n个子级p元素(从最后一元素开始计数）   
+   **p~h2**   
  +   选中p标签同级的后边所有h2标签   
+   **a[href^="wwww"]**   
  +   a标签的属性href值以“www”开头 添加样式   
+   **a[href$="wwww"]**   
  +   a标签的属性href值以“www”结尾 添加样式   
+   **a[href*="wwww"]**   
  +   a标签的属性href值包含“www” 添加样式 
+   **p::selection{color:red;}**   
  + ​    p标签文字选中时的样式 应用少量 CSS 属性：color、background、cursor 以及 outline。 
+ ​    **input:disabled{background:pink;}**   
  +   input被禁用时添加设置样式   
+   **input:enabled{background:green;}**   
  +   input可用状态下添加样式设置样式   
+   **input:checked{}**   
  +   input控件中单选或者复选框被选中值添加样式   

#### css样式

##### 样式单位

##### **长度单位取值**

+ 固定取值px
+ 百分比取值
  + 参考点是这个标签的父级的尺寸

**颜色单位取值**

+ 关键字取值
  + 英文单词代表颜色
+ 16进制取值
  + #ccc
+ 三基色取值
  + rgb(128,128,128)

```css
 	/*三基色取值*/
	Color:RGB(255,0,0);/*红色*/

    Color:RGB(0,255,0);/*绿色*/

    Color:RGB(0,0,255);/*蓝色*/

    Color:RGB(100%,0%,0%);/*红色*/

    Color:RGB(0%,100%,0%);/*绿色*/

    Color:RGB(0%,0%,100%);/*蓝色*/
	/*16进制取值*/

    Color:#ff0000; /*红色*/

    Color:#00ff00; /*绿色*/

    Color:#0000ff; /*蓝色*/
	/*关键字取值*/

    Color:red;/*红色*/

    Color:green;/*绿色*/

    Color:blue;/*蓝色*/

    Color:rgba(255,255,255,0.5)/*透明度为0.5的白色*/
```



##### 基础样式

**宽：高**

+ 设置，一个尺寸的上下限度

  `max-width：最大宽  min-width：最小宽   max-height：最大高  min-height：最小高`

**显示：display**

+ inline-block显示为行内块标签
+ block显示为块标签
+ none消失

**背景：background**

+   **背景颜色background-color**

+   **背景图background-image:url();**   

+   **背景图平铺 background-repeat:;**   

  `repeat-x;水平方向平铺    epeat-y;垂直方向平铺   no-repeat不平铺   `

+ **背景图定位background-position:**   

  ` 属性为两个 left right top bottom 也可以直接写固定值px数值   `

+   **背景的简化语法**   

  + ​	  **background:color url() repeat position;**   

+   **背景图大小 background-size:cover**   

  + 背景图不变形尽可能的平铺铺满 也可以直接写固定值px数值   

+   **背景色渐变 background-image**   

  ` linear-gradient(方向：to right，颜色，颜色);   `

+   **背景图像的起点 background-origin**   

  ` border-box 起始点为边框    padding-box 起始点为padding    content-box 起始点为content`

+   **背景图像的显示范围 background-clip:;padding-box;content-box;**   

  ` border-box 显示的范围边框   padding-box 显示的范围padding   content-box 显示的范围content   `

**文本样式**

+ **段落首行缩进**   

   ` text-indent:20px;首行缩进20px；   `

+   **文本去掉下划线**   

  `  text-decoration:none; 属性值underline（下划线），overline（上划线）   `

+   **水平居中**   

  `  text-align:center; 属性值 left（文字在左侧） right（文字在右侧）   `

+   **字符间的距离**

  `  letter-spacing:20px;字符间距20px   词间距word-spacing:20px;这两个一般针对英文使用   `

+   **强制换行**   

  `  word-wrap:break-word;    normal（默认值）   `

+   **文字的阴影**   
  `  text-shadow:水平 垂直 模糊度 颜色   `

+   **无序列表样式**   

  `  ul{list-tyle:none}    去掉li标签自带的默认样式    `

**字体样式**

+ **字体颜色  color**

  `color:red; `

+   **默认文本正常显示  :  font-style:normal**    

  `  italic文本斜体显示  oblique文本倾斜显示   `

+ **字体大小:  font-size**   

     `font-size:40px `

+   **字体类型 ： font-family**

  `   font-family:"微软雅黑";   `

+   **文字重量 :  font-weight**   

    `文字重量（加粗） 400-900（取值200一个界限） 400位正常 900=bold   `

+   **行高：  line-height**   

  + ​    **line-height=font-size+行间距**   
    + 如果父级只有一行内容（行标签）那么只是给父级标签设置一个line-height=父级自身的高度    就可以让内容的内容垂直居中
    +  如果父级标签内容的内容是一个设置高度的块标签，那么给父级设置line-height=父级自身高度    此时文字内容居中，自己标签本身不居中
    +   如果是行内块标签，设置高度之后，元素本身也不局中   
    + 如果父级标签内部有一个文字的行标签和图片；默认是图片跟文字底部对其，所以图片此时不会居中，    给父级设置line-height;给图片设置vertical-align:middle;    
  + **居中对其 :vertical-align:middle**

  ` vertical-align:top;顶部 vertical-align:bottom;底部   `

+ **链接样式**

  + 链接样式与选择器何在一起叫做状态伪类选择器

  + 伪类：权重：10

    `li:hover a{color:red;}`

+  **input默认样式**   

  +   去除默认边框 可以重新给边框赋值   

    `  去除获取焦点的样式 outline:none   `

+   **光标的显示**   

    `cursor:pointer     把光标改变成小手   `

#####   **边框border**     

+ border-width:;边框的宽度   

+ border-style:;边框的样式   

  `  solid实线 dashed虚线 double双线   `

+ border-color:;边框的颜色   

  `简写 border:width style color;  ` 

+ border-top:;边框上边   

+   border-right:;边框右边   

+   border-bottom:;边框下边   

+   border-left:;边框左边   

+   border-image:url()  

  `border-image:url() 30 30 30 30 round; 30指的是顺时针边框上右下左   round 重复   stretch 拉伸`

#####   圆角   

+   border-radius:;边框圆角  数值px 数值%   

+   border-top-left-radius:; 左上角   

+   border-bottom-left-radius:; 左下角   

+   border-bottom-right-radius:; 右下角   
  `border-radius:10px 20px 30px 40px; 左上角10px 右上角20px 右下角30px 左下角40px（顺时针）   `

+   **元素透明**   

  `  opacity:; 取值范围0.0~1.0 ； 0完全透明 1完全不透明   

##### 盒子模型

**定义**

> 网页是由多个标签拼凑形成的；

**作用**

> 计算元素在网页中实际的占位宽度：width+border+margin+padding;

**表现形式**

>  border:边框；width:初始的宽度设置；padding：内容到边框的距离；margin:标签到标签的间隔

**表现特征**

+ 行标签，垂直方向padding，margin不占位
+ 所有标签在水平方向，之间的间隔相当于两个标签左右边距之和
+ 块级标签和行内块标签上下间隔是以最大的外边距为准
+ 如果父级标签内部有自己块标签

##### 浮动

**定义**

> **子级标签漂浮出父级的约束；这样有时候父级的高度会消失**

**取值**

> float:left/right/none
>
> 所有的元素经过浮动之后，都会变成块标签

**表现形式**

> 当写书内容时 会从上往下排序 想让它从左向右依次排序 这时需要添加浮动    浮动之后所有的标签都是行内块标签

**浮动会产生负面效果**

+ 父级高度消失

  +   直接设置父级高度可以直接恢复  高度直接固定扩展性差   

  +  设置overflow:hidden; 超出的部分隐藏 不能应用在下拉菜单上 

  + 给失去高度的父级最后添加一个不参与浮动的空标签 空标签太多，结构表现行为三者不能分离    clear:both;

  +   给父级添加样式   

    `  父级:after{content:"";display:block;visibility:hidden;clear:both;} 代码结构复杂 代码冗长   `

  +   给跟随标签的父级设置：clear:both;   

##### 定位

**定义**

> **能够自由实现一个标签的位置设置**

**表现形式**

+   **position:static; 没有定位**   

+   **position:fixed; 固定定位**   

  `  以body为参考 原点body的左上角 不会会占据原来的位置   `

+   **position:relative; 相对定位**      

  `  以自己为参考 原点自己的左上角 还会占据原来的位置   `

+   **position:absolute; 绝对定位定位**   

  `  以父级为参考 原点父级的左上角 不会会占据原来的位置   `

##### **图层的设置   z-index**

**定义**

> 当我们的标签在同一个位置显示是，这些标签就会出现层叠，新的标签覆盖旧的标签，这是的标签图层都是0  如果希望有一个标签在最上层 就需要给这个标签使用图层设置z-index

**特征**

> 设置层级关系；值越大，越在上面

## JavaScript 入门

### Javascipt 语法

#### 初识JS

##### 什么是前端？

> **一切能看到的网页内容都属于前端**

##### 什么是程序？

> 可以看做是一系列动作执行的描述

##### 什么是交互

> 在html中输入数据，后台程序处理数据，之后回馈一个数据

#### JS的组成

> **ECMA 语法和规则；BOM浏览器对象模型；BOM文档对象模型**

#### JS引入方式

##### 外部引入

```html
<script src="js/javascript.js"></script>
```

##### 内部引入

```html
<script>
    alert("这是一个警告框“）
    document.write("向页面主体输出内容“）
    console.log("向控制台输出“）
</script>
```

##### 内联使用

```html
<div onclick="function(){console.log('你好')}"></div>
```

#### Js的运行环境

##### 定义

> 将程序转化为计算机可以直接识别的语言，这套转化工具叫做运行环境

##### 执行原理

> **在执行所有程序之前，首先预览程序，将程序分为优先执行，顺序执行的内容，最后编译成为计算机语言，最后执行**

#### Js语言的特点

**动态化**

+ 程序要执行了才开始解析程序

**轻量化**

+ 使用灵活，规则较少

**单线程**

+ 一次只是执行一个程序
  + 弱点：运行程序你较慢，执行耗费内存资源的程序时，后面的程序只能等待；从而造成页面加载缓慢
  + 解决：采用同步执行，异步执行相结合

#### Js语法规范

+ 1，严格区分大小写
+ 2，js语句换行，代表上一句执行的结束，为了区分js语句执行范围，给每句话的结尾添加分号‘ ； ’
+ 3，在js中不要使用中横线‘ - ’
+ 4，代码注释分为：单行注释 //  多行注释/**/  

#### Js三种输出方式

**控制台输出**

> **向数据台输入内容**

+ 特征：可以输入任何数据类型

  `console.log('向控制台输出')`

**页面输出**

> 在页面输入一个内容

`document,write("页面输出")`

**浏览器弹出**

> 控制浏览器弹出一个警告框

+ 属于window对象，全名：window.alert（）

  `alert(“这是一个警告框”)  alert：警告的意思`

#### js程序的执行原则

> 在一般情况下，js程序是从上往下，顺序执行，并且只执行一次
>
> 在js程序执行运算过程中，遵循数学中的加减乘除，小括号等运算规则和执行程序优先级

#### 注释

> 单行注释//      多行注释/**/

### 变量

#### 变量定义

> 变量是一个存储数据的空间

#### 变量作用

> 在执行中我们只需要调用变量，就可以直接使用变量中的数据，避免了重复书写形成冗余

#### 变量的创建

**变量声明**

+ var
  + 计算机一旦看到变量声明，首先开创空间

**变量名称**

+ a
  + 给这个变量空间命名为a
+ 命名规则
  + 名称的第一位不能是数字，但是可以是 ''%'  _  $ 字符，字母
  + 变量名不能取关键字和保留字
    + 关键字和保留字在程序中己经被计算机赋予特殊含义；开发人员不能使用

#### 变量的命名

**驼峰命名**

+ 大驼峰

  + 多个单词组合命名的时候，首个字母小写，第二个字母大写

    `backgroundColor:red;`

+ 小驼峰

  + 所有单词的首字母都大写

    `BackgroundColor：red； MyCore`

**蛇形命名**

+ 多个单词以下划线为连接线

  `my_top_center`

**赋值符号**

+ ‘  =  ’ 
+ 给空间里面填充数据

#### 变量的引用

+ 直接调用变量名称，就可以使用变量的值

+ 在程序中使用字母符号的时候，要么直接通过双引号，代表这个字母是文字，要么直接将字母声明为变量

#### 变量创建的方法

+ 标准

  `var b = 10;`

+ 变量还不知道有什么值，先占一个位置

  `var b`

+ 批量创建，不建议经常使用

  `var a = 10 b = 12 c = 20;`

+ 无声明创建，静止使用

  `c = 12`

### 数据类型

#### 数据类型定义

> 用于描述一切数据内容

#### 判断方式

+ typeof 变量名

  返回结果：数据类型的名称

#### 数据存储

+ 堆存储
  + 主要存储一些最小单元，基本数据类型
+ 栈存储
  + 引用数据类型：属于一个名称后面跟着一个大小不定的大段数据，所有需要可以自由伸缩的空间

#### 数据类型的加减乘除

**数学运算**

> **所有的数据类型遇到string类型都会被自动动转换为string类型**

+ **加法运算**

  > **加号变成拼接符号，其他的数据类型相加，先转化为number在相加**

  + **分类**
    + **string类型+number**
      + 加号变成拼接符号；number被自动转化为string类；
      + 拼接在一起；（凡是从前端网页中来的数据都是string类型）
    + **number+boolean**
      + boolean类型自动转化为number类型在进行相加
      + true---> 1；flase--->0
    + **boolean+string**
      + 此时boolean类型转化为string类
      + 加号变拼接
    + **null+number**
      + null转化为number
      + null：0
    + **null+boolean**
      + 两个类型都转化为number类型
      + 进行相加

+ **减法运算**

  + 减法运算，计算机先把所有的数据类型转化为number类型；然后再相减
  + undefined转化number中是NaN

+ **除法运算**

  + 任何的数据类型相除；都是先转化为数字number类型然后再相除
  + 如果我们的一个**数字除以0的计算：结果是无限大；infinity;**
  + **在转化number中，null,false转化为：0；undefined都是转化为NaN**
  + **在转化为Boolean：null,false都是false，undefined转化为false**

+ **自增，自减**

  + n++;是先运算；再加1；++n;先加1；在运算
  + n--;是先运算；再减1；--n;先减1；在运算

+ **余数运算**

  >  如果都是number类型；js就会依据数学中的运算规则，进行运算

  + 主要作用

    + 控制我们获取的一个数据不超过规定的范围

      `num%10 : 求一个变量num的值除10之后所留下来的余数`

#### 数据分类

> 文字，数学符号，对错，一些比较大的内容

**js数据分为**

+ **基础数据类型**
  + 数字类型
    + number :凡是数字都是number类型
  + 字符串类型
    + string：凡是放在双引号或者单引号下的内容都是字符串类型
  + 布尔值类型
    + boolean：对：true；错：false，真假，对错，又或者没有
  + 未赋值
    + undefined：未赋值的；有名没有值的称为undefined未赋值的
  + 空类型
    + null：创建一个变量，这个变量没有初始值，需要占位，我们会给一个变量赋值为空
+ **引用数据类型**
  + 函数function ；arr数组 ；对象Object；symbol类型
+ **NaN与任何值都不相等，包括本身，NaN与任何值进行计算都为NaN**

#### 数据类型的转换方式

**定义**

>  将不同的数据类型进行转化，通俗的讲将一种数据类型转换为另外一种字符串

**原因**

> 在页面获取的数据都是字符串类型，但是这些数据有的需要进行操作计算

##### 转换方式

+ 转布尔型（boolean）

  + 语法

    + **使用boolean(值)函数 可以将任意数值转换为布尔型**

  + 结果

    + 输出结果：true  false

  + 规则

    + **数值number转布尔型 boolean**

      除了0 和 NAN其余都是true

      ```javascript
      console.log(Boolean(0)) // false
      console.log(Boolean(NaN))// false
      ```

    + **字符串string转布尔型boolean**

      除了空字符串其余都是true

      ```javascript
       例：console.log(Boolean("")); //false;
      ```

    + **空值null转布尔型**

      ```javascript
      console.log(Boolean(null)) //false
      ```

    + **未定义undefined转布尔型**

      ```javascript
      console.log(Boolean(undefined));//false
      ```

+ **转字符串(string)**

  + 方法一

    + 语法

      + String(值)函数；

    + 规则

      + 返回值为转换的内容加一个双引号“”

      ```javascript
      console.log(String(23));//输出结果“23”
      console.log(String(NaN));//输出结果“NaN”
      console.log(String(undefined));//输出结果“undefined”
      console.log(String(null));//输出结果“null”
      console.log(String(true));//输出结果“true”
      ```

  + 方法二

    + 语法

      + 调用被转换数据类型的toString()方法  值。
      + **toString();**

    + 规则

      + 此方法只适合number  boolean  不适用于null和undefined;

      ```javascript
      var num=123;
      str=num.toString();
      console.log(str);  //输出结果为“123”
      
      var num=true;
      str=num.toString();
       console.log(str);  //输出结果为“true”
      ```

  + 方法三

    + 隐式转换

      + 系统根据程序的需求进行自动转换

    + 语法

      + 值+“”空字符串

      `123+“”；输出结果为“123”；null+"" ;输出结果为“null”`

+ 转数值number

  + **Number(值)；**

    + **强制类型转化Number()**

    + 特征

      + Number()任何数字内容转化为number类型
      + 但是对于非数字内容出现：NaN;

    + 规则

      + **字符串转数值**

      ```javascript
      //如果为纯数值的字符串则直接转换为数字
      
      console.log(Number("123"));//输出结果为123
      console.log(Number("00123")); // 输出结果为123
      
      //如果字符串中有非数字内容则转换成NaN
      
      console.log(Number("a123"));//输出结果为NaN
      console.log(Number("中文"));//输出结果为NaN
      
      //如果是空字符串则转换成0
      
      console.log(Number(""));//输出结果为0
      ```

      + **布尔值转数值型**

      ```javascript
      console.log(Number(true)); //输出结果为1
      console.log(Number(false)); //输出结果为0
      ```

      + **空值转数值型**

      ```javascript
      console.log(Number(null)); //输出结果为0
      ```

      + **未定义转转数字型**

      ```javascript
      console.log(Number(undefined)); //输出结果为NaN
      ```

    + **缺点**

      + 无法直接对数字和文本相结合的内容进行转化；

  + **parseInt(值）**

    + **数据转化取整**

    + 规律

      + **从第一个字符开始转换 直到遇到遇到小数点 或者非数字 停止转换 将前面的内容转换**
      + **如果第一个字符为非数字 则返回NaN 相对于字符串而言**

      ```javascript
      console.log(parseInt("123");//输出结果为123
      console.log(parseInt("123px");//输出结果为123
      console.log(parseInt("12.34");//输出结果为12
      console.log(parseInt("a123");//输出结果为NaN
      ```

  + **parseFloat()**

    + **取浮点数（小数）**

    + **规律**

      + **从第一个字符开始转换，如果第一个字符为非数字 则得到的结果为NaN**

      + **如果第一个数字为不是一个非数字，则往后执行 直到遇到非数字 或者小数点**

        `   123.567 只读取123 这个时候用到parsefloat() 123.567    `

    ```javascript
    console.log(parseFloat("12.34");//输出结果为12.34
    console.log(parseFloat("12.34.56");//输出结果为12.34 遇到小数点截止
    console.log(parseFloat("12abc");//输出结果为12遇到非数字截止
    ```

+ **isNaN(检测的值）**

  + **函数检测是否为非数字**

  + 规律

    + 返回值：如果是数字  返回false  如果不是数字返回true
    + 说明 isNaN() 会发生一个隐式转换 会把检测的值转换成number 然后进行运算

    ```javascript
    console.log(isNaN("a");)//返回结果为true  这里面字符串“a"转换为数值NaN
     console.log(isNaN("1");)//返回结果为false
    ```

### 运算符
#### 运算符定义

> 运算符也叫操作符，用于执行代码的操作运算

#### 运算符分类

##### 关系运算

+ 本质

  利用对比后的结果，对后续的执行提供继续执行的判断条件

+ 语法特点

  + **大于，小于（>,<）**
    + 表现

      + **两两比较结果是：boolean值**

      + **string类型之间比大小（转化）；**

        `将所有的string转化为Unicode编码表中的排序；然后按照排序进行比较`

      + **其他数据类型比较大小：**

        `null,number；null<1;但是不等于0`

  + **===绝对等于**

    + 表现

      + **直接对比null===false;这个是返回结果false；**

      + **null===null;NaN===NaN;返回结果为：false；**

        `NaN不是一个具体的值不能进行相等`

  + **!==;绝对不等于**

##### 逻辑运算

+ **作用**

  + 为程序提供判断条件

+ 语法特点

  + **与运算中：&&**

    + 判断条件

      > **从左往右，一直到结束；如果条件都满足，返回true或者1，有一项不满足，返回false或者0**

  + **或运算：||**

    + 判断条件

      > **从左往右，一直到结束；查找符合true的条件，只要有一项符合就不在往下查找，返回true或者1,**

  + **非运算：！**

    + 取所有判断结果返回值

      **如果初始判断值为0；返回true，如果初始判断值为1；返回为false**

    + 只是执行true和false返回结果

      **如果初始判断为0；返回为：true；如果出事判断为：1；返回为false**

##### 赋值运算

**本质**

> **在初始值的基础上去进行数学运算，然后将结果重新赋值给变量；**

+ 语法特点

  + **+=运算**

    + 判断条件

      > **自身加上自身；然后将值重新赋值给自身；**\

  + 其他运算
    
    + ***=；%=；/=**

##### 三目运算

**定义**

> **有多条件参与的运算；**

**语法表现**

+ **关系运算？条件成立执行程序：条件不成立所执行程序；**

**主要作用**

+ **利用关系对比，得到一个布尔值类型的结果true/false**

**表现特点**

+ **问号后面：立即执行就是关系运算返回结果为true的情况下去执行**
+ **冒号之后：执行的就是我们的关系运算结果为false的内容**

### 语言表达式
#### 表达式定义

>  **在程序中，凡是最终能获得结果的句子都是表达式**

> **一定会返回一个结果短句子**

#### 语句

##### 条件判断语句

**语法**

> **if(){如果条件成立则执行}**

**组成部分**

+ 特殊关键字：“if”
+ 条件判断表达式
+ 程序执行区域
  + 执行顺序：从上到下，从左到右

**执行**

+ 赋值运算
  + 先算等号右边的内容，赋值给左边的量

##### 条件分支控制语句

**语法**

> if：如果，else否则

**运行逻辑**

+ 如果条件1成立：执行条件1的程序
+  如果条件2成立：执行条件2的程序 
+  如果条件3成立：执行条件3的程序 
+ 否则：执行最后的程序

**运行顺序**

+ 从上往下执行，只要满足一个条件，后续的就不再执行了

**执行逻辑**

+ 先在表达式中，进行关系运算
+ 得到的结果是boolean，进行if判断
+ 如果是true；执行后续的程序；否则就执行false的结果

**语法**

> **switch case** 

**执行特点**

> 首先给一个结果true，然后拿表达式结果和结果对比，成立则进行后续的内容

**语法组成**

+ switch（先设置一个结果）
+ ｛case表达式
  + 返回结果是一个true或者false-
  + **和switch中设置的结果对比，对等执行冒号后面的程序；**
+ **break；跳出停止的意思**
+ **default：所有不满足，在执行**

```javascript
switch(表达式){//首先色号设置一个结果
    case 值1：
        表达式的值和 值1匹配上，需要执行代码
   case 值2：
        表达式的值和 值2匹配上，需要执行代码
   case 值3：
        表达式的值和 值2匹配上，需要执行代码
   break ；
   default：
        如果表达式和以上的case后面的值都没匹配上，那么执行这里的代码
   break；
}
//不写break会会穿透到下一个break

switch(表达式) {
     case n:
        代码块
        break;
     case n:
        代码块
        break;
     default:
        默认代码块
} 
```

**实例**

```JavaScript
计算周的名称
    switch (new Date().getDay()) {
    case 0:
        day = "星期天";
        break;
    case 1:
        day = "星期一";
         break;
    case 2:
        day = "星期二";
         break;
    case 3:
        day = "星期三";
         break;
    case 4:
        day = "星期四";
         break;
    case 5:
        day = "星期五";
         break;
    case 6:
        day = "星期六";
} 
console.log(day);//当天星期几
```

##### 循环执行语句

**组成**

+ 解析
  + 一定有一个程序反复执行，最终目标是执行到停止
  + 为了让这个条件能停止；一定要设置一个判断条件
  + 这个判断情况不满足情况的，程序反复执行，一旦满足就会立即停止
  + 为了让程序在执行的时候走向满足条件
    + 设置一个变量
    + 这个变量要么自增，要么自减
    + 最后满足这个条件终止程序
+ **循环语句的组成部分**
  + **循环变量；循环条件；循环体**

**语法**

> **while 循环**

```javascript
while(条件)
    {
        需要执行的代码
    }
```

**运用**

> **一般运用于不定项循环**

**特点**

> **不知道循环次数，只知道循环条件**

**实例**

```javascript
let i = 0
let x = []
while(i<5){
    x =x + "The number is " + i 
    i++
    console.log(x);
}
```

**语法**

> **do while 循环**

```javascript
do
{
    需要执行的代码
}
while (条件);
```

**判断逻辑**

+ 和while的区别是：先执行一次程序
+ 判断这个条件是否成立，成立则往后执行
+ 不成立停止后续条件

**实例**

```javascript
let i = 0
let x = []
do
{
    x=x + "The number is " + i + "<br>";
    i++;
}
while (i<5);
```

**运用**

>  **一般应用于有循环次数的循环**

**语法**

```javascript
for (语句 1; 语句 2; 语句 3)
{
    被执行的代码块
}
// 语句 1 （代码块）开始前执行

// 语句 2 定义运行循环（代码块）的条件

// 语句 3 在循环（代码块）已被执行之后执行

```

**实例**

```javascript
var cars = [1,23,4,5,6,6,7]
var len=cars.length;
for (var i=0, i<len; i++)
{ 
    document.write(cars[i] + "<br>");
}
```

**语法**

> for in()

```javascript
for (变量 in 对象)
{
	在此执行代码
}
//“变量”用来指定变量，指定的变量可以是数组元素，也可以是对象的属性。
```

**运用**

>  **for...in 语句用于对数组或者对象的属性进行循环操作** 

**表现特征**

>   **for ... in 循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作** 

**语法**

~~~JavaScript
for(var i in obj){
    console.log(i)--->对象的所有属性名
    console.log(obj[i])----->对象的所有属性值
}

var obj = {name:"joe",age:12,six:'男'}
for (var i in obj) {
    console.log(i) //-- - > 对象的所有属性名 name  age  six
    console.log(obj[i])//-- -- - > 对象的所有属性值 joe 12 男
}
~~~

+ **利用for in循环遍历输出对象属性和属性值**

**实例**

```javascript
var x
var mycars = new Array()
mycars[0] = "Saab"
mycars[1] = "Volvo"
mycars[2] = "BMW"

for (x in mycars){
	document.write(mycars[x] + "<br />")
}

console.log(x);//2
console.log(mycars);//index.html:23 (3) ["Saab", "Volvo", "BMW"]
```

##### 关键字

**语法**

+ **break**
  + **彻底跳出程序，那么该程序不再执行**
  + 跳出的这个关键字所处的程序段，
    + 程序段：就是大括号所包含的内容；不影响其他程序执行；
+ **continue**
  + **跳出本次执行；继续下一次执行；**

### DOM元素

#### 定义

> 是操作HTML标签的集合

#### 内容

##### **批量查找**

> **通过HTML标签名称查找** 

**document.getElementsByTagName（‘标签名’）**

**查找方法**

+ 用for循环来找到每一个标签
+ 获取的结果:一个多个标签的节点集合

**属性**

+ **这个集合有长度：length**
  + 集合.length:得到是一个数字
+ **集合中每个标签都有序号；序号叫作下标（index)**
  + 集合中第一个 标签的下标：是从0开始计算的
  + 集合中最后一个标签下标：length-1

##### 单一查找；

> **通过HTML标签的id属性来进行查找**

**document.getElementByLd('id名');**

+ 返回的结果就是一个 标签以及 标签的内容

> **通过类名class的方式来获取元素：**

**document.getElementsByClassName（‘类名’）**

+ 返回的元素是一个多个列表的集合

**查找方法**

+ **如何找到一个具体的元素**
  + 通过for循环我们可以讲一个多元素几个的列表，一一遍历出来

##### **获取元素内容**

**元素.innerHTML**

##### 添加属性

> **给一个标签添加属性**

**元素.setAttribute('name''value')**

**增加标签**

> **HTML网页的任何内容是string类型；使用string类型的拼接方式来实现对标签的增加；**

**增加样式**

> **创建的标签添加class类名来实现对样式的添加**



### 函数

#### 定义

> **用来存储一段代码的容器，在需要使用是反复调用**

#### 语法表现/创建方式

```javascript
//使用变量赋值的方式直接调用一个函数
var aa = function(){}

// 使用函数声明符创建一个函数
function cc(){}
```

#### 组成部分

+ **函数的声明：function**
+ **函数的名称：function后面的名称**
+ **函数体：{函数体:执行的内容}**
+ **函数的圆括号：参数值列表**
  + 主要作用：每次使用函数，都可以通过传参实现对函数的值传递

~~~ javascript
function add() {
    //函数体
}
~~~

#### 函数的参数

##### 形参

>  **不赋值的变量名，在函数名称的参数列表内**

##### 实参（arguments）

> **在函数的调用中实参的参数有多个，一般把参数的集合称为参数列表**

特点

1. 有长度，显示传递的实际参数的个数
2. 有下标，自由的根据下标获取某一个实际参数
3. 获取实参列表中的每一个参数：需要使用for循环
4. 函数命名上存在重名现象：
   + 通过判断arugments的长度来判断给函数调用传参

##### 传参

> **调用函数时，在函数的参数列表内，传入实际的值赋值给形参**

##### 返回结果的获取（return）

> **能够在函数外部调用到函数内部的数据**

作用

+ **将函数内部需要使用的数据和程序导出**

表现特点

+ **return返回值和console.log这两种输出不能在函数内部同时使用**

#### 函数的作用域

##### 全局作用域

> **函数外部创造的变量叫做全局变量，具有全局作用域**

##### 局部作用域

> **函数内部创造的变量叫做局部变量，具有局部作用域，仅限于函数内部使用**

##### 声明提前（预解析）

> **将程序找中的所有函数名以及函数的内容提前优先执行**

+ **直接声明**
  + **将变量名称提前，但是变量值不提前**
+ 在ES5中
  + **函数的名称和值都提前**
  + **变量仅仅提前名称**

#### 函数获取设置

##### 如何理解一个函数

1. 函数的功能：任何函数都是解决一个单一的功能

2. 看标签的参数；主要传什么？看参数的类型和个数

3. 需不需要返回：

   * 有return就说明一定有结果；如果没有，那说明函数只是用来执行过程

4. 调用时机

   + 看函数的功能；以及程序所需的功能；

5. 函数是属于谁的：

   + **this：函数的归属对象是谁**

     `只能在函数内通过console.log（this）找出函数式是谁在调用`

##### 函数调用

> **将一个函数执行结果，作为实参在另一个函数内传参；实现函数对函数的调用**

##### **样式设置**

**dom.style.样式属性=“样式的值”；**

~~~html
    <div class = 'warp'>
        <p>样式属性</p>
    </div>
    <script>
        function $(el){return document.querySelector(el)}
        $('.warp p').style.color = '#fff'
        $('.warp p').style.width = '300px'
        $('.warp p').style.height = '300px' 
        $('.warp p').style.background = '#000'
    </script>
~~~

##### 内容获取

**dom.innerHTML**

~~~html
    <div class = 'warp'>
        <p>样式属性</p>
    </div>
    <script>
        function $(el){return document.querySelector(el)}
        $('.warp p').innerHTML = '内容获取'
    </script>
~~~

### 对象

#### 定义

> **包含了所有静态数据和动态方法的集合**

**动态方法**

+ 函数：
  + 每一个函数都封装一段代码；这个代码相当于程序中所做的动作

**静态方法**

+ var
  + 一堆变量或者是变量的集合

#### 创建

+ **使用变量的赋值的方式直接引用一个对象**

  + 语法

    var obj = {}

  + **程序流程**

    + 有一个对象：{}；没有名称存在堆存储中；
    + 我们在栈中使用var声明符创建一个变量
    + 将堆中的{}引用给变量obj；

+ **运用实际方法创建对象**

  + **实例创建：var obj=new Object();**

#### 赋值

**var obj={}; var cc=obj;**

+ 这样的一种赋值方式，是将obj和cc的指向都指向同一个对象内容主体(浅层复制/拷贝)

#### 对象的操作

##### 增

+ **对象.属性=属性值**

  ·当属性名是变量名的时候：可以obj.属性=属性值增加属性

+ **对象["属性名"]=属性值;**

  + 当属性名是一个字符串的时候。我们就可以使用obj[属性名]=属性值

  ~~~JavaScript
  对象.属性=value
  // 向object中添加一个属性值
  	obj.name = "zy";
  // 向obj中添加gender属性
  	obj.gender = "男";
  // 向obj中添加age属性
  	obj.age = 18
  对象["属性名"]=value;
  
  obj["123"] = 789;
  obj["nihao"] = "nihao";
  
  var n = "123";
  console.log(obj[n]);//789
  ~~~

##### 删

+ **delete obj[属性名]**

~~~JavaScript
delete obj.age;
~~~

##### 改

+  **对象.属性名 = 新值** 
+ **对象["属性名"]=新值**

~~~JavaScript
obj.age = 22;
obj["age"] = 22;
~~~

##### 查

+ **获取对象的属性值**
  + 对象.属性
  + **对象[属性]来获取对象的属性**
  + **当调用对象内的方法时：obj.方法名();**

#### 对象内的关键字:this

> **代表对象的指向**

**表现形式**

+ **一般情况下this直接使用在对象方法里**
  + 代表调用这个方法的对象
+ **函数中的this代表了调用这个函数的对象**

#### 遍历获取（for in循环方法）

### 内置对象
#### 定义

> **就是js在推出来给开发人员使用（再带对象、对象的API）**

#### 类型
##### Date对象

> **关于时间日期**

##### 日期对象

+ **var time=new Date()**

  **获取计算机时间**

+ **var myTime=new Date('2020/8/6 17:00')**

  ​	**人为的设置计算机时间**

  **返回**

  ​	**毫秒数：myTime-time**

**类型（API）**

+ **get方法：得到时间，不能修改时间**

  + **getDate()** 

     从 Date 对象返回**一个月中的某一天 (1 ~  31)**。

  + **getDay()**

    从 Date 对象返回**一周中的某一天 (0 ~ 6)**。

  + **getMonth()**

    从 Date 对象返回**月份 (0 ~ 11)**。

  + **getFullYear()**

    从 Date 对象以**四位数字返回年份**。

  + **getYear()**

    请使用 getFullYear() 方法代替。

  + **getHours()** 

    返回 Date 对象的**小时 (0 ~ 23)**。

  + **getMinutes()** 

    返回 Date 对象的**分钟 (0 ~ 59)**

  + **getSeconds()**

     返回 Date 对象的**秒数 (0 ~ 59)**

  + **getMilliseconds()**

    返回 Date 对象的**毫秒(0 ~ 999)**。

  + **getTime()**

    **返回 1970 年 1 月 1 日至今的毫秒数**

+ **set方法：修改时间**

  + **setDate()**

    设置Date对象中**月的某一天(1 ~ 31)**

  + **setMonth()**

    设置Date对象中**月份(0 ~ 11)**

  + **setFullYear()**

    设置Date**对象中的年份（四位数字）**

  + **setHours()**

    设置Date对象中的**小时(0 ~ 23)**

  + **setMinutes()**

    设置Date对象中的**分钟(0 ~ 59)**

  + **setSeconds()**

    设置Date对象中的**秒钟(0 ~ 59)**

  + **setMilliseconds()**

    设置Date对象中的**毫秒(0 ~ 999)**

##### Math对象

**随机数**

​	**Math.random() **

​		**返回 0 ~ 1 之间的随机数**

**区间随机取值**

​	**Math.random()*(max-min)+min**

​		**得到所需要取值范围**

**类型（API）**

+ **Math.abs()**

  获取**参数的绝对值；不分正负；**

+ **Math.celi()**

  **对数进行上舍入**

+ **Math..floor()**

  **对数进行下舍入**

+ **Math,max(x,y)**

  **返回 x 和 y 中的最高值**

+ **Math.min(x,y)**

  **返回 x 和 y 中的最低值**

+ **Math.random() **

  **返回 0 ~ 1 之间的随机数**

+ **Math.round(x)**

  **把数四舍五入为最接近的整数**

##### string对象

###### str.charAt(下标)

> **按照下标找字符**

~~~javascript
var str = "Hello world!"
console.log(str.charAt(1))// e
~~~

###### str.indexOf(‘字符’，下标)

> **按照字符找下标**

+ **index：表示从这个位置开始查找字符**
+ **'字符'：表示要找的字符，如果有返回字符下标，如果没有返回-1**
+ 如果str.indexOf(‘字符串’)
  + **返回的是字符串第一位字符的下标**

~~~javascript
var str = "Hello world!"
console.log(str.indexOf("Hello"))//0
console.log(str.indexOf("World"))//-1
console.log(str.indexOf("world"))//6
~~~

###### str.lastIndexOf(‘字符’，下标)

> **从后往前查找找字符**

+ **下标是开始查找的位置**

~~~javascript
    var str = "Hello world!"
    console.log(str.lastIndexOf("Hello"))//0
    console.log(str.lastIndexOf("World"))//-1
    console.log(str.lastIndexOf("world"))//6
~~~

###### str.concat(str1，str2，str3)

> **字符串拼接**

+  用于连接两个或多个字符串 

~~~javascript
var str1="Hello "
var str2="world!"
console.log(str1.concat(str2))//Hello world!
~~~

###### slice（ start，end）

> **字符串截取**

+ 返回

  + **截取内容，不改变原来的数据**

  **截取的是数组一部分的内容，但是这部分内容不包含end这个下标（包前不包后）**

~~~JavaScript
var str="Hello happy world!"
console.log(str.slice(6))//happy world! 提取从位置 6 开始的所有字符

var str="Hello happy world!"
console.log(str.slice(6,11))//happy 提取从位置 6 到位置 11 的所有字符
~~~

###### substr( start,count)

> **字符串截取**

+ 返回

  + **不会改变原字符串**
  + **返回值是一个新的字符串**

  **从下标开始，截取多少位由count控制**

~~~javascript
var str="Hello world!"
console.log(str.substr(3)) // lo world! 


var str="Hello world!"
console.log(str.substr(3,7)) // lo worl 
~~~

###### substring（index，end）

>  **字符串截取**

+ 返回

  + **不会改变原数组，**
  + **返回值为一个新的字符串**

  **从下标开始，截取位数为count - 1**

  **当index<count时自动调换位置，如果index和count任意一个为负数，则自动转化为0**

~~~javascript
var str="Hello world!"
console.log(str.substring(3))//lo world!

var str="Hello world!"
console.log(str.substring(3,7)//lo w
~~~

###### split()

> **字符串分割**

+ 返回
  + **会改变原值**

~~~JavaScript
var str="How are you doing today?"

document.write(str.split(" "))// How,are,you,doing,today?
document.write(str.split(""))//	 H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,?
document.write(str.split(" ",3))//  How,are,you

"2:3:4:5".split(":")	// ["2", "3", "4", "5"]
"|a|b|c".split("|")	// ["", "a", "b", "c"]

//句子分割成单词

var sentence = 'Hello happy world'
var words = sentence.split(' ')
console.log(words) //["Hello", "happy", "world"]

//将单词分割为字母
var sentence = 'hello'
var words = sentence.split('')
console.log(words)// ["h", "e", "l", "l", "o"]
~~~

##### array对象

###### 数组插入

**在头部插入：arr.unshift(元素)**   **在尾部追加：arr.push(元素)**

###### 数组删除

**从头部删除：arr.shift();**

**在尾部删除：arr.pop()**` 一次只删除一个`

###### 合并数组

+ **arr.concat(brr)**

  将两个数组合并为一个数组：并且重新创建

  ~~~JavaScript
  var hege = ["Cecilie", "Lone"];
  var stale = ["Emil", "Tobias", "Linus"];
  var kai = ["Robin"];
  var children = hege.concat(stale,kai);
  console.log(children)//Cecilie,Lone,Emil,Tobias,Linus,Robin
  ~~~

###### 将数组连接成为字符串

+ **arr.join(‘ ’)**

  小括号中所填的是连接符

  ~~~javascript
  var arr=[2,3,4,5];
  arr.join(‘$’)//'2$3$4$5’
  ~~~

###### 数组截取

+ arr.slice(start，end)

  **包前不包后，不改变原数组，相当于复制，返回值是一个新数组**

  **字符串中也有这个方法**

  ~~~javascript
  var fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
  var citrus = fruits.slice(1,3);//Orange,Lemon
  ~~~

+ arr.splice(start，count)

  **添加或删除数组中的元素 ，会改变原数组。包含开始的下标，返回的是一个新数组**

  ~~~JavaScript
  var fruits = ["Banana", "Orange", "Apple", "Mango"];
  fruits.splice(2,0,"Lemon","Kiwi");//Banana,Orange,Lemon,Kiwi,Apple,Mango
  ~~~


## JavaScript 进阶
### BOM

#### 定义

**由浏览器实现提供javascript程序的一组对象**

#### BOM的组成部分

**window：表示浏览器窗口，Bom的核心**

**document：表示当前页面文档相关信息**

**location：表示当前窗口地址栏相关信息**

**history：表示当前浏览器历史记录相关信息**

**screen：表示客户端屏幕相关信息**

**navigator：表示浏览器自身相关信息**

**EVent：事件**

#### window事件

>  **所有在全局变量声明的变量和函数，自动生成window对象的属性和方法**,
>
> window对象是全局对象，window方法是全局方法

**window,alert() 弹窗**

**window.open(('url','页面的打开方式'))；打开页面**

+ window.open('https://www.baidu.com')//默认是打开新页面
  + _blank 加载到一个新的窗口。这是默认
+ window.open('https://www.baidu.com','_self') 在新页面打开

**window.close()关闭页面**

+ 注意浏览器 不能关闭非弹出窗口

#### 定时器

​	**setInterval():周期性定时器**

+ 参数：
  + 在定时器内需要反复执行的函数
  + .每隔多少时间（毫秒）执行一次上述函数
+ **清除定时器**
  + **clearInterVal()**

**setTimeout()：延时定时器**

+ 参数：
  + .在定时器内需要执行的函数
  + 在多久之后执行这个函数，只执行一次

#### Location对象

> **地址栏对象**

**. location.href：获取或设置地址栏完整路路径**

 **location.search ：获取地址栏？后的参数信息**

 **location.hash 获取地址栏#后的参数信息（锚点信息）**

**location.reload() 刷新⻚页⾯面**

#### 解析地址（url）

`url：http://127.0.0.1:8848/2002A/1.BOM/tohistory.html?name=123&pass=456#box`

`https://www.baidu.com/`

+ **http||https ：网络通讯协议 https加密的**
+ **127.0.0.1 ：ip地址**
+ **baidu.com：域名**
+ **:8848 ：端口 默认端口是80**
+ **2002A/1.BOM/tohistory.html：文件路径**
+ **?name=123&pass=456 页面传值**
+ **#box锚点**

#### History 对象

**history.go()**

+ **n正数:返回历史纪录后n⻚**
+ **n负数:返回历史记录前n⻚**
+ **n为0相当于刷新⻚⾯**

**history.back() 返回上一页**

**history.forward() 返回下一页**

#### 浏览器信息对象

**navigator**

+ **存放了关于浏览器版本，浏览器平台，操作系统的信息**

  **window.navigator.userAgent**

+ 我们可以通过这些信息来判断未来我们的浏览器器到底是⼀一个电脑上还是⼿手机
  上; 如果⼿手机上我们可以判断出到底是ios⼿手机;还是安卓⼿手机

#### 屏幕管理对象

**Screen**

+ **Screen.width 屏幕可用宽度**
+ **Screen.height 屏幕可用高度**

### DOM

#### 定义

**DOM包含了所有HTML元素的属性和方法，以及访问他们的方式**

#### DOM文档对象

#### **document**

**组成部分**

+ **标签/元素名称**
+ **元素/元素的属性节点**
+ **文本内容**

#### DOM节点操作

#### 定义

**HTML中所有的元素都是一个节点**

+ 整个文档是文档节点

+ **所有的标签都是元素节点**
+ 标签内的属性是属性节点
+ 标签内的文本是文本节点

![1612189578429](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1612189578429.png)

#### DOM节点属性

|              |     nodeName     | nodeType | nodeValue |
| :----------: | :--------------: | :------: | :-------: |
| **元素节点** | **大写的标签名** |    1     |   null    |
| **属性节点** |      属性名      |    2     |  属性值   |
| **文本节点** |    **#text**     |    3     | 文本内容  |
| **注释节点** |     #comment     |    8     | 注释内容  |
| **文档节点** |    #document     |    9     |   null    |

#### 获取元素

##### id获取

​	**document.getElementById('id') **

+ **只找一个**

##### class获取

​	**document.getElementsByClassName('类名')** 

+ 返回结果是一个**元素集合**

##### 标签名称获取

​	**document.getEelementsByTagName('标签')**

+ 返回结果是一个**元素集合**

**选择器(单一)**

​	**document.querySelector('css选择器')**

+ 只找一个

**选择器(批量)**

​	**document.querySelectorAll('css选择器')**

+ 返回结果是一个**元素集合**

#### 查找元素

##### 获取元素的所有子节点

​	**元素.children**

+ **伪数组**

##### 获取第一个元素子节点

​	**元素.firstElementChild**

##### 获取最后一个元素子节点

​	**元素.lastElementChild**

##### **获取下一个兄弟节点**

​	**元素.nextElementSibling**

##### 获取上一个兄弟节点

​	**元素.previousElementSibling**

##### 获取父节点

​	**元素.parentNode**

#### **类数组转化**

##### 伪数组定义

​	**获取的元素集合称为类数组对象,伪数组**

##### 伪数组特征

+ 跟数组一样有length和下标
+ 但是不能使用数组的方法
+ 想要使用数组方法,需要转化为数组

**转化方式**

+ **[...类数组]**

+ **Array.from(类数组)**

#### 元素类名

##### 类数组：classList

+ **classList.add()** 
  + **添加类名**
+ **classList.remove()** 
  + **删除类名**
+ **classList.contains()** 
  + **检测类名是否存在** 
  + **返回布尔值**
+ **classLIst.toggle()**
  + **类名存在则删除，类名不存在则添加**

#### 数组迭代方法

**forEach()**

+ **普通的for循环,没有返回值**

**map()**

+ **得到每⼀项的返回结果组成的数组**

**filter()**

+ **筛选出返回条件为真的项组成的数组**

**some()**

+ **数组中只要有⼀项为真就返回true**

**every()**

+ **数组中所有项为真就返回true,否则返回false**

### DOM节点

#### 创建元素

**标签名称**

​	**document.createElement('标签名称')**

**文字内容**

​	**document.createTextNode('里面放的是文字内容')**

#### 设置/修改元素内容

​	**Dom.innerHTML**

#### 操作元素

##### 标准属性

> **a.href，div.className，img.src，a.target，，div.style，img.alt，div.title**

**删除**：**dom.removeAttribute('属性名称')**

##### 自定义属性

**添加**

​	**元素.setAttribute('属性名称'，'值')**

​	**功能：设置自定义属性**

**删除**

 	**元素.removeAttribute(‘自定义属性名’)**

​	**功能：删除自定义属性**

**修改**

​	**元素.setAttribute('属性名称'，'值')**

​	**功能：修改自定义属性**

**查找**

​	**元素.getAttribute(‘⾃自定义属性名’)**

​	**功能：获取自定义属性**

**获取属性列表**

​	元素.attributes

#### **插入创建好的元素**

**追加**

+ 语法：

  ​	**parentNode.appendChild(child)**

+ 功能： 

  ​	**向父节点的子节点列表的末尾添加新的子节点**

**插队**

+ 语法：
  + **parentNode.insertBefore(新节点, 被插队的节点 )**

+ 功能： 
  + **在已有的子节点前插入一个新的子节点**

#### 元素的删除

+ 语法：

  **parentNode.removeChild(child)**

+ 功能： 

  **从子节点列列表中删除某个节点**

#### 元素的复制

+ 语法

  **元素.cloneNode(true)**

+ 功能

  **克隆隆一个节点**

#### 元素的替换

+ 语法：

  **parentNode.replaceChild(新节点, 被替换的节点 )**

+ 功能：

#### 文本节点

+ 语法：

  **document.createTextNode(‘文本内容’)**

+ 功能：

   **创建文本节点**

### 事件

#### 定义

**文档与浏览器特定的交互瞬间**

#### 事件三要素

**事件源，事件类型，事件处理函数**

~~~JavaScript
btn.onclick = function(){
    console.log('111')
}
//事件源：btn
//事件类型：click
//事件处理函数：function
~~~

#### 事件函数

##### HTML事件处理理程序

~~~html
<button onclick = "alert(1)">按钮</button>
~~~

##### DOM0级事件处理理程序

~~~JavaScript
var btn = document.querySelector('button')
btn.onclick = function () {
    console.log('111')
}
//捣毁DOM0级

btn.onclick = null
~~~

**捣毁DOM0级事件：btn.onclick = null**

##### DOM2级事件处理理程序

~~~javascript
//事件源.addEventListener(事件类型，事件处理函数，事件流)

btn.addEventListener('click',function(){
    // ... 
},false)

var fn1 = function(){
    alert(1)
}
btn.addEventListener('click',fn1,false)
//特点：可以绑定多次事件
//缺点：销毁不了匿名函数

//捣毁DOM2级
btn.removeEventListener('click',fn1)
~~~

#### 事件类型

##### 鼠标事件

1. **click 点击事件**
2. **dblclick双击事件**
3. **mouseover 鼠标滑过事件**
4. **mouseout 鼠标移出事件**
5. **mousedown 鼠标按下事件**
6.  **mouseup 鼠标抬起事件**

7. **mousemove 鼠标移动事件**

~~~JavaScript
btn.addEventListener('click',function(){
    console.log(1222)
})
~~~

##### 键盘事件

**根据事件对象的keyCode判断当前按得是哪个键**

1. **keydown 键盘按下**
2. **keyup 键盘抬起**
3. **keypress 键盘按下抬起**

~~~javascript
document.addEventListener('keydown', function (event) {
    // 事件对象：触发事件的时候会产生一个事件对象，事件对象中包含关于事件的所有信息
    if (event.keyCode === 13) {
        console.log('点击的回车')
    }
})
document.addEventListener('keyup', function () {
    console.log('键盘抬起')
})
document.addEventListener('keypress', function () {
    console.log('keypress')
})
~~~

| 键位                    | 码值  | 键位                   | 码值   |
| ----------------------- | ----- | ---------------------- | ------ |
| 0~9（数字键）           | 48~57 | A~Z（字母键）          | 65~90  |
| Backspace（退格键）     | 8     | a~z（字母键）          | 97~122 |
| Enter（回车键）         | 13    | Space（空格键）        | 32     |
| Left arrow（左箭头键）  | 37    | Top arrow（上箭头键）  | 38     |
| Right arrow（右箭头键） | 39    | Down arrow（下箭头键） | 40     |

##### 表单事件

1. **获取焦点：onfocus**
2. **失去焦点：onblur**
3. **表单修改value：onchange**
4. **输入触发：oninput**
5. **表单提交：onsubmit**

~~~javascript
var input = document.querySelector('.text')
input.addEventListener('focus', function () {
    console.log('获取焦点')
})
input.addEventListener('blur', function () {
    console.log('失去焦点')
})
input.addEventListener('change', function () {
    console.log('change事件')
})
input.addEventListener('input', function () {
    console.log('input事件')
})


var checkbox = document.querySelector('.checkbox')
checkbox.addEventListener('change', function (e) {
    console.log('复选框修改状态了', checkbox.checked)
})

var select = document.querySelector('select')

select.addEventListener('change', function (e) {
    console.log('下拉框的值修改了', select.value)
})

~~~

~~~html
<!--表单提交-->
<form id='test_form' action='' method='' omsubmit='return checkForm()'>
    <input type='text' name='username' value='' id="user"/>
    <input type='password' name='pwd' value ='' id="pass"/>
    <button type='submit'>提交</button>
</form>

<script>
    function $(el){return document.querySelector(el)}
    var input = document.getElementById('test_form');

    input.addEventListener('submit',function(){
        console.log('提交了',$('#user').value,$('#pass').value)
    })
</script>
~~~

##### window对象

1. **页面加载完成：onload**
2. **改变窗口尺寸：onresize**
3. **监听页面滚动：onscroll**
4. **获取页面滚动条的距离**
   + **Document.documenElement.scrollTop**
   + **Document.documenElement.scrollLeft**

~~~JavaScript
window.onload = function () {
    // 页面加载完成
    var title = document.querySelector('h2')
    console.log(title)
}

window.addEventListener('load', function () {
    var title = document.querySelector('h2')
    console.log('页面加载成功', title)
})

改变窗口尺寸
window.onresize = function () {
    console.log(window)
}

监听页面滚动事件
window.onscroll = function () {
    console.log('页面滚动了')
}
~~~

#### 事件对象

##### 定义

​	**触发事件的时候会产⽣生一个事件对象，事件对象中包含关于事件的所有信息**

##### 事件对象的获取方法

~~~JavaScript
btn.addEventListener('click', function (event) {
    // 处理理兼容性问题（针对IE）
    var e = event || window.event
    // 获取事件源
    var target = e.target || e.srcElement
    })
~~~



### 同步和异步

#### 执行环境

##### 单线程

**定义**

**一次只是执行一次任务，如果有多个任务，就必须排队，等前面的任务执行完毕，在执行一个任务**

**缺点**

+ **只要存在一个任务耗时很久，后面的任务都必须排队等着，会拖延整个程序的执行**

`常见的浏览器无响应（假死）往往就是因为某一段JS代码⻓长时间运行（比如死循环），导致整个页面卡在某个任务，其它任务无法执行`

**解决方法**

### 事件流

#### 定义

**事件流就是事件传递，传递的是事件的触发**

**传递范围**

从真正触发的元素（最先出发的事件）到document

**传递的顺序**

+ 浏览器分为两大类：
  + IE浏览器 -----非标准浏览器
  + 非IE浏览器 ----标准浏览器
+ 两大类浏览器执行流程分别
  + 标准浏览器
    + 统计顺序是从父级到子级 从外到内
    + 触发事件
    + 事件执行：从子级到父级 从内到外
  + 非标准浏览器
    + 没有获取统计环节
    + 只有触发
    + 事件执行：从子级到父级 从内到外

#### 传递规则

**先捕获，再冒泡**



##### 事件冒泡

**从具体的元素开始触发，逐级网上不到具体的元素触发（从内到外执行）**

![1612230233046](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1612230233046.png)

##### 事件捕获

**从不太具体的元素开始触发，具体的元素最后触发（由外向内指向）**

![1612230346229](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1612230346229.png)

#### DOM事件流

##### 组成

DOM2级事件规定事件流包括三个阶段：**事件捕获阶段，事件⽬目标阶段，事件冒泡阶段**

**事件捕获 > 事件冒泡**

![1612230786029](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1612230786029.png)

##### DOM0级事件

**元素.on+事件类型=function(){} ---绑定事件**

**元素.on+事件类型=null ---移除事件**

**相同的事件后面的会覆盖前面的**

##### DOM2级事件

**元素.addEventListener('事件类型',function(){},boolean) ---绑定事件**

**元素.removeEventListener('事件类型',function(){},boolean) ---绑定事件**

**true:捕获阶段执行**
**false:冒泡阶段执行**

##### 阻止冒泡

+ **ev.stopPropagation()**

##### 取消默认行为

+ **ev.preventDefault()**

**事件源**

+ **ev.target || ev.srcElement**

#### 事件委托

##### 定义

**利用事件冒泡的特性，可以把⼦元素的同⼀类型事件委托给父元素集中管理**

##### 优点

**事件委托绑定事件比循环绑定事件好在哪？**

+  减少页⾯面中的事件处理程序，减少DOM操作提升性能
+ 可以给渲染的数据提前添加事件

~~~JavaScript
$('ul').addEventListener('click', function (e) {
    if (e.target.nodeName === 'LI') {
        console.log(e.target.innerHTML)
    }
})
~~~

### 元素位置尺寸

#### 元素尺寸

**dom.offsetTop：相对于定位父元素顶部的距离,margin+top**

**dom.offsetLeft：相对于定位父元素左边的距离,margin+left**

**dom.offsetWidth 元素的外宽 width+padding+border**

**dom.offsetHeight：元素的外高 height+padding+borde**

**dom.clientWidth：元素的内宽 width+padding**

**dom.clientHeight：元素的内高 height+padding**

#### 浏览器的尺寸

**window.innerWidth 浏览器的宽高 ----包含滚动条**

**window.innerHeight**

**document.documentElement.clientWidth 浏览器的宽高 不包含滚动条**

**document.documentElement.clientHeight**

**document.documentElement.scrollWidth 页面的实际宽高**

**document.documentElement.scrollHeight**

#### 滚动条滚动距离

**document.documentElement.scrollTop**

#### 事件对象相关的位置

**e.clientX 鼠标距离浏览器的位置**

**e.clientY**

**e.offsetX 鼠标距离盒子边界长度的 width+padding**

**e.offsetY**

**e.pageX 鼠标距离页面的位置**

**e.pageY**

### json

#### 定义

**json仅仅是⼀种数据的格式,数据类型是字符串**

+ json数据格式也是采⽤用键值对的形态存在的，但是所有的**键名都必须以字符串的形式存在**
+ 在所有的数据中键值对之间⽤用逗号隔开，对象之间⽤用逗号
+ **{}表示对象，[]表示数组**

#### 格式

##### 数组格式

~~~json
['a','b']
[1, 2, 3, 4]
[
    {
        "name": "⼩小明",
        "age": 12,
        "hobby": ["唱歌", "跳舞"],
        "active": true // false null
    }
]
~~~

##### 对象格式

~~~json
{
    "name": "⼩小明",
    "age": 12,
    "hobby": ["唱歌", "跳舞"],
    "active": true // false null
}
~~~

##### JSON格式转化

 **对象转json ： var json = JSON.stingify(obj)**

**json转对象： var obj = JSON.parse(json)**

~~~JavaScript
var json = '[{"name": "小明", "age": 12, "active": true, "hobby": ["唱歌", "跳舞"]}]'
// json转对象
var obj = JSON.parse(json)
console.log(obj)//{name: "小明", age: 12, active: true, hobby: Array(2)}
// 对象转json
console.log(JSON.stringify(obj))//[{"name":"小明","age":12,"active":true,"hobby":["唱歌","跳舞"]}]
~~~

### ajax

#### 定义

是指⼀种创建交互式、快速动态网页应用的网页开发技术， **通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更更新。**

#### http环境

+ **本地：C:/Users/JASON/Desktop/2/index.htm**
+ **http环境 https：//www.baidu.com**

#### URL地址

**确定一个网站，不同的地址能确定一个服务器**

~~~JavaScript
https://www.baidu.com/
https://m.gmw.cn/baijia/2020-05/19/33840738.html
https://www.baidu.com/s?cl=3&tn=baidutop10&&hisfilter=1

协议：http无加密 https加密的
域名：www.baidu.com
端口 :8848 :80
页面路径 baijia/2020-05/19/33840738.html
页面查询参数 ?cl=3
			&tn=baidutop10
			&hisfilt er=1
锚点：#
~~~

#### 请求路径

+ **相对**
  + ajax.html
  + ../ajax.html

+ **绝对**
  + http://localhost:3000/cookie.html
  + /cookie.html

#### ajax作用

+ **向服务端发送请求（浏览器-服务端）**
  + Xhr.open()
  + Xhr.send()
  + 请求头 xhr.setRequestHeader()
+ **获取服务端返回的数据 （服务端-浏览器）**
  + 响应内容 xhr.responseText
  + 响应头：xhr.getAllResponseHeaders

#### ajax请求步骤

1. **创建xhr核⼼心对象， readyState：0**

~~~javascript
var xhr = new XMLHttpRequest();
~~~

2. **建⽴立浏览器器端和服务器器端的联系， readyState：1**

~~~javascript
// xhr.open('请求⽅方式 GET POST', '请求的地址')
xhr.open('GET', 'http://127.0.0.1:5500/data.json')
~~~

3. **创建链接完毕，发送内容， readyState：1**

~~~javascript
xhr.send()
~~~

4. **接受数据，readyState：2，3，4**

~~~javascript
xhr.onreadystatechange = function () {
    // 确定服务端响应成功，再读取数据 xhr.readyState === 4
    // 确定请求地址成功 xhr.status === 200
    if (xhr.readyState === 4 && xhr.status === 200) {
        // 获取服务端返回的json格式的数据 xhr.responseText 字符串串类型，需要转成对象
        var data = JSON.parse(xhr.responseText)
        console.log(data)
    }
}
~~~

#### 状态码(readyState)

+ **0：创建xhr**

+ **1：发送完毕**
+ **2：准备接收服务端数据**
+ **3：已经接收但是不一定接收完毕**
+ **4：接收完毕**

#### 服务器状态码(status)

+ 200
  请求的网页已永久移动到新位置，即永久重定向。

+ 301
  此次请求返回的网页未修改，继续使用上次的资源。

+ 304
  服务器找不到请求的网页。

+ 404
  服务器遇到错误，无法完成请求。

+ 500

  服务器遇到错误，无法完成请求

#### 获取接收的数据

~~~JavaScript
xhr.responseText 文本
xhr.responseXML 接收的是xml**
~~~

#### **content-type**

~~~JavaScript
application/x-www.form-urlencoded
multipart/form-data  表单数据
application/json json数据
~~~

#### get和post请求的区别

+ **安全性post更好**

+ **执行率get更高**

+ **传递的数据量post更大**

+ **传递参数的方式不一样**

  + **get：通过在url后边加查询字符去传递**

  ~~~JavaScript
  xhr.open('get','http://localhost:3000/24.ajax/web/shop.jsonname='+$('.user').vlaue+'&pass='+$('.pass').vlaue)
  xhr.send()
  ~~~

  + **post：通过请求体传送的 在send()里**

  ~~~JavaScript
  xhr.open('post','http://localhost:3000/24.ajax/web/shop.json')
  xhr.setRequestHeader('content-type','application/x-www.form-urlencoded')
  xhr.send('user=12345&pass=543321')
  ~~~

#### AJAX：GET请求

~~~JavaScript
1. 创建ajax核心对象
var xhr=new XMLHttpRequest();
console.log(xhr)
console.log(xhr.readyState) //此时状态码是0

//2.建立浏览器端和服务端的联系
//open的参数：第一个参数是请求方式： get post；第二个参数是：请求的路径

xhr.open('get','http://localhost:3000/24.ajax/web/shop.json');
console.log(xhr.readyState) //此时状态码是1

//3.当创建链接完毕之后，我们需要将内容发送出去
xhr.send()
console.log(xhr.readyState) //此时状态码是1

//4.接收数据
xhr.onreadystatechange=function(){//监听状态码
    // xhr.readyState 状态码 01234
    console.log(xhr.readyState) //234
    if( xhr.readyState===4){//当状态码等于4的时候，说明我们已经接收完毕
        var json=xhr.responseText //获取接收的数据
        console.log(json)
    }
}
~~~

#### AJAX：POST请求

**post请求必须写请求头**

~~~javascript
1. 创建ajax核心对象
var xhr=new XMLHttpRequest();
console.log(xhr)
console.log(xhr.readyState) //此时状态码是0

//2.建立浏览器端和服务端的联系
//open的参数：第一个参数是请求方式： get post 第二个参数是：请求的路径

xhr.open('post','http://localhost:3000/24.ajax/web/shop.json');

// 注意：post请求必须写请求头
xhr.setRequestHeader('content-type','application/x-www.form-urlencoded')
console.log(xhr.readyState) //此时状态码是1

//3.当创建链接完毕之后，我们需要将内容发送出去
xhr.send()
console.log(xhr.readyState) //此时状态码是1

//4.接收数据
xhr.onreadystatechange=function(){//监听状态码
    // xhr.readyState 状态码 01234
    console.log(xhr.readyState) //234
    if( xhr.readyState===4){//当状态码等于4的时候，说明我们已经接收完毕
        var json=xhr.responseText //获取接收的数据
        console.log(json)
    }
}
~~~

### 跨页面传值

#### 地址栏传参

+ **用location.href跳转，url后面拼接参数**
  + location.href 拼接 ?key1=value1&key2=value2

~~~html
<style>
    li {
        line-height: 45px;
        background: red;
        border-bottom: 1px dashed;
    }
</style>
<body>
    <h2>页面1</h2>
    <ul>
        <li>javascript</li>
        <li>html</li>
        <li>css</li>
        <li>vue</li>
        <li>react</li>
        <li>node</li>
        <li>html5+css3</li>
        <li>小程序</li>
    </ul>

    <script>
        var ul = document.querySelector('ul')
        ul.addEventListener('click', function (e) {
            if (e.target.nodeName === 'LI') {
                var str = '?text=' + e.target.innerHTML + '&time=' + Date.now()
                console.log(str)
                location.href = 'http://127.0.0.1:5500/index2.html' + str + '&name=小明'
            }
        })
    </script>
~~~

+ **获取参数 location.search接受数据，解析**

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>页面2</title>
</head>
<body>
    <h2 id="title">页面2</h2>


    <script>
        // encodeURIComponent('中文') 转码 "%E4%B8%AD%E6%96%87"
        // decodeURIComponent("%E4%B8%AD%E6%96%87") 解码 "中文"
        // location.search 获取地址栏查询参数
        var str = decodeURIComponent(location.search).substr(1) // 解码中文，并且删除字符串中的？
        var arr = str.split('&') // 根据 & 拆分成数组
        var obj = {} // 定义对象存储地址栏参数
        // 遍历数组
        arr.forEach(function (val) {
            // 数组中的每一项根据 = 号拆分成数组
            var arr2 = val.split('=')
            console.log(arr2[0], arr2[1])
            // 数组的第一项作为 obj 的key,第二项作为obj的value
            obj[arr2[0]] = arr2[1]
        })
        var time =  new Date(Number(obj.time)).toLocaleString()
        title.innerHTML = obj.name + ' 在 ' + time + ' 点击了 ' + obj.text
        
    </script>
</body>
</html>
~~~

#### Web存储

+ **本地存储**
  + **临时存储：sessionStorage**
  + **永久存储：localStorage**

+ **cookie**

##### localStorage:永久存储

**作用**

+ 在HTML5中，新加入了了⼀个localStorage特性，这个特性**主要是用来作为本地存储来使用**的，**解决了cookie存储空间不足的问题 (cookie中每条cookie的存储空间为4k)**

+ localStorage中⼀般**浏览器支持的是5M大小**，这个在不同的浏览器中localStorage会有所不同。

**(注意 localStorage 只⽀支持 string 类型的数据存储)**

~~~JavaScript
// 存数据
localStorage.setItem('key', 'value')

// 读取数据
localStorage.getItem('key')

// 删除⼀一条数据
localStorage.removeItem('key')

// 清除所有数据
localStorage.clear()
~~~

##### sessionStorage:临时存储

**作用**

+ sessionStorage ⽤用于**临时保存同⼀窗⼝(或标签页)的数据**，在**关闭窗口或标签页之后将会删除这些数据**。
+ **语法：和localStorage一样**

##### cookie

**作用**

+ 浏览器存储数据的方式，浏览器发起请求的时候，会自动把cookie中存储的内容，携带并发送到服务器，

  **容量: 4k**

**获取**

+ **document.cookie**

##### 添加cookie

+ **document.cookie = "key=value"**

##### cookie长期保存

**在实际开发中，cookie常常需要长期保存**

~~~javascript
//保存⽤用户登录的状态
//GMT_String是以GMT格式表示的时间字符串
document.cookie="userId=828;expires=GMT_String"


//将userId这个cookie设置为GMT_String表示的过期时间，超过这个时间，cookie将消失，不可访问

// GMT_String: new Date().toGMTString();
var date=new Date();

var expiresDays=10; //将date设置为10天以后的时间

//将userId和userName两个cookie设置为10天后过期

date.setTime(date.getTime()+expiresDays*24*3600*1000); 

document.cookie="userId=828; userName=hulk;expires="+date.toGMTString()


~~~

##### cookie实例

~~~JavaScript
//设置
document.cookie = "userId=4009512"
document.cookie = "pass=1234567"
//cookie 过期时间
//GMT_String 时间格式
var data = new Date（'2020-1-12'）.toGMTString();
document.cookie = "user=4009512;exprires="+date；
//如果要删除这一条cookie
//把这条cookie的过期时间写到当前时间就可以删除
var data = new Date（'1999-10-12'）.toGMTString();
document.cookie = "user=4009512;exprires="+date；
~~~

#### 区别

**cookie**

    document.cookie
    特点：
        本地存储
        回话缓存
        有效时间  时间格式： toString（）  toUTCString() toGMTString()
        安全性
        必须在服务器运行
        4k
        发送请求的时候，会携带cookie

**localStorage && sessionStorage**

localStorage:
    5m
    永久存储
     不需要在服务器环境下就能使用

sessionStorage:
    会话级
    临时存储

**api**

    localStorage.setItem(key,val);
    localStorage.getItem(key);
    localStorage.removeItem(key);
    localStorage.clear()

##### Web存储案例

~~~html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>页面1</title>
    </head>
    <style>
        li {
            line-height: 45px;
            background: red;
            border-bottom: 1px dashed;
        }
    </style>
    <body>
        <h2>页面1</h2>
        <ul>
            <li>javascript</li>
            <li>html</li>
            <li>css</li>
            <li>vue</li>
            <li>react</li>
            <li>node</li>
            <li>html5+css3</li>
            <li>小程序</li>
        </ul>
    </body>
</html>
<script>
    // 没有跨域的页面可以使用同一个本地数据，（相同协议，相同域名，相同端口表示没有跨域）
    // 获取本地数据，如果本地没有数据就使用[]
    // localStorage 存的都是string类型的数据，如果存数组或者对象的话，需要转成json类型，获取的时候再转成对象
    var arr = JSON.parse(localStorage.getItem('stringArr')) || [];

    var ul = document.querySelector('ul')
    ul.addEventListener('click', function (e) {
        if (e.target.nodeName === 'LI') {
            arr.push(e.target.innerHTML)
            localStorage.setItem('stringArr', JSON.stringify(arr))
            location.href = 'http://127.0.0.1:5500/web%E4%BC%A0%E5%8F%82/index2.html'

            // 本地存储（永久存储）
            // localStorage.setItem('clickString', e.target.innerHTML)
            // // 获取
            // if (localStorage.getItem('clickCtring')) {
            //     // 删除
            //     localStorage.removeItem('clickCtring')
            // }
            // 清空
            // localStorage.clear()
            // location.href = 'http://127.0.0.1:5500/web%E4%BC%A0%E5%8F%82/index2.html'
        }
    })
</script>
~~~

~~~html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>web传参</title>
    </head>
    <body>
        <h2>web传参</h2>
        <ul id="list"></ul>
    </body>
</html>
<script>
    // 获取本地数据
    var arr = JSON.parse(localStorage.getItem('stringArr')) || []

    console.log('本地存储的数据',arr)
    list.innerHTML = arr.map(function (val) {
        return '<li>' + val + '</li>'
    }).join('')

    list.addEventListener('click', function (e) {
        if (e.target.nodeName === 'LI') {
            // 筛选
            arr = arr.filter(function (val) {
                return val !== e.target.innerHTML
            })
            list.removeChild(e.target)
            localStorage.setItem('stringArr', JSON.stringify(arr))
        }
    })
</script>
~~~



### 面向对象

#### 作用域

+ **全局作用域:** 全局变量拥有全局作用域,可以在任何地方使用
+ **局部作用域**: 局部变量拥有局部作用域,只能在定义的函数内使用
+ **变量提升**：
  + **使用var关键字声明的变量会将（var 变量量名)提升到当前作⽤用域最**
    **顶端,赋值留留在原地**
+ **函数提升**
  + **函数声明会提升到当前作用域的最顶端**

#### This

​	**this 在 js 中指的是行上下文环境对象** 

##### this指向
+ 全局中的this
  + **window对象**
+ 函数中的this
	+ **调⽤用函数的对象,谁调⽤用指向谁**
+ 事件处理理函数中的this 
  + **绑定事件的元素**
+ 构造函数中的this
  +  **实例例化对象**

~~~JavaScript
function $(el){return document.querySelector(el)}
console.log(this);//window
function aa(){
    console.log(this)//window
}
aa()

$('.box').onclick = function(){
    console.log(this);
}

var obj = {
    name:123,
    fn:function(){
        console.log(this);
        alert(1)
    }
}
obj.fn()//函数在obj里面运行，fn里面的this指向是obj
~~~

#### 面向对象

##### 定义

**面向对象编程是一种设计模式（编程思想），将对象作为基本单元，将程序和数据封装**

##### 特征

+ **封装**
  + 让使用对象的⼈不考虑内部实现，只考虑功能使用 把内部的代码保护起来，只留出一些个api接口供用户使用
+ **继承**
  + 就是为了代码的复用，从父类上继承出⼀些方法和属性，子类也有自⼰的⼀些属性
+ **多态**
  + 对象的多功能，多方法，⼀个方法多种表现形式

##### 工厂模式

+ 为什么使用工厂模式？
  +  **解决了了创建多个相似对象(结构相同)的问题**

~~~JavaScript
function student(name,sex,age){
    var obj = new Object();
    obj.name = name;
    obj.sex = sex
    obj.age = age;
    return obj
}
~~~

##### 构造函数模式

+ 为什么使用构造函数模式？
  + **解决了对象识别问题,（即如何得知⼀个对象的类型）**
+ **检测一个对象是否是某一个构造函数的实例**
  + **对象 instanceof 构造函数名**
  + **constructor**

~~~javascript
function Student(name,age,sex){
    var obj = new Object()//自动创建一个对象
    //把this指向obj
    this.name = name;
    this.age = age;
    this.sex = sex;
    this.className = '17098B'
    return obj//将创建的obj返回
}
var a = new Student('阿生','男',3)//实例化
~~~

##### 原型模式

+ **在原型对象中定义共有的属性和方法**

+ 为什么使用原型模式？
  + **解决了多个对象具有相同的属性或方法被重复创建的问题**
+ 查找对象的属性的时候会先查找对象本身的属性
+ **如果对象本身没有此属性，会从原型对象上找，直到找不到**
+ `实例对象._proto_ === 构造函数.prototype`

~~~javascript
Student.prototype = {//prototype 构造函数找原型
    constructor:Student,//原型对象找构造函数
    money:'$200',
    car:'绿源电动车'
}
~~~

##### 三部曲

+ **构造函数**
+ **原型对象**
+ **实例化**

~~~JavaScript
// 构造函数
function Tab(opt){
    this.init(); //自调用
}
// 原型对象
Tab.prototype = {
    constructor：Tab,
    init:function(){
        
    }
    addEvent:function(){
        
    }
}
// 实例对象

new Tab ({
    //对象传参
})
~~~

##### 原型链

**定义**

**如果没有去隐式原型上找；**

**如果没有的话，去下一个隐式原型上找**

**每个对象都有proto,指向的是原型**

**这样的链式结构就是原型链**

![1612256548749](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1612256548749.png)

### 正则

#### 定义

​	**正则表达式，也叫规则表达式, 是对字符串操作的⼀种逻辑公式**

#### 特征

+ **使用极简单的方式，去匹配字符串**
+ **速度快，代码少**
+ **在复杂的字符串中快速精准的匹配想要的字符**

#### 创建

+ 字面量
  + **var reg = / 规则/修饰符**
+ 实例化
  + **var reg = new RegExp( 规则 ，修饰符 )**

#### 基本语法

##### 修饰符

| **i** | **忽略略大小写** |
| :---: | :--------------: |
| **g** |   **全局匹配**   |
|   m   |     多行匹配     |

##### 元字符

|       **\d**        | **匹配数字**             |
| :-----------------: | ------------------------ |
|       **\D**        | **匹配非数字**           |
|       **\w**        | **匹配数字字母下划线**   |
|       **\W**        | **匹配非数字字母下划线** |
|       \s****        | **匹配空字符**           |
|       **\S**        | **匹配非空字符**         |
|         \b          | 匹配单词边界             |
|         \B          | 匹配非单词边界           |
| **[\u4e00-\u9fa5]** | **匹配中⽂文**           |

##### 特殊字符

|    \    | **转义字符,将在正则中有特殊含义的字符转为普通字符** |
| :-----: | :-------------------------------------------------- |
| **[]**  | **中括号中的字符匹配任意⼀个**                      |
|  **^**  | **以什么开始**                                      |
|  **$**  | **以什么结束**                                      |
| **[^]** | **取反,除了中括号里以外的字符**                     |
|  **.**  | **除了换行以外的任意字符**                          |
|   \|    | **或**                                              |
| **()**  | **分组**                                            |

##### 限定符

| **{n,m}** | **匹配n-m个**                |
| :-------: | ---------------------------- |
|  **{n}**  | **匹配n个**                  |
| **{n,}**  | **最少匹配n个**              |
|   **+**   | **⼀个或多个，相当于{1,}**   |
|   *****   | **0个或多个，相当于{0,}**    |
|   **?**   | **0个或⼀一个，相当于{0,1}** |

#### 常见正则

##### 手机号正则

~~~javascript
// 以数字1开头
// 第⼆位不能是[012]
// 后9位任意数字
var reg = /^1[3-9]\d{9}$/
~~~

##### 邮箱正则

~~~javascript
// 开头可以多个是数字字⺟母下划线
// 中间有@符
// @符后也是多个数字字⺟母下划线
// 接着匹配 .
// 后⾯面跟常⻅见尾缀(com | cn | net)
var reg = /^\w+@\w+\.(com|cn|net)$/
~~~

##### QQ正则

~~~javascript
1 // 不不能以0开头
2 // ⻓长度为5-11位
3 var reg = /^[1-9]\d{4,10}$/
~~~

##### 网址正则

~~~javascript
// http开头,s可有可⽆无,后⾯面是://
// @前是数字字⺟母下划线
// @后.前是数字字⺟母下划线
// .后是尾缀
var reg = /^https?:\/\/w{3}\.\w+\.(com|cn|net)}$/
~~~

##### 匹配前后空格

~~~javascript
// 只匹配开头或结尾，不不管中间
 var reg = /^\s*|\s*$/g
~~~

#### 使用方法

##### 正则test()方法

语法：**正则.test(字符串)**

返回值：**布尔值**

~~~JavaScript
var reg = /[0-9]/
reg.test('aaaaa')
reg.test('aaaa1')
~~~

##### 字符串 match() 方法

语法: **字符串.match(正则)**

返回值: **数组**

**match()方法返回匹配项组成的数组(支持全局匹配)**

~~~JavaScript
var str = 'ababa'
var res = str.match(/a/g)
// res => ["a", "a", "a"]
~~~

##### 正则exec()方法

语法: **正则.exec(字符串)**
返回值: **数组**
**exec()方法返回匹配项组成的数组(不支持全局匹配)**

不加g永远只能找到第⼀一个
加g该方法调用一次匹配第一个，再调⽤用⼀一次匹配第二个，以此类推，找不到返回null

~~~JavaScript
var str = 'ababa'
var reg = /a/g

reg.exec(str)// ["a", index: 0, input: "ababa", groups: undefined]
reg.exec(str)// ["a", index: 2, input: "ababa", groups: undefined]
reg.exec(str)// ["a", index: 4, input: "ababa", groups: undefined]
reg.exec(str)// null
~~~

##### 字符串的split()方法

**split方法支持使用正则当做分隔符**

~~~JavaScript
var str = 'a-a-a-a'
str.split(/-/g) // ["a", "a", "a", "a"]
~~~

##### 字符串的replace()方法

**replace方法支持使用正则匹配替换的字符串**

~~~javascript
var str = 'abab'
str.replace(/a/g, 'c') // 'cbcb'
~~~



----



## 模块化

### 认识模块化

1. **把一个复杂系统分解成各个模块**
2. **每个模块完成指定的功能**
3. **各个模块之间互不影响**
4. **模块与模块之间要有明确的规定配合工作**

### 模块化的意义

1. **代码的可复用性**
2. **代码的可维护性**
3. **更加友好的组织代码**
4. **便于团队协作**
5. **减少单个文件的体积**

### 模块化的规范

+ script标签
  + 可以减少单个文件的体积
  + 模块与模块之间会相互污染
  + 难以维护模块之间的关系
  + 代码阅读时不容易理清相互之间的逻辑
  + 文件加载时并非是按需加载
+ commonjs（node端实现）

+ **AMD 规范（require.js）**
+ **CMD 规范**

### 使用require

#### 在html中引入`require`

>  `data-main`自定义属性，定义入口文件的路径，省略`.js`后缀

~~~javascript
 <script src="./js/libs/require.js" data-main="./js/main"></script>
~~~

#### 定义模块`define`

+ 参数:
  + **第一个参数：数组，数组的内容是当前模块所需要依赖的模块名称（模块文件路径）,`如果没有依赖，可以省略第一个参数`**
  + **第二个参数：回调函数，里面就是我们封装的代码回调函数里面的形参是依赖模块的输出**
+ **定义模块的时候必须有输出**

~~~JavaScript
define([],function () {
    function $(sel) {
        return document.querySelector(sel)
    }
    function gets(sel) {
        return [...document.querySelectorAll(sel)]
    }
    return {$,gets}
});
~~~

#### 配置 `require.config`

> 在入口文件中 配置模块名称与模块路径(省略`.js`后缀)

~~~javascript
require.config({
    paths: {
        "get": './getDom',
        //"模块名称":"模块文件的路径"
        "click": "./click"
    }
})
~~~

#### 调用模块 `require`

+ 参数
  + **第一个参数**
    + 数组，
    + 数组的内容是调用的模块名称（路径）
  + **第二个参数：**
    + 回调函数
    + 回调函数里面的形参是调用模块的输出，要注意与引用的模块名称一对应

~~~JavaScript
require([
    'get',
    "click"
], function (_$, click) {
    console.log(_$)//{}
    console.log(_$.$('#app'))
    click()

})
~~~



## 移动端
### Sass

#### 定义

+ **Sass 是一种 CSS 的预编译语⾔言。它提供了 变量、嵌套、 混合（mixins）、 函数等功能，并且完全兼容 CSS 语法。Sass 能够帮助复杂的样式表更更有条理理， 并且易于在项目内部或跨项⽬目共享设计。**

+ 文件后缀为.scss或者.sass，一般使用.scss

+ 类似的css预处理理有less

#### 安装

+ vscode下载插件“ easy sass”
+ 在用户设置中加入一下代码："easysass.targetDir": "./css"

#### 基本语法

##### 变量与插值

+ **SCSS允许使用 “$” 声明变量**

~~~JavaScript
$blue : #1875e7;
div {
    color : $blue;
}
~~~

+ **如果变量需要镶嵌在字符串之中，就必须需要写在插值语句 “#{}” 之中**

~~~JavaScript
$side: left;
.rounded {
    border-#{$side}-radius: 5px;
}
~~~

##### **计算**

+ **SCSS允许在代码中使用算式**

~~~JavaScript
body {
    margin: (14px/2);
    top: 50px + 100px;
    right: $var * 10%;
}
~~~

##### 嵌套

+ **SCSS允许选择器器嵌套**

~~~JavaScript
div {
    h1 {
        color : red;
    }
}
// 属性也可以嵌套
p{
    border:{
        color:red;
    }
    //注意 : 属性嵌套后⾯面需要加上冒号。
}
// 在嵌套的代码块内，可以使⽤用 & 引⽤用⽗父元素
a{
    &:hover{
        color:#ffb3ff;
    }
}
~~~

##### **注释**

+ /* 多行注释 */ ，会保留到编译后的文件

+ // 单行注释 ，只保留在SASS源文件中，编译后被省略

+ 在/*后⾯面加一个感叹号，表示这是"重要注释"。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息

  `/*! */`

#### 代码的重用

##### 占位符%

~~~JavaScript
// SCSS允许通过 % 来声明⼀一个选择器器，但必须通过 @extend 指令调⽤用
%wh{
    width:100px;
    height:100px;
}
div{
    @extend wh;
}
~~~



##### 继承 @extend

~~~JavaScript
// SCSS允许⼀一个选择器器，继承另⼀一个选择器器
.class1 {
    border: 1px solid #ddd;
}
// class2要继承class1，就要使⽤用 @extend 命令
.class2 {
    @extend .class1;
}
~~~



##### 混合宏 @mixin

~~~JavaScript
// 使⽤用 @mixin 命令，定义⼀一个可以重⽤用的代码块。
@mixin left{
    float：left;
    margin-left:10px;
}
// 使⽤用 @include 命令，调⽤用这个混合宏。
div{
    @include left;
}
// @mixin的强⼤大之处，在于可以指定参数和默认值。
@mixin common($w,$h,$bg:pink) {
    width:$w;
    height:$h;
    background:$bg;
}
// 使⽤用 的时候，根据需要加⼊入参数：
div{
    @include common(100px,100px,red)
}
~~~



##### 插入文件

~~~JavaScript
// @import== 命令，⽤用来插⼊入外部⽂文件。
@import "reset.scss"
~~~

#### 高级用法

##### 循环语句

~~~javascript
// @for $var from through 含头含尾
@for $i from 1 through 10{
    .border-#{$i}{
    border:#{$i}px solid blue;
   }
}
// @for $var from to 含头不不含尾
    @for $i from 1 to 4 {
        .list li {
            &:nth-child(#{$i}) {
                        font-size: #{$i}0px;
                        }
    }
}
~~~



##### 自定义函数

~~~JavaScript
// @function ⽤用于声明函数 @return ⽤用于返回值
// 先声明后使⽤用
@function double($n) {
    @return $n * 2;
}

#sidebar {
	width: double(5px);
}
~~~

### 移动端布局

#### 流式布局(百分比布局)

**通过高度定死宽度百分比来适应不同的屏幕**

+ 左侧固定,右侧自适应

~~~css
* {
    box-sizing: border-box;
}


.box {
    width: 100%;
    height: 700px;
    position: relative;
}

.right {
    width: 100%;
    height: 100%;
    background: red;
    padding-left: 200px;
}


.left {
    width: 200px;
    height: 100%;
    background: green;
    position: absolute;
}
~~~

+ 右侧固定,左侧自适应

~~~css
* {
    box-sizing: border-box;
}


.box {
    width: 100%;
    height: 700px;
    position: relative;
}


.right {
    width: 200px;
    height: 100%;
    background: ref;
    position: absolute;
    right: 0;
    top: 0;
}


.left {
    width: 100%;
    height: 100%;
    padding-right: 200px;
    background: green;
}
~~~

#### 圣杯布局

+ 两侧固定,中间自适应

**缺点:对于大屏幕来说,用户体验并不是特别好,有些布局元素会显得很长**

**解决方案: rem布局**

~~~css
*{
    Box-sizing:border-box
}
Htm,body,.wrap{
    Width:100%
        Height:100%
}
.wrap{
    Position:relative;
}
.left{
    Width:200px;
    Height:100%;
    Background:pink;
    Position:aboute;
    Top:0;
    Left:0;
    z-index:1;
}
.center{
    Width:100%
        Height:100%;
    Background:red
        Position:aboute;
    Top:0;
    Left:0;
}
.right{
    Width:200px;
    Height:100%;
    Background:pink;
    Position:aboute;
    Top:0;
    Right:0;
    z-index:1;
}
~~~

#### 响应式布局

**媒体查询是实现响应式布局的关键技术**

##### 常见设备尺寸

~~~css
 /* 超小设备（⼿手机，小于768px） */
 @media screen and (min-width:480px){ ... }


 /* 小型设备（平板电脑，768px-992px） */
 @media screen and (min-width:768px) { ... }


 /* 中型设备（台式电脑，992px-1200px） */
 @media screen and (min-width:992px){ ... }

 /* 大型设备（大台式电脑，大于1200px） */
 @media screen and (min-width:1200px){ ... }
~~~

##### 最小宽度 min-width

~~~css
@media screen and (min-width:480px){ ... }
~~~

##### 最大宽度 max-width

~~~css
@media screen and (max-width:1200px){ ... }
~~~

##### 多个媒体特性的使用:并且

~~~css
@media screen and (min-width:480px) and (max-width:992px){ ... }
~~~

##### not关键词的使用：除了

~~~css
@media not screen and (min-width:1200px){ ... }
~~~

#####  only关键词的使用: 仅仅

​	**一般用来排除不支持媒体查询的浏览器**

~~~css
@media only screen and (min-width:480px){ ... }
~~~

### css3

#### 选择器

##### 属性选择器

+ **input[type = 'checkbox' ]**
+ 标签中**常见的属性**：href，style，src，title，name，id，class，type，target palaceholder disable checked selected value

##### 构造伪类选择器

+ 父级下的第一个元素
  + Parent >child:first-child
  + Ul>li:first.child{}
+ 父级下的最后一个子元素
  + parent > child:last-child
+ 父级下的任意位置
  + parent>child:nth-child(n)

##### 同类兄弟元素选择器

**某一个范围下的，同类的兄弟元素**

+ 第一个
  + parent.child:first-of-type
+ 最后一个
  + parent.chlid:last-of-type
+ 任意位置
  + parent child :nth-of-type(n)

~~~css
ul {
    width: 300px;
    background-color: skyblue;
}

ul li {
    border: 1px solid #000;
    height: 40px;
}

ul>li:first-child {
    background-color: green;
}

ul>li:last-child {
    background-color: green;
}

ul>li:nth-child(3) {
    background-color: green;
}

ul li:nth-of-type(4) {
    background-color: #ff000f;
}
~~~

##### 状态伪类选择器

+ 鼠标悬停:hover（只能控制子级）
+ 获取焦点：focus
+ 在元素之前：before

~~~css
ul::before {
    content: '';
    display: inlineblock;
    width: 10px;
    height: 10px;
    background: chocolate;
    border-radius: 50%;
}
~~~

+ 在元素之后：after

~~~css
 ul:after {
        content: '';
        color: royalblue;
        display: inlineblock;
        width: 10px;
        height: 10px;
        background: chartreuse;
        border-radius: 50%;
    
~~~

+ 当元素不可点击时：disabled

~~~html
<style>
    #btn:disabled {
        background-color: darkblue;
    }
</style>
<input type="button" name="" id="btn" value="按钮" disabled />
~~~

##### 交集选择器

~~~css
/* 交集选择器 */
ul li.blue::before {
    content: '';
    display: inline-block;
    background: skyblue;
    width: 10px;
    height: 10px;
    border-radius: 50%;
}
~~~

#### 样式属性

##### 怪异盒模型：IE盒模型

​	**与普通盒模型的区别：盒模型的占位是是 padding + margin + border +本身的宽度；**

​	**而iE盒模型的区别是在 它不会向外侧撑开而使向内部挤压，会压缩内容宽度（一般用于移动端）**

+ box-sizing : border-box(将盒子设置为怪异盒模型)
+ margin不会压缩width

##### 长度单位

+ px ：像素
+ %：以父级及为参考
+ Em ：是以父级的font-size为准
+ rem：是以根元素的HTML的font-size为准
+ vw/vh：将屏幕分为了100份 vw是宽 ， vh是高

##### 文字描边

**text-stroke（兼容）：线宽,颜色**

+ ie:-ms-
+ 火狐：-moz-
+ opera:-o-
+ 谷歌 -webkit-

**这些 私有前缀的作用是：让浏览器能够块的识别css3属性**

~~~html
<style>
	h1{   
        -webkit-text-stroke:3px red; 
    }
</style>
<h1>hollo world</h1> 
~~~

##### 文字阴影

**text-shadow：(水平位移，垂直位移，模糊值，颜色)**

~~~css
.msg{ 
    text-shadow: 0px 0px 1px #0077AA; 
}
~~~

##### 盒阴影

**box-shadow：（水平位移，垂直位移，模糊值，颜色）**

~~~css
.msg:hover{box-shadow: 0px 0px 1px #0077AA;  }
~~~

##### 透明

 **透明色**

~~~css
rgba（0,255,255，0.1）
~~~

**透明度：元素透明**

~~~css
opacity：0-1
如果opacity设置为0，元素不显示，但是占位
如果设置为display：none，页面不会加载元素，不占位
~~~

##### 圆角

~~~css
border-radius:(左上角，右上角，右下角，左下角);
border-top-left-radius：5px;
border-top-right-radius:5px;
border-bottom-left-radius:5px;
border-bottom-right-radius:5px;
最大不能超出50%，一旦超出50%按照50%计算
~~~

##### 渐变

~~~css
background-image:()
/*线性渐变*/
linear-gradient：（to right bottom，red，green，yellow）（默认从上到下） 
linear-gradient：（-90deg，green，yellow）（默认从上到下）
/*重复线性渐变*/
background-image:repeating-linear-gradient(red,yellow 10%, green 20%)
/*径向渐变*/
radial-gradient()从内向外渐变 
改变渐变形状：circle圆形 默认椭圆：ellipse 
background-image：rwadial-gradient(circle, yellow)

~~~

**背景图**

~~~css
background-size ：背景图尺寸
cover 拉伸图片，屏幕，铺满整个标签
contain 拉升  图片 直到碰到 父级边框，缺点  受到图片大小的尺寸的制约
clip：默认   padding-box 
			content-box
~~~

### 弹性布局

#### **flex布局**

Flex 是 Flexible Box的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性

任何一个容器可以指定为flex布局

~~~css
.box{
    display:flex
}
~~~

**设为 Flex布局以后，子元素的float、clear和vertical-align属性将失效。**

#### 基本概念

采用 Flex 布局的元素，称为Flex容器,它的所有子元素自动成为容器成员，称为 Flex 项目

#### 容器的属性

##### 父元素

**以下6个属性设置在父级容器上**

+ **flex-direction 属性决定主轴的方向（即项目的排列方向）**

~~~css
.box {
    flex-direction: row | row-reverse | column | column-reverse;
}
row（默认值）：从左到右
row-reverse：从右到左
column：从上到下
column-reverse：从下到上
~~~

+  **flex-wrap 放不下时是否换行**

~~~css
.box{
    flex-wrap: nowrap | wrap | wrap-reverse;
}
nowrap（默认）：不换行
wrap：换行，第一行在上方
wrap-reverse：换行，第一行在下方
~~~

+ **flex-flow 是flex-direction属性和flex-wrap属性的简写形式**

~~~css
.box {
    flex-flow: <flex-direction> || <flex-wrap>;
}
~~~

+ **justify-content 设置项目在主轴上的对齐方式( flex-direction 设置的方向就是主轴)**

~~~css
.box {
    justify-content: flex-start | flex-end | center | space-between | space-around;
}
flex-start（默认值）：左对齐
flex-end：右对齐
center： 居中
space-between：两端对齐，项目之间的间隔都相等
space-around：项目两侧的间隔相等,项目之间的间隔比项目与边框的间隔大一倍
~~~

+ **align-items 设置项目在交叉轴上的对齐方式( flex-direction 设置的对应方向就是交叉轴)**

~~~css
.box {
    align-items: flex-start | flex-end | center | baseline | stretch;
}
flex-start：交叉轴的起点对齐
flex-end：交叉轴的终点对齐
center：交叉轴的中点对齐
baseline: 项目的第一行文字的基线对齐
stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度
~~~

+  align-content 设置多根轴线的对⻬方式。如果项目只有一根轴线，该属性不起作用

~~~css
.box {
    align-content:flex-start | flex-end | center | space-between | space-around |stretch;
}
flex-start：与交叉轴的起点对齐。
flex-end：与交叉轴的终点对齐。
center：与交叉轴的中点对齐。
space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
stretch（默认值）：轴线占满整个交叉轴。
~~~

##### 子元素

以下6个属性设置在子元素项目上

+ **order 设置项目的排列顺序。数值越小，排列越靠前，默认为0**

~~~css
.item {
    order: 数字;
}
~~~

+ **flex-grow 设置项目的放大比例，默认为0，即如果存在剩余空间，也不放大**

~~~css
.item {
    flex-grow: 数字;
}
如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）
如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍
~~~

+ **flex-shrink 设置项目的缩小比例，默认为1，即如果空间不足，该项目将缩小**

~~~css
.item {
    flex-shrink: 数字;
}
为0的时候， 不收缩
为1的时候，会收缩
~~~

+ **flex-basis 设置了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小**

~~~javascript
.item {
    flex-basis: <length> | auto;
}
它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间
~~~

+  **flex 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto,后两个属性可选**

~~~CSS
.item {
    flex: none | auto;
}
该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)
~~~

+ **align-self 设置单个项目与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch**

~~~CSS
.item {
    align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
该属性可能取6个值，除了auto，其他都与align-items属性完全一致
~~~

#### 伪类选择器

##### 考虑其他同级元素的影响

~~~css
E:first-child　　第一个
E:last-child　　最后一个
E:only-child  只有一个节点的时候选中
E:nth-child(n)　正数第几个，从1开始，计算所有元素
E:nth-last-child(n) 倒数第几个
~~~

#####  不考虑其他同级元素的影响

~~~css
E:first-of-type　　第一个
E:last-of-type　　最后一个
E:only-of-type　　只有一个同类型的元素
E:nth-of-type(n)　　正数第几个，从1开始,只计算同类元素
E:nth-last-of-type(n) 倒数第几个，只计算同类元素
~~~

#### 字体图标

**自定义字体**

~~~css
@font-face {
    // 自定义字体的名字
    font-family: "iconfont";
    // 要使用的字体文件
    src: url('iconfont.eot?t=1479642403788'); /* IE9*/
    src: url('iconfont.eot?t=1479642403788#iefix') format('embedded-opentype'), /* IE6-IE8 */
        url('iconfont.woff?t=1479642403788') format('woff'), /* chrome, firefox */
        url('iconfont.ttf?t=1479642403788') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/
        url('iconfont.svg?t=1479642403788#iconfont') format('svg'); /* iOS 4.1- */
}

div {
    font-family: "iconfont";
}
~~~

 **使用iconfont（阿里巴巴矢量图标库）**

图标下载地址：https://www.iconfont.cn/

### rem

#### 前端尺寸单位

##### em

**em 是一个相对长度单位。其相对于当前对象内文本的字体尺寸，如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸**

+ em的值并不是固定的
+ em会继承父级元素的字体大小

##### rem

**rem全名rootem，简写rem，故其也是一个相对长度单位，但只相对于根元素，可以简单的通过更改根元素大小，从而调整所有字体大小。**

+ 只相对于根元素（html）
+ 通过修改根元素可成比例的调整页面字体大小
+ 其适配方案通过js脚本设置像素点来实现

##### vw、vh

**vw（Viewport Width）、vh(Viewport Height)是基于视图窗口的单位，是css3的一部分，基于视图窗口的单位。**

+ vw:1vw 等于视口宽度的1%
+ Vh:1vh 等于视口高度的1%

#### 动态计算rem

+ **js根据屏幕宽度和设计图动态设置html的font-size**

~~~javascript
function setRem() {
 var cwidth = document.documentElement.clientWidth;
 // 计算当前宽度和设计图的比例，
 var scale = cwidth / 375;
 // 设置页⾯面 1rem的大小
 document.documentElement.style.fontSize = 100 * scale + 'px';
 }
 setRem()
 // 每次窗口改变都重新设置一下rem
 window.onresize = setRem;
~~~

+ **scss中使用vw计算rem**

~~~css
// 设计图 750px下 100px === 1rem,⽐比例例为 100：1
// 1vw = 750 / 100 = 7.5px
// 100px = 100vw / (750 / 100) = 13.33333333vw
// html {
// font-size: 100vw / (750 / 100)
// }

// 标准设计图
$design_size: 375；
// html默认的font-size
$base_font: 75;
// 定义方法把设计图的px专成rem
@function rem($px) {
    @return $px / $base_font * 1rem;
}

html {
    // 设置页面1rem的值
    19 font-size: 100vw / ($design_size / $base_font);
}
// 设置320px以下都是用320px尺寸展示
@media screen and (max-width: 320px) {
    html {
        font-size: 64px;
    }
}
// 设置540px以上都是用540px的尺寸展示
@media screen and (min-width: 540px) {
    html {
        font-size: 108px;
    }
}
// 把页面所有的字体默认大小改成14px
body {
    font-size: 14px;
}
h2 {
    // 375尺⼨寸的⼿手机下为45px，其他设备下等⽐比例例缩放
    height: rem(45);
    background: red;
}
~~~

### 动画 

#### transform 转换属性

##### translate位移

~~~css
 transform : translate(50px,100px); //把元素水平移动 50 像素，垂直移动 100 像素


 transform : translateX(50px); //把元素水平移动 50 像素


 transform : translateY(100px); //把元素垂直移动 100 像素
~~~



##### scale缩放

~~~css
transform : scale(2); //把元素宽高同时放大两倍


transform : scale(2,4); //把元素宽度放大2倍，高度放大4倍


transform : scaleX(0.5); //把元素宽度缩小一半


transform : scaleY(1.2); //把元素高度放大1.2倍
~~~



##### rotate旋转

~~~css
transform : rotate(45deg); //把元素旋转45deg


transform : rotateX(45deg); //把元素沿X轴旋转45deg


transform : rotateY(45deg); //把元素沿X轴旋转45de
~~~



##### skew倾斜

~~~css
transform : skew(30deg,20deg); //把元素沿水平方向倾斜30deg,沿垂直方向倾斜20deg

transform : skewX(30deg); //把元素沿水平方向倾斜30deg

transform : skewY(20deg); //把元素沿垂直⽅向倾斜20deg
~~~

##### 简写

~~~css
//每个元素只能设置一个transform属性，可以同时设置多个值,如
transform: rotate(30deg) translate(50px) scale(2)
~~~

##### 旋转元素的基点位置

~~~css
transform-origin: x y z
~~~

#### transition 过渡属性

~~~css
transition-property : css的属性名称 或者all

transition-duration : 动画持续的时间

transition-timing-function : 动画的执行的曲线
ease:平滑运动
linear：线性运动
ease-in:逐渐加速 速度越来越快
ease-out:逐渐减速 速度越来越慢
ease-in-out:先加速再减速 速度先变快再变慢

transition-delay : 动画延迟时间

// 一般不不分开设置，直接写复合属性,
transition: all 2s linear 2s;
~~~

+ **css过渡效果结束后执行的js事件:transitionend**

~~~javascript
document.getElementById("myDIV").addEventListener("transitionend", function () {
    // ...todo
});
~~~

#### animation 关键帧动画

##### 定义动画

~~~css
@keyframes 动画名{
    0%{ ... }
       50%{ ... }
    100%{ ... }
        }
    //开始状态和结束状态时，可以用from 和 to代替
~~~

##### 调用动画

~~~css
animation-name: 动画名称

animation-duration: 动画持续的时间

animation-timing-function: 动画的执行的速度,与transition属性相同

animation-delay: 延迟时间

animation-iteration-count: 动画执行的次数,可以是数字或者infinite（无限循环）

animation-direction: 是否循环交替反向播放动画,
    normal( 正常播放 )
alternate(奇数次正向，偶数次反向)
alternate-reverse (奇数次反向，偶数次正向)
reverse( 反向播放 )

animation-fill-mode: 动画填充的模式,
    forwards(动画结束后停在最后的位置)
backwards(保留动画开始的初始状态)

animation-play-state: 动画是否暂停,
    running( 继续 )
paused( 暂停 )
~~~

#### 请求动画帧 requestAnimationFrame

+ **屏幕刷新频率**
  + 屏幕每秒出现图像的次数。普通笔记本为60Hz（赫兹）
+ **动画原理**
  + 计算机每16.7ms刷新一次，由于人眼的视觉停留，所以看起来是流畅的移动
+ **通过定时器达到的动画效果，容易卡顿抖动,原因是**
  + setTimeout异步加载，只有当主线程任务执行完后才会执行，因此实际执行时间总是⽐设定时间要晚
  + settimeout的固定时间隔不一定与屏幕刷新时间相同，会引起丢帧
  + **每次刷新的间隔中会执行一次requestAnimationFrame函数，不会引起丢帧，不会卡顿**

#### calc() 函数

​	**用于动态计算长度值**

+ 需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)
+ 任何长度值都可以使用calc()函数进行计算
+ **calc()函数⽀支持 "+", "-", "*", "/" 运算**
+ calc()函数使用标准的数学运算优先级规则

### touch事件

#### 定义

+ **PC端的鼠标事件无法满足移动设备触摸屏的特点**
+ **touch事件是移动端特有的**

#### 事件类型

+ **touchstart 开始触摸**
+ **touchmove 手指滑动**
+ **touchend 触摸结束**
+ **touchcancel 触摸意外中断（如：接电话）**

#### 基本用法

> **移动端不支持dom0级，只能通过dom2级绑定事件**

~~~javascript
// 开始触摸
box.addEventListener('touchstart',function(){
    console.log('我就摸一下');
});
// 手指滑动
box.addEventListener('touchmove',function(){
    console.log('轻轻的扒拉扒拉');
});
// 触摸结束
box.addEventListener('touchend',function(){
    console.log('下次再来');
});
~~~

> **touchEvent事件对象的额外三个属性**

~~~javascript
e.touches TouchList对象，正在触摸屏幕的所有手指的一个列表

e.targetTouches TouchList对象，正在触摸当前 DOM 元素上的手指的一个列表。

e.changedTouches TouchList对象,涉及当前事件的手指的一个列列表，存放的是发生变化的触点

// 开始触摸
box.addEventListener('touchstart', function(e) {
    console.log(e.touches); // length 1
    console.log(e.targetTouches); // length 1
    console.log(e.changedTouches); // length 1
});


// 触摸结束
box.addEventListener('touchend', function(e) {
    console.log(e.touches); // length 0
    console.log(e.targetTouches); // length 0
    console.log(e.changedTouches); //// length 1
});

// 在结束触摸事件 (touchend) 中,touches 和 targetTouches中的触点信息会被清空
// 一般使用 changedTouches获取触点信息
~~~

#### 封装touch

##### 封装点击事件

+ **为什么要封装点击事件？**

  + **click 事件有300ms的延迟**
  + touch 事件只要触摸屏幕就会触发，很多时候我们只是要滑动屏幕

+ **如何封装**

  + 通过touch事件模拟
  + 声明变量记录是否产生移动
  + 声明变量记录触摸开始和结束的时间差
  + 当未产生移动并且时间差在150ms内，认定为点击
  + 执行点击后的回调函数
  +  重置记录的值

  ~~~JavaScript
  var myTouch = {
      /**
       * el 绑定事件的元素
       * callback 回调函数
       */
      tap: function(el, callback) {
          //1.判断el的类型
          if (typeof el === 'object') {
              var isMove = false; //记录是否产生移动
              var startTime = 0; //记录开始时间
              //开始触摸
              el.addEventListener('touchstart', function() {
                  startTime = new Date() * 1;
              });
              //手指滑动
              el.addEventListener('touchmove', function() {
                  isMove = true;
              });
              //触摸结束
              el.addEventListener('touchend', function(e) {
                  //判断:1.是否产生移动  2. 时间差是否小于150ms
                  if (!isMove && new Date() * 1 - startTime < 150) {
                      callback && callback(e);
                  }
                  //重置记录的值
                  isMove = false;
                  startTime = 0;
              });
          }
      },
  ~~~

##### 封住滑动事件

+ 通过touch事件模拟
+  记录开始触点位置和最后移动触点位置
+  两个触点坐标的位移达到 30 ( 绝对值相减 )，认定为发生滑动
+  当水平位移的距离大于垂直位移的距离，则认定为水平滑动；反之则是垂直滑动。
+ 再根据两触点位移的正负差值,判断滑动方向

~~~JavaScript
/**
     * el 绑定事件的元素
     * dir 方向
     * callback 回调函数
     */
    swipe: function(el, dir, callback) {
        //1.判断el的类型
        if (typeof el === 'object') {
            var startPos = null; //开始触点位置
            var endPos = null; //结束触点位置
            //开始触摸
            el.addEventListener('touchstart', function(e) {
                startPos = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                }
            });
            //手指滑动
            el.addEventListener('touchmove', function(e) {
                endPos = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                }
            });
            //触摸结束
            el.addEventListener('touchend', function(e) {
                //判断滑动的方向和设置的方向是否一致
                if (startPos && endPos && dir === fn(startPos, endPos)) {
                    callback && callback(e);
					startPos = null;
					endPos = null;
                }
            });

            function fn(start, end) {
                //开始触点的位置 - 结束触点的位置
                var disx = start.x - end.x; //水平差值
                var disy = start.y - end.y; //垂直差值
                var absx = Math.abs(disx); //水平绝对值
                var absy = Math.abs(disy); //垂直绝对值
                //1.是否产生滑动
                if (absx > 30 || absy > 30) {
                    //2.滑动方向
                    if (absx > absy) { //水平
                        return disx > 0 ? 'left' : 'right';
                    } else { //垂直
                        return disy > 0 ? 'up' : 'down';
                    }
                }
            }
        }
    }
}
~~~



### h5新增

#### HTML5新特性

+ **绘画的 canvas 元素** 
+ **用于媒介回放的 video 和 audio 元素** 
+ **对本地离线存储的更好的支持** 
+ **新的特殊内容元素，比如 article、footer、header、nav、section** 
+ **新的表单控件，比如 calendar、date、time、email、url、search** 

#### 语义化标签

> **HTML5将一些结构类标签，细分出语义化结构标签**

~~~html
<header>网页的头部</header>

<footer>网页的底部</footer>

注意：一个文档，只能出现一个main标签，不能被嵌套在需要重复出现的标签中
<main>用来表示文档的主体部分</main>

HTML5将一些结构类标签，细分出语义化结构标签
<nav>表示导航</nav>

<aside>侧边栏</aside>

<article>表示文章</article>

<hgroup>标题管理</hgroup>

<section>章节</section>

<address>联系信息</address>
~~~

#### 新增的控件

~~~html
可输入的下拉框
<input type="text" list="box" />
<datalist id="box"> <!--选项-->
    <option value ="1234567"></option>
    <option value ="12345678"></option>
    <option value ="1234567890"></option>
    <option value =""></option>
</datalist>

list属性指向datalist的id
~~~

#### input新增类型

~~~html
搜索框
	<input type="search" name="" id="" value="" /> 
url地址栏
	<input type="url" name="" id="" value="" /> 
电话
	<input type="tel" name="" id="" value="" /> 
email
	<input type="email" name="" id="" value="" /> 
color
	<input type="color" name="" id="color" /> 
number
	<input type="number" name="" id="" value="" /> 
数字拉动条
	<input type="range" name="" id="range" value="" max="50" min="10" /> 
max：最大值 min：最小值
时间选择
	<input type="time" name="" id="time" value="" /> 
日期和时间
	<input type="datetime-local" name="" id="" value="" /> 
周和年
	<input type="week" name="" id="" value="" /> 
年月
	<input type="month" name="" id="" value="" /> 
日期
	<input type="date" name="" id="" value="" /> 
~~~



### web存储

+ **本地存储**
  + **临时存储：sessionStorage**
  + **永久存储：localStorage**

+ **cookie**

#### localStorage:永久存储

**作用**

+ 在HTML5中，新加入了了⼀个localStorage特性，这个特性**主要是用来作为本地存储来使用**的，**解决了cookie存储空间不足的问题 (cookie中每条cookie的存储空间为4k)**

+ localStorage中⼀般**浏览器支持的是5M大小**，这个在不同的浏览器中localStorage会有所不同。

**(注意 localStorage 只⽀支持 string 类型的数据存储)**

~~~JavaScript
// 存数据
localStorage.setItem('key', 'value')

// 读取数据
localStorage.getItem('key')

// 删除⼀一条数据
localStorage.removeItem('key')

// 清除所有数据
localStorage.clear()
~~~

#### sessionStorage:临时存储

**作用**

+ sessionStorage ⽤用于**临时保存同⼀窗⼝(或标签页)的数据**，在**关闭窗口或标签页之后将会删除这些数据**。
+ **语法：和localStorage一样**

#### cookie

**作用**

+ 浏览器存储数据的方式，浏览器发起请求的时候，会自动把cookie中存储的内容，携带并发送到服务器，

  **容量: 4k**

**获取**

+ **document.cookie**

##### 添加cookie

+ **document.cookie = "key=value"**

##### cookie长期保存

**在实际开发中，cookie常常需要长期保存**

~~~javascript
//保存⽤用户登录的状态
//GMT_String是以GMT格式表示的时间字符串
document.cookie="userId=828;expires=GMT_String"


//将userId这个cookie设置为GMT_String表示的过期时间，超过这个时间，cookie将消失，不可访问

// GMT_String: new Date().toGMTString();
var date=new Date();

var expiresDays=10; //将date设置为10天以后的时间

//将userId和userName两个cookie设置为10天后过期

date.setTime(date.getTime()+expiresDays*24*3600*1000); 

document.cookie="userId=828; userName=hulk;expires="+date.toGMTString()


~~~

##### cookie实例

~~~JavaScript
//设置
document.cookie = "userId=4009512"
document.cookie = "pass=1234567"
//cookie 过期时间
//GMT_String 时间格式
var data = new Date（'2020-1-12'）.toGMTString();
document.cookie = "user=4009512;exprires="+date；
//如果要删除这一条cookie
//把这条cookie的过期时间写到当前时间就可以删除
var data = new Date（'1999-10-12'）.toGMTString();
document.cookie = "user=4009512;exprires="+date；
~~~



### 拖放

#### 拖放事件

##### 三个对象

+ **源对象  **
  + **被拖放的元素**
+ **过程对象 **
  + **经过的元素**
+ **目标对象 **
  + **到达的元素**

##### 源对象中的事件

> **要想让某个元素可以拖拽需要设置 draggable="true" 大多数的标签该属性默认值是false，但是img标签和a标签的draggable属性默认是true**

+ **dragstart 源对象开始拖放**
+ **drag 源对象拖放过程中**
+ **dragend 源对象拖放结束**

##### 过程对象中的事件

+ **dragenter 源对象开始进入过程对象范围( 鼠标进入 )**
+ **dragover 源对象在过程对象范围内移动**
+ **dragleave 源对象离开过程对象范围**

##### 目标对象

+ **drop 源对象被拖放到目标对象内**

+ **注意**

~~~md
1. 页面中的元素默认都是过程对象

2. 过程对象的dragover事件有一个默认行为！！！

3. 那就是当dragover触发时，drop会失效！！！！

4. 所以需要阻止dragover的默认行为才能触发drop
~~~



##### 简单拖放步骤

~~~txt
1. 将源对象draggable属性值置为true,允许元素可拖放

2. 给源对象绑定开始拖放事件,规定当元素被拖动时会发生什么

3. 给过程对象绑定拖动经过事件,规定经过过程对象时会发生什么

4. 阻止目标对象的dragover事件的默认行为

5. 给目标对象绑定(drop)事件 ,规定放开后会发生什么
~~~

**实例**

~~~html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>拖放</title>
        <style>
            .droptarget {
                float: left;
                width: 100px;
                height: 35px;
                margin: 15px;
                padding: 10px;
                border: 1px solid #aaaaaa;
            }
        </style>
    </head>

    <body>
        <div class="droptarget" ondragover="dragOver(event)" ondrop="Drop(event)">
            <p draggable="true" id="dragtarget" ondragstart="dragStart(event)" ondragend="dragEnd(event)">拖动我!</p>
        </div>
        <div class="droptarget" ondragover="dragOver(event)" ondrop="Drop(event)"></div>
        <p id="demo">拖动 p 元素</p>
        <script>
            var dragtarget = document.querySelector('#dragtarget')

            function dragStart(ev) {
                ev.dataTransfer.setData('text', ev.target.id)
                document.querySelector('#demo').innerHTML = '开始拖动'
            }

            function dragEnd(ev) {
                document.querySelector('#demo').innerHTML = '拖动结束'
            }

            function dragOver(ev) {
                ev.preventDefault()
            }

            function Drop(ev) {
                var con = ev.dataTransfer.getData('text')
                ev.target.appendChild(document.getElementById(con))
            }
        </script>
    </body>
</html>
~~~



#### dataTransfer

> ==dataTransfer== 是**拖放事件对象中的属性**,该属性用于**源对象和目标对象之间的数据传输**。==数据类型不区分大小写==

~~~
1. 在源对象里面存储数据 e.dataTransfer.setData("数据名字","值")

2. 在目标对象里面获取数据 e.dataTransfer.getData("数据类型")

3. 在源对象里面清除数据 e.dataTransfer.clearData("数据类型(可省,省则清除所有)")

4. effectAllowed 和 dropEffect 这两个属性结合起来设置拖放的视觉效果 copy、link、move

5. e.dataTransfer.setDragImage(img,100,100); 
  第一个参数：img对象
  第二个参数：鼠标相对于图片的x方向偏移量
  第三个参数：鼠标相对于图片的y方向偏移量
~~~

**实例**

~~~html
<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <style>
            .box {
                width: 100px;
                height: 100px;
                background-color: red;
            }

            .box2 {
                width: 100px;
                height: 100px;
                background-color: green;
            }
        </style>
    </head>

    <body>
        <div class="box" draggable="true">元对象</div>
        <div class="box2">目标对象</div>
        <script>
            var box = document.querySelector('.box')
            var box2 = document.querySelector('.box2')
            box.addEventListener('dragstart', function (event) {
                event.dataTransfer.setData('name', '源对象')
                // var img = document.createElement('img')
                event.effectAllowed = 'move'
                var img = new Image()
                img.src = './img/1.png'
                event.dataTransfer.setDragImage(img, 200, 200)
                console.log(event)
            })

            box2.addEventListener('dragover', function (event) {
                event.preventDefault()
            })
            box2.addEventListener('drop', function (event) {
                event.dropEffect = 'move'
                var con = event.dataTransfer.getData('name')
                event.innerHTML = con
            })
        </script>
    </body>

</html>
~~~



### 文件上传

#### file上传文件

~~~html
<input type="file" multiple>
~~~

~~~
multiple 设置多选

通过change事件监听是否上传文件

files 属性获取上传的文件集合
~~~

#### FileReader接口

~~~
1. 创建读取文件对象 var f = new FileReader();

2. 读取文件 f.readAsDataURL(file) 或 f.readAsText(file);

3. 获取读取到的结果 f.result
~~~

#### FileReader方法

| FileReader方法     | 描述                   |
| :----------------- | ---------------------- |
| readAsBlnaryString | 读取为二进制编码       |
| ==readAsText==     | 读取文本文件的文本内容 |
| ==readAsDataURL==  | 读取文件的路径         |

#### FileReader事件

| FileReader事件 | 描述                   |
| -------------- | ---------------------- |
| abort          | 读取中断               |
| error          | 读取出错               |
| loadstart      | 读取开始               |
| progress       | 正在读取               |
| ==load==       | 读取成功               |
| loadend        | 读取完成，无论成功失败 |

#### 方法

~~~
1. <input type='file' multiple></input>  multiple 设置可以多选多个文件
2. 获取input   使用 change 事件去监听  上传过程
3. 在change 事件中处理 上传的文件
判断 上传的 类型  （图片/文件）
a. 获取到上传的文件 （this.files 对象）
b. 创建读取文件对象 var f = new fileReader()
c. 读取对象  (读取图片地址  f.readAsDataURL()   读取文件对象  f.readAsText())
d. 获取读取到的内容  （ f.load 读取成功）
f. 把读取的内容添加到节点
~~~

**实例**

~~~html
<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
    </head>

    <body>
        <div class="box"></div>
        <input id='inp' type="file" multiple></input>
    <script>
        var inp = document.querySelector('#inp')
        inp.onchange = function () {
            var reg = /^image\//
            var oreg = /^text\//
            // 多张图片展示
            var cur = this.files // 对象
            Array.from(cur).forEach((item, index) => {
                if (reg.test(item.type)) {
                    // 创建读取对象
                    var f = new FileReader()
                    // 读取文件
                    f.readAsDataURL(item) // 读取图片
                    // f.readAsText(item) // 读取文本
                    // 读取完成
                    f.onload = function () {
                        var img = new Image()
                        img.src = f.result
                        document.querySelector('.box').appendChild(img)
                    }
                } else {
                    // 创建读取对象
                    var f = new FileReader()
                    // 读取文件
                    f.readAsText(item) // 读取文本
                    // 读取完成
                    f.onload = function () {
                        console.log(f.result)
                    }
                }

            })
            // var img = this.files[0]
            // // 创建读取对象
            // var f = new FileReader()
            // console.log(f)
            // // 读取文件
            // f.readAsDataURL(img)
            // // 读取完成
            // f.onload = function () {
            //     var img = new Image()
            //     img.src = f.result
            //     document.querySelector('.box').appendChild(img)
            // }

        }
    </script>
    </body>

</html>
~~~



### 多媒体

#### 音频audio、视频video

~~~html
<audio src="horse.mp3" controls loop="loop" autoplay="autoplay">
    <source src="horse.ogg" type="audio/ogg">
    <source src="horse.wav" type="audio/mpeg">
    <source src="horse.acc" type="audio/mpeg">
    您的浏览器版本太low不支持 audio 元素,请更新。
</audio>


1. audio 标签用于存放一个音频文件
2. source 标签用于指定文件的路径和文件的类型
3. 加载多个类型的音频文件是为了兼容不同的浏览器
4. 当浏览器不支持播放音频是可用一段文字提示
~~~

#### 常用属性

| 常用属性    | 功能                             |
| ----------- | -------------------------------- |
| controls    | 设置或返回是否显示播放控件       |
| autoplay    | 设置或返回是否加载完毕后自动播放 |
| loop        | 设置或返回是否循环播放           |
| muted       | 设置或返回是否静音               |
| volume      | 设置或返回音量                   |
| paused      | 设置或返回是否暂停               |
| currentTime | 设置或返回当前播放时间           |
| duration    | 设置或返回总时长（秒）           |

#### 常用API

| 常用API | 功能     |
| ------- | -------- |
| play()  | 播放     |
| pause() | 暂停     |
| load()  | 重新加载 |

#### 事件

| 事件           | 功能                      |
| -------------- | ------------------------- |
| canplaythrough | 当文件缓冲/加载完成后触发 |
| timeupdate     | 当前播放位置更改时触发    |
| ended          | 当播放结束时触发          |

### canvas

**Canvas是HTML5中新出的一个元素，开发者可以通过JS脚本动态绘制图像**。

#### 创建canvas画布

```
在页面中创建canvas标签,并设置其id和宽高 (不要通过css设置,会有bug)

<canvas id="myCanvas" width="500" height="500">
```

#### 设置画布

```
// 1. 通过js设置画布宽高
var canvas = document.getElementById('myCanvas');
canvas.width = 800;
canvas.height = 600;

// 2. 获取上下文对象 （可以理解为获取画笔）
var cxt = canvas.getContext('2d');
```

#### 绘制 - 线条

| 方法        | 描述     |
| ----------- | -------- |
| beginPath() | 开启路径 |
| moveTo(x,y) | 起始点   |
| lineTo(x,y) | 下一个点 |
| closePath() | 闭合路径 |
| stroke()    | 描边绘制 |
| fill()      | 填充绘制 |

// 画封闭图填充颜色
由线条组成的封闭图 不是完整的封闭图 填充不上颜色
由点连接形成的封闭图，可以填充颜色


| 属性        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| strokeStyle | 描边颜色                                                     |
| fillStyle   | 填充颜色                                                     |
| lineWidth   | 粗细                                                         |
| lineCap     | 设置或返回线条端点样式 <br> butt 默认,平直边缘<br> round 圆形线帽 <br> square 正方形线帽 |
| lineJoin    | 设置或返回两条相交线的拐角<br> miter  默认,尖角<br> round 圆角 <br> bevel 斜角 |

#### 绘制 - 矩形

| 方法                         | 描述                               |
| ---------------------------- | ---------------------------------- |
| rect(x,y,width,height)       | 需配合stroke()或fill()方法绘制矩形 |
| fillRect(x,y,width,height)   | 绘制填充矩形                       |
| strokeRect(x,y,width,height) | 绘制矩形边框                       |
| clearRect(x,y,width,height)  | 清除指定矩形区域                   |

#### 绘制 - 圆弧

==弧线==`arc(x,y,r,sAngle,eAngle,counterclockwise)`

| 参数             | 描述                                |
| ---------------- | ----------------------------------- |
| x,y              | 圆心的坐标                          |
| r                | 圆的半径                            |
| sAngle           | 起始弧度                            |
| eAngle           | 结束弧度<br>弧度 = Math.PI/180*角度 |
| counterclockwise | 可选。true逆时针,false顺时针        |

Math.PI = 数学 ∏
==两切线之间的弧线== `arcTo(x1,y1,x2,y2,r)`

| 参数  | 描述         |
| ----- | ------------ |
| x1,y1 | 弧的起点坐标 |
| x2,y2 | 弧的终点坐标 |
| r     | 半径         |

==绘制扇形==

```
cxt.moveTo(x,y);
cxt.arc(x,y...);
cxt.closePath();
```

#### 绘制 - 文本

| 属性         | 描述                         |
| ------------ | ---------------------------- |
| font         | 设置或返回文本的当前字体属性 |
| textAlign    | 设置或返回文本的对齐方式     |
| textBaseline | 设置或返回文本的基线         |

| 方法                 | 描述         |
| -------------------- | ------------ |
| fillText(text,x,y)   | 绘制填充文本 |
| strokeText(text,x,y) | 绘制描边文本 |

#### 绘制 - 图像

```
drawImage(img,x,y,width,height)
```

| 参数   | 描述                |
| ------ | ------------------- |
| img    | 要使用的图像        |
| x      | 绘制的起始位置x坐标 |
| y      | 绘制的起始位置y坐标 |
| width  | 可选。宽度          |
| height | 可选。高度          |

#### 绘制 - 转换

| 方法                              | 描述                                                   |
| --------------------------------- | ------------------------------------------------------ |
| **scale(scalewidth,scaleheight)** | 缩放当前绘图至更大或更小                               |
| scalewidth                        | 缩放当前绘图的宽度 (1=100%, 0.5=50%, 2=200%, 依次类推) |
| scaleheight                       | 缩放当前绘图的高度 (1=100%, 0.5=50%, 2=200%, 依次类推) |
| **rotate(Math.PI/180*角度)**      | 旋转当前绘图                                           |
| **translate(x,y)**                | 重新设置画布原点                                       |
| x                                 | 添加到水平坐标（x）上的值                              |
| y                                 | 添加到垂直坐标（y）上的值                              |
| **transform()**                   | 替换绘图的当前转换矩阵                                 |
| **setTransform()**                | 将当前转换重置为单位矩阵。然后运行 transform()         |



#### 绘制 - 渐变色

**线性渐变**

```css
var lg = ctx.createLinearGradient(x, y, x1, y1);
lg.addColorStop(渐变位置,颜色);
ctx.strokeStyle = lg;
```

**径向渐变**

```css
var rg = cxt.createRadialGradient(起始圆x, 起始圆y, 半径, 结束圆x, 结束圆y, 半径);
rg.addColorStop(渐变位置,颜色);
ctx.strokeStyle = rg;
```

#### 多图形组合方式

```css
ctx.globalCompositeOperation = 
'source-over' //后画覆盖先画
'destination-over' //后画清空先画
```

#### 保存画布

~~~css
cvs.toDataURL(); 
~~~

#### 绘制数据图表

##### 折线图

获取canvas对象

`var ctx = document.getElementById('canvas').getContext('2d');`

**重置原点**

`ctx.translate(100, 510)`

**封装划线方法**

~~~ js
 //封装划线方法
    function drawLine(x, y, x1, y1, color) {
        //x,y  开始点坐标  x1,y1结束点坐标   color：线条颜色
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.moveTo(x, y);
        ctx.lineTo(x1, y1);
        ctx.stroke();
    }
~~~

 **画坐标轴线**

~~~ js
// x:
drawLine(0, 0, 800, 0, '#000')
// y：
drawLine(0, 0, 0, -500, '#000')
~~~

**横轴**

> 遍历数据

1. 刻度

   ~~~ js
   drawLine(i*50,0,i*50,-10,"#000")//刻度
   ~~~

   

2. 坐标轴标注

   ~~~ js
   //坐标轴标注
   ctx.beginPath();
   ctx.font="16px normal bold"
   ctx.textAlign='center';
   ctx.fillText(data[i-1].month,i*50,20);
   ~~~

   

3. 绘制顶点

   ~~~ js
   //顶点
   ctx.beginPath()
   ctx.fillStyle="green"
   ctx.arc(i*50,-data[i-1].money/10,5,0,Math.PI*2,false)
   ctx.fill()
   ~~~

   

4. 链接相邻两个点

   ~~~ js
   // 划线
   //如果下标i超出数据范围是拿不到的
   if(i<data.length){
       drawLine(i*50,-data[i-1].money/10,(i+1)*50,-data[i].money/10,"red")
   }
   ~~~

5. 写标注

   > 标注的坐标点：
   >
   > ​	x:横轴刻度的横坐标
   >
   > ​	y:数据中的money/10

   ~~~js
   //标注
   ctx.beginPath();
   ctx.font="16px normal bold"
   ctx.textAlign='center';
   ctx.fillText(data[i-1].money,i*50,(-data[i-1].money/10)-20);
   ~~~

   

 **纵轴**

> 从数据上看，我们可以看到最大的值是4000，我们人为的把图形范围设置为5000
>
> 图形中y轴长500px，1px===10money
>
> 我们要给y轴画10个刻度，每个刻度是50px 
>
> 每个刻度的标注就是 50px*10money=500

~~~ js
//y轴刻度
for(var i=1;i<=10;i++){
    drawLine(0,-i*50,10,-i*50,'#000');
    //写刻度
    ctx.beginPath();
    ctx.font="16px normal bold"
    // ctx.textAlign='center';
    ctx.textBaseline="middle";
    ctx.fillText(i*500,-30,-i*50);
}
~~~

##### 条形图

**封装画矩形的方法**

~~~ js
//封装一个矩形方法
function drawRect(x,y,width,height,color){
    ctx.beginPath();
    ctx.fillStyle=color;
    ctx.fillRect(x,y,width,height)
}
~~~



**绘制矩形**

> 开始点：从横轴上开始
>
> ​	x：横轴刻度左边
>
> ​	y:0
>
> 宽度：自定义（注意：不能大于两个刻度之间的间隔）
>
> 高度：-数据中的money/10（因为我们要反方向绘制，所以高度是负值）
>
> 开始点横坐标偏移量：
>
> ​	原因：我们想让条形图在刻度中间
>
> ​	把开始点的横坐标减去条形图宽度的一半（向左偏移宽度的一半）

~~~ js
    drawRect(i*50-15,0,30,-data[i-1].money/10,"blue")
~~~



### Swiper

#### 定义

+ 开源、免费、强大的触摸滑动
+ Swiper常用于移动端网站的内容触摸滑动
+ Swiper能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果

#### 使用

+ **首先加载插件，需要用到的文件有swiper.min.js和swiper.min.css文件**

~~~html
<link rel="stylesheet" href="dist/css/swiper.min.css">

<script src="dist/js/swiper.min.js"></script>
~~~

+ **HTML内容**

~~~html
<div class="swiper-container">
    <div class="swiper-wrapper">
        <div class="swiper-slide">Slide 1</div>
        <div class="swiper-slide">Slide 2</div>
        <div class="swiper-slide">Slide 3</div>
    </div>
    <!-- 如果需要分页器 -->
    <div class="swiper-pagination"></div>

    <!-- 如果需要导航按钮 -->
    <div class="swiper-button-prev"></div>
    <div class="swiper-button-next"></div>

    <!-- 如果需要滚动条 -->
    <div class="swiper-scrollbar"></div>
</div>
~~~

+ **初始化调用Swiper**

~~~JavaScript
var mySwiper = new Swiper ('.swiper-container', {
    // 如果需要分页器
    pagination: {
        el: '.swiper-pagination',
    },

    // 如果需要前进后退按钮
    navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
    },

    // 如果需要滚动条
    scrollbar: {
        el: '.swiper-scrollbar',
    },
})
~~~

#### 常用属性

### better-scroll 

#### 简介

BetterScroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。

#### 原理

1. 与浏览器滚动原理一致，父容器高度固定，子元素内容撑开，必须产生滚动条，才能滚动。

2. better-scroll只处理容器（wrapper）的第一个子元素（content）的滚动

   > 当 版本 >= 2.0.4 的时候，可以通过 `specifiedIndexAsContent` 配置项来指定 content

#### 引用

> BetterScroll 2.X 里面，我们将 1.X 耦合的 feature 拆分至插件，以达到按需加载、减少包体积的目的。因此，`@better-scroll/core` 只提供了最核心的滚动能力。

**核心模块**

~~~ js
<script src="https://unpkg.com/@better-scroll/core@latest/dist/core.js"></script>

<!-- minify -->
<script src="https://unpkg.com/@better-scroll/core@latest/dist/core.min.js"></script>


//实例
let wrapper = document.getElementById("wrapper")
let bs = new BScroll(wrapper, {})

~~~



**具备所有插件能力的 BetterScroll**

~~~ js
<script src="https://unpkg.com/better-scroll@latest/dist/better-scroll.js"></script>

<!-- minify -->
<script src="https://unpkg.com/better-scroll@latest/dist/better-scroll.min.js"></script>

//实例
let bs = BetterScroll.createBScroll('.wrapper', {
    
})
~~~



#### HTML结构

~~~ html
<div class="wrapper">
  <ul class="content">
    <li>...</li>
    <li>...</li>
    ...
  </ul>
  <!-- 这里可以放一些其它的 DOM，但不会影响滚动 -->
</div>
~~~

#### 配置

#####  scrollX

类型：`Boolean`

默认值: `false`

作用：当设置为 true 的时候，可以开启横向滚动。

##### scrollY

类型：`Boolean`

默认值：`true`

作用：当设置为 true 的时候，可以开启纵向滚动看

#####  probeType

类型: `Number`

默认值:`0`

作用:

1. 滚动一段时间后在去派发scroll事件
2. 只要滚动会实时的派发scroll事件
3. 不仅在滚动实时的派发scroll事件，并且在滚动动画的时候也会派发scroll事件

##### specifiedIndexAsContent

- **类型**：`number`
- **默认值**：`0`
- **作用**：指定 `wrapper` 对应索引的子元素作为 `content`，默认情况下 BetterScroll 采用的是 `wrapper` 的第一个子元素作为 content。

##### click

- **类型**：`boolean`
- **默认值**：`false`
- **作用**：BetterScroll 默认会阻止浏览器的原生 click 事件。当设置为 true，BetterScroll 会派发一个 click 事件，我们会给派发的 event 参数加一个私有属性 `_constructed`，值为 true。

#### 常用方法

##### bs.refresh()

> 重新计算 better-scroll，当 DOM 结构发生变化的时候务必要调用确保滚动的效果正常

#####  bs.scrollToElement(el, time, offsetX, offsetY, easing)

参数：

{DOM | String} el 滚动到的目标元素, 如果是字符串，则内部会尝试调用 querySelector 转换成 DOM 对象。

{Number} time 滚动动画执行的时长（单位 ms）

{Number | Boolean} offsetX 相对于目标元素的横轴偏移量，如果设置为 true，则滚到目标元素的中心位置

{Number | Boolean} offsetY 相对于目标元素的纵轴偏移量，如果设置为 true，则滚到目标元素的中心位置

返回值：无

作用：滚动到指定的目标元素。

##### bs.on()

~~~ js
 bs.on("scroll",function(){
    console.log(this.y);//滚动的距离  下拉是正值(拉的距离越大值越大)  上拉是负值
    this.maxScrollY//最大的滚动距离
})
~~~

#### 事件

**scroll**

- **触发时机**：正在滚动

```js
  bs.on('scroll', function(){
      console.log(this.x,this.y)
  })
```

**touchEnd**

- **触发时机**：用户手指离开滚动区域

```js
  bs.on('touchEnd',function(){
      
  })
```

#### 案例

##### 侧导航

> **注意：**
>
> ​	dom节点发生变化之后，一定要调用`bs.refresh()`方法

1. 渲染html

2. 实例化bs

3. 绑定点击事件，调用scrollToElement

   ~~~ js
    var bs = BetterScroll.createBScroll('.box', {
           specifiedIndexAsContent: 1,//设置content  索引
           probeType: 2,
           click:true,
       })
       // bs.on('scroll', function () {
       // })
       renderCont() //创建内容
       renderNav() //创建导航
       bs.refresh()
       $('.nav').onclick = function (e) {
           if (e.target.nodeName === "LI") {
               var index = e.target.getAttribute('data-index')
               var el=gets('.content li')[index]
               bs.scrollToElement(el, 200,)
               
           }
    }
   ~~~

   

##### 下拉刷新

> **原理**
>
> ​	获取当前滚动距离，向下拉为正值
>
> ​	判断是否达到刷新临界值
>
> ​	如果达到：显示对应内容
>
> ​	在`thouchEnd`事件中，判断手指离开屏幕的时候，滑动距离是否在临界值范围

~~~ js
 var bs = BetterScroll.createBScroll('.box', {
        specifiedIndexAsContent: 1,//设置content  索引
        probeType: 2,
    })
    renderCont() //创建内容
    bs.refresh()
    bs.on('scroll', function () {
        //判断：如果滑动的距离大于60 刷新
        $('.msg').style.top=0;
        if (this.y > 60) {
            $('.msg').innerHTML="松开刷新"
        } else {
            //如果小于60
            $('.msg').innerHTML="下拉刷新"
        }

    })
    bs.on('touchEnd', function () {//手指离开
        // console.log('滑动了' + this.y)
        $('.msg').style.top=-30+'px';
        if (this.y > 60) {
            setTimeout(function () {
                renderCont()
                alert('已刷新')
                bs.refresh()
            }, 1000)
        } 
    })
~~~



##### 上拉加载

> **原理**
>
> ​	上拉时，`this.y`是负值
>
> ​	bs纵向滚动的区间是：`【minScrollY, maxScrollY】`，并且 `maxScrollY `是负值
>
> ​	我们要获取元素拉到底之后，又向上拉动的距离`this.y - this.maxScrollY`
>
> ​	通过判断这个值可以知道拉动距离是否达到加载临界值

~~~ js
 var bs = BetterScroll.createBScroll('.box', {
        specifiedIndexAsContent: 1,//设置content  索引
        probeType: 2,
    })
    renderCont() //创建内容
    bs.refresh()
    bs.on('scroll', function () {
        // console.log(this.y)//如果是向上滑动 是负值
        // console.log(this.maxScrollY) //bs 纵向滚动的位置区间是 [minScrollY, maxScrollY]，并且 maxScrollY 是负值，maxScrollY 是正值。
        var dist = this.y - this.maxScrollY //拉到底之后，又向上拉动的距离  
        if (dist < -120) {//达到刷新的高度
            $('.msg').innerHTML = "加载更多..."
            $('.msg').style.bottom = 0;
        }
    })
    bs.on('touchEnd', function () {//手指离开
        var dist = this.y - this.maxScrollY//拉到底之后，又向上拉动的距离  、
        // console.log(dist)
        if (dist < -120) {//达到刷新的高度
            $('.msg').innerHTML = "玩命加载中..."
            setTimeout(function () {
                renderCont();
                bs.refresh()
                // alert('加载完毕')
                $('.msg').innerHTML = "加载完毕"
                $('.msg').style.bottom = -30 + 'px';
            }, 2000)

        } else {//没达到

        }
    })
~~~






# 高级

## 初级node

###  ES6语法       

#### let和const

##### 不存在变量提升

```javascript
console.log(n) //报错
let n = 10;
console.log(n)// 10
```



##### 暂时性死区

如果在某个作用域里面，使用let创建l的变量，那么这个变量名就把这个区域锁死了，也就是说这个作用域里面，只能使用let声明            

```javascript
let n = 10;
if(n>0){
    console.log(n)
    let n = 25
    var n =15 //已经声明了标识符'n'
    console.log(n)//在初始化之前无法访问“n”
},
```

​                                

##### 块级作用域

全局：不在函数内声明

局部：只有在函数内部声明的变量，叫做局部变量

let 和 const 不管是循环 判断 还是函数 只要在{}声明的变量就是局部变量 

```javascript
if(true){
        let num = 100;
    }
console.log(num);// num is not defined
```



```javascript
 var list = document.querySelectorAll('li')
    for (var j = 0; j < list.length; j++) {
        list[j].onclick = function () {
            console.log(j);
        }
    }
  //5
let list = document.querySelectorAll('li')
    for (let i = 0; i < list.length; i++) {
        list[i].onclick = function () {
            console.log(i);
        }
    }
 //0,1,2,3,4
```



##### 不可复制声明

```javascript
let n = 10;
if(n>0){
    let n = 25
    var n =15 //已经声明了标识符'n'
    console.log(n)
}
```



##### const常量

常量的值不可修改

```javascript
const age = 20
age += 10
console.log(age);//报错：Assignment to constant variable（赋值给常变量）
```

如果常量是引用数据类型，修改值得内容不报错

```javascript
const obj = {a:1}
 console.log(obj);
//  obj = [1,2]
//  console.log(obj); 报错
obj.a = 100;
console.log(obj)//不报错
```

#### 数组的解构赋值

##### 基本用法

```javascript
let arr = [1,2,3,4,5]
let [a,b,c,d,e] = arr;
console.log(a,b,c,d,e);
//1 2 3 4 5
```

##### 默认赋值

```javascript
let arr = [1,2,3,4]
let [a,b,c,d,e=100] = arr;
console.log(a,b,c,d,e);
//1 2 3 4 100
```

> 如果数组中的[4]没有值，此时e的值应该是undefined，假设不确定数组的[4]没有值，我们可以在结构的时候给一个默认值，如果没有，e===默认值，如果有e===arr[4]

#### 字符串的解构赋值

```javascript
 //字符串的解构和赋值
let str = 'sfdsfsfsafafds'
//以数组的形式结构
 let [sfd,sfs,fsa] = str
 console.log(sfd,sfs,fsa);
 // s f d
//以对象的形式结构
 let {slice:slice,split,indexOf,length} =str
 console.log(length);
 //14
let a = 1;
let b = 2;
let c = 3;
let add = function () {

}
let obj = {
    a: a,
    b: b,
    c: c
} 
//如果对象的key的值和变量名恰好一样，就可以简写
let obj1 = {
    a,
    b,
    c,
    add
}
console.log(obj1); 
//{a: 1, b: 2, c: 3, add: ƒ}
```

#### 对象的解构赋值

##### 对象的简写

```javascript
let a = 1;
let b = 2;
let c = 3;
let add = function () {
    
}
let obj = {
    a: a,
    b: b,
    c: c,
    add: add
}
// 如果对象的key和值的变量名恰好是一样,就可以简写
let obj1 = {
    a,
    b,
    c,
    add
}
// console.log(obj1)
```



##### 基本用法

```javascript
	let obj2 = {
		a:1,
        b:2,
        msg:'hello'
	}
    let {a:x,b:y,msg:z} = obj2
    console.log(x);
    console.log(y);
    console.log(z);
    console.log(obj2.a);
	let{a,b} = obj2
    //let {a:a,b:b} = obj2
    console.log(a,b)
	let {x,y} = obj2
    console.log(x,y)//undefined
	//此时x，y没有和obj相关联 无法对应到具体的值，因为对象本身是无序的

```

##### 赋原型属性

```javascript
 let obj3 = {
        name:"tina",
        age:100,
        say(){
            console.log('hello');
        }
    }
    let {name,say,toSting} = obj3
    console.log(name);
    say()
    console.log(toString);
    //toString 是Object原型的方法
```

##### 赋默认值

```javascript
let {age:n = 10} = obj3
console.log(n)
```

#### 展开运算符

...的作用：主要是用来开展数组和对象

```javascript
 let arr = [1, 2, 3]
    add(...arr)

    function add() {
        console.log(arguments);
    }
    let brr = [...arr] // 展开再放到数组中
    console.log(brr);

    const obj = {
        a: 1,
        b: 2
    }
    console.log({...obj});
    //{a: 1, b: 2}
    const obj1 = {
        a: 9,
        b: 10
    }
    const newObj = {...obj,...obj1}
    console.log(newObj);
    // {a: 9, b: 10}

    let crr = [...brr,5]
    let obj2 = {...obj,x:5}
    console.log(obj2);
    //{a: 1, b: 2, x: 5}
```

#### 模板字符串

>  大括号内可以放任意的js表达式，但是一定要有返回值

```javascript
let box = document.getElementById('box')
let msg = '今天天气不错'
// box,innerHTML = "<p>" + msg + "</p>"
box.innerHTML = `<p>${msg}</p>`
let a = 1;
let b = 2;
alert('a:'+a)
alert(`b:${b}`)
```

####  函数中的this和super

> 如果箭头函数中出现this，它的指向应该是根据  它的上一级的作用域的环境进行判断

+ **this**
  + this一般只出现在函数内部
  + this指向的是当前函数的执行环境
  + 设定this的意义：
    + 同一个函数在不同的环境下执行，可以有不同的效果
  + 只有在函数执行的时候才能判断this指向
    + 如果判断不准this的指向（console.log(this））

```javascript
const obj2 = {
	add:()=>{
	console.log(this)
	},
	dist:function(){
		console.log(this)
	}
}
obj2.add()//window
obj2.dist()//obj2
```

+ **super**

  + 根this有同样的特性

  + super指向的是当前函数执行环境所属类的父类的原型prototype

  + 书写的时候只能写在实例的方法里面

    ```javascript
    Obj.prototype.name = "2007"
    let obj3 = {
        fn(){
            console.log(this)
            console.log(super.name)
        }
    }
    obj3.fn()
    //super ===> Obj.prototype
    ```

    

#### 函数中修改this指向

``call apply bind``

##### call

`fun.call('新的指向，1，2，3')`

+ 让调用call的函数执行

+ 在函数执行的时候，传入了this指向

+ call后面的参数会被函数的参数捕捉

  ```javascript
  function add(a, b) {
  	console.log(arguments)
  	console.log('add函数已执行')
  	console.log(this)
  	console.log(a + b)
  }
  // add() window
  const obj = {
  	a: 1,
  	b: 2
  }
  // add.call('zxcvb')
  // add.call(obj)
  ```

  

##### apply

+ 让调用apply的函数执行

+ 在函数执行的时候，传入了this的指向

+ apply的第二个参数是数组（类似于arguments，形参集合）

  `add.apply(obj, [99, 10])`

##### bind

+ 不能使调用bind的函数执行
+ 生成一个新的函数
+ 可以改变函数内部的this

```javascript
let stu = {}
let a = () => {
    console.log(this) //window
}
a()
a.call(stu) //window
a.apply(stu) //window
let f = a.bind(stu)
f() //window
```

##### call()    apply()     bind()  的区别

+ **call（）和apply（）**
  + 相同点：
    + 两个方法都是通过一个函数调用；并且修改这个this指向
    + 两个方法都有两个参数：
      + 第一个参数代表this指向的对象
      + 第二个参数调用这两个方法的函数内需要传递的参数
  + 不同点：
    + call地第二个参数传递的是一个个的值，apply（）传的是一个数组
+ **bind（）**
  + 可以改变this指向，但是不能直接让调用的函数执行，也不传参
  + 可以返回一个新函数，让新函数去执行和传参

#### 箭头函数

```javascript
let add = (/*形参*/) =>{//代码块}
```

##### 简写

```javascript
//如果只有一个形参
const say = name =>{
    console.log(name)
}
say('hello')
// 如果没有参数
let add = () => {//代码块}
//如果有多个参数
let add = (a,b,c,d,e) => {return a + b}

//如果作为对象中的方法
const obj = {
    fun1(){
        //function简写
    }，
    fun3:function(){},
    fun2:()=>{
        //箭头函数
    }
}
```

##### 箭头函数的中的this

> 如果箭头函数中出现了this，他的指向应该根据他的上一级的作用域环境进行判断

```javascript
const obj2 = {
    add: () => {
    // console.log(this)
	},
dist: function () {
    // console.log(this)
	}
}
obj2.add() //window
obj2.dist()// obj2
```

##### 箭头函数中修改this指向

```javascript
let stu = {}
let a = () => {
	console.log(this)
}
// a()
// a.call(stu)//window
// a.apply(stu)//window
let f = a.bind(stu)
```



#### 类 class

```javascript
class Preson{//通过class关键字创建类
    //在类里面写的是成员方法和成员属性
    constructor(name,age){
        this.name = name;
        this.age = age
    }
    sayname(){
        // 成员方法的this都指向生成的实例
        alert(`我叫${this.name},我今年${this.age}岁`)
    }
}
//类里面的成员方法最终会被挂在类的原型上（prototype），并且成员方法之间是通过this来沟通的
let xiaoming = new Preson（"小明"，18）
xiaoming.sayname()
```

##### 类的继承

**子类必须在constructor 方法中调用 super()**

`因为：子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法然后对其进行加工，再加上子类自己的实例属性和方法，如果不调用super（）,子类得不到this对象`

```javascript
class Student extends Preson {
	constructor(name, age) {
		super(name, age)
	}
    sayage() { //子类的方法
    	console.log(`我的年龄是：${this.age}岁`)
	}
	sayname() {//子类重写父类的方法
		console.log(`sayname方法被我重写了`)
	}
    say() {// 在子类中访问父类的方法
   	 	console.log(this)
    	console.log(super.sayname)
        // this.sayname()
        // 如果子类重写了父类的方法，在子类中要访问父类的方法可以使用super
        super.sayname()
    }
}
let st = new Student('小明', 18)
```

**子类可以访问父类的属性和方法，父类不可以访问子类的属性和方法，子类可以重写父类的方法**

#### 静态实例

挂在类本身的方法，静态方法（类方法）Array.xxx（）

在原型中方法叫成员方法（原型方法）Array.prototype.xxx（） 

#### 静态方法

实例可以访问到吗？

##### Array.from()

把接受到的参数准换成数组，仅仅能转换类数组（集合，字符串），如果不是类数组返回[]

```javascript
Array.from('abc')
// ['a','b','c']
Array.from(123)
//返回：[]

```

##### Array.isArray()

> 一般情况我们判断类型使用的是typeOf但是判断 [] ,{},null的时候返回值都是 object，如果该方法一个参数，如果是数组返回true

```javascript
typeof[]//object
typeof{}//object
typeof null//object
Array.isArray([])//true
Array.isArray({})//false
Array.isArray(null)//false
```

#### 实例方法

通过我们new出来的实例去调用方法

##### arr.forEach(fn)

接收一个函数，该函数会依次执行，执行的次数就是数组的长度，每次执行都接收三个参数

分别是：数组元素，数组的索引，数组本身

```javascript
 let arr = ['a', 'b', 'c']
    arr.forEach((item, i, brr) => {
        console.log(item);
        console.log(i);
        console.log(brr);
    })
    Array.prototype.myforeach = function (fn) {
        for (let i = 0; i < this.length; i++) {
            fn(this[i],i,this)            
        }
    }
```

##### arr.map()  

返回值：一个新数组

map接收的回调函数里面返回值会作为新数组的元素

接收一个函数，该函数会依次执行，执行的次数就是数组的长度，每次都接收三个参数

分别是：数组元素，数组的索引，数组本身

```javascript
 let arr = [1,2,3,4,5,6,7,8]
   let newArr = arr.map((item,i,arr)=>{
       return `${item}+${i}`
   })
   console.log(newArr);
```

##### arr.find()

> 即使多个符合条件的元素，也仅仅找一个，找到第一个就停止查找

```javascript
let arr = [1,2,3]
let result = arr.find(itme => itme > 1)
console.log(result)//2
```

##### arr.findIndex()

> 跟find（）方法效果一样，只不过返回查找到元素的索引，没找到返回结果是 -1

```javascript
let resultIndex = arr.findIndex(item => item >1)
console.log(resultIndex)
```

##### arr.filter()

> 从数组中筛选出所有符合条件的元素，并且把这些元素组成一个新的数组，不修改原素组返回值：所有符合条件的元素组成数组

```javascript
let resultfilter = arr.filter(item =>item >1)
console.log(resultfilter)
```

##### arr.every()

> 返回值是boolean值，用来判断数组中的元素是否都符合某一条件，如果全部符合返回为true，只要有一个不符合false

```
let arr = [1,2,3]
arr.every(item => item > 3) //false
arr.every(itmm => item > 2) //false
arr.every(item => item > 0) //true
```

##### arr.some()

> 返回值是boolean值，用来判断数组中的元素是否都符合某一条件，如果有符合的元素，就返回true（只要有一个），如果全没有返回false

```javascript
arr.some(item => item > 2) //true
arr.some(item => item > 0) //false
```

##### arr.reduce()

> 第一次参数：上一次执行的返回值；第二个参数：next下一个要遍历的元素；第三个参数：index；第四个参数array
>
> **reduce的返回值，最后一次回调函数执行的返回值**

```
let arr = [66,77,88]
arr.reduce((a,b)=>{
	console.log(a,b)
	return b - a
})
```

#### 对象的新增方法

##### Object.assign()

> 用于合并对象（可以合并多个），最少接收两个参数类型必须是对象

**会把第二个以及以后的对象属性都合并到第一个对象，但是这些被合并的对象不会被修改，把第一个对象作为assign的返回值**

```javascript
 let obj1 = {
        a: 1,
        b: 2
    }
 let obj2 = {
     a: 99,
     fn() {
         console.log(1)
     }
 }

 /*es5 合并对象
       for (let key in obj2) {
            obj1[key] = obj2[key]
        }
        console.log(obj1)
    */
 let obj3 = Object.assign(obj1, obj2)
 console.log(obj3)
```

##### Object.is()

> 跟比较运算符 === 的效果一样，仅仅修复了比较NaN与NaN的行为

```javascript
NaN === NaN
//false
Object.is(NaN,NaN)
//true
```

##### Object.keys()

> 用来遍历对象，该方法接收一个对象，返回值又该对象的key组成的数组

```javascript
let obj3 = {
    a:99,
    b:2,
    fn(function(){
        
    })
}
console.log(obj3)
//['a','b','fn']

Object.key(obj3)
Object.key(obj3).forEach(item =>{
    console.log(obj3[item])
})
//把所有的数组的键名 放在一个数组当中
```



------



### node

> js运行环境是浏览器，js分为bom，dom，ECMAScript；js一定要依赖一个页面，才能执行

#### node初识

+ node是一款软件，功能：解析并运行JS（bom，dom，ECMAScript的API）
+ node是命令行应用，没有操作页面
+ node里面没有bom和dom；
+ 功能：操作文件；搭建服务器等

##### 命令行工具

+ 用 win + R, 输入cmd
+ 右键在文件下打开cmder
+ 长摁住shift 鼠标右键 选择PowerShell 输入cmder

#####  常用的cmd命令

+ 查看当前目录下的所有内容 dir
+ cd:切换工作目录
  + `cd F:`
+ 在盘内进行切换的时候，采用相对路径 一个点代表当前目录 两个点代表上一级目录
  + `同级 cd ./  上一级：cd ../   进入到盘符的根目录 cd/`

##### node中js如何运行

> 浏览器如何运行：把工作目录定位到要运行的js文件的目录在命令行中输入 node 要运行的js文件名

+ 运行文件：node 要运行的js文件名
  + `node index.js`
+ 技巧
  + 快捷技巧：使用tab键，自动补全当前目录名称
  + 快捷技巧：键盘的上下键，可查看历史命令
+ 不支持dom

#### node中的模块

##### node中的模块

+ commonjs是最早提出的js中的模块化规范
+ AMD，CMD规范是浏览器端的规范

##### 关于模块化的总结

+ 能够使各个模块独立运行，且互相不影响

+ 模块与模块之间应该一种统一的合作方式

  + ##### 什么是模块化

    + 把一个复杂的系统分解成各个模块
    + 每个模块完成指定的功能
    + 各个模块之间相互不影响
    + 模块与模块之间应该有约定明确的规则可以一起配合工作

  + **模块化的意义**

    + 代码的复用性
    + 代码的可维护性
    + 更加友好的组织代码
    + 便于团队协作
    + 减少单个文件的体积

##### node中的模块

+ 一份js文件就是一个模块
+ node中规定使用require方法引入模块
+ node中规定使用module.exports去导出模块

##### node中模块的分类

+ 自定义模块（我们自己创建的模块）
+ 核心模块（包含在node内部，安装node环境，那么这些模块就可以直接使用了，比如fs）
+ 第三方模块（需要安装，有个人创建并按照规范传到node包管理中心的模块）

```javascript
function add(){
    console.log('你好：NIHAO')
}
let b = '弄啥嘞'

module.exports = {add,b}

const{add,b} = require('路径')
console.log(add(),b)
console.log('hello world')
```



------



### fs模块

#### fs的功能

> fs模块是一个核心模块，**主要的功能是操作目录和文件**

##### 读取文件

**fs.readFileSync(url,'utf-8)**

+ 参数：
  + 要读取文件的路径
  + 字符显示编码
+ 如果文件路径不存在，报错

```javascript
let html = fs.readFileSync('./1.html', 'utf-8');
```

##### 写入文件

**fs.writeFileSync(URL,str,'utf-8')**

+ 参数：
  + 写入文件的路径
  + 要写入的内容
  + 字符显示编码规范
+ 如果文件路径不存在，会创建，如果已存在会完全覆盖

```javascript
fs.writeFileSync('./dist/newHtml.html',html,'utf-8')
```

##### 删除文件

**fs.unlinkSync(URL)**

+ 参数：
  + 要删除的文件路径

```javascript
fs.unlinkSync('./hello.html')
```

##### 判断资源是否存在

**fs.existsSync(URL)**

+ 参数：
  + 要判断的资源的路径
+ 如果 存在返回true，如果不存在返回false

```javascript
fs.existsSync('./hello.html')
```

##### 判断资源是文件还是目录

**fs.statSync(URL)**

+ 参数：
  + 要判断的资源的路径
+ 识别该资源对象，里面有判断文件或目录的方法
  + 返回值：Object

```javascript
fs.statSync('./hello.html')
```

##### 判断是否为文件

**isFile()**

+ 参数：
  + 无
+ 如果是文件返回true

```javascript
!fs.statSync(filePath).isFile()
```

##### 判断是否为文件

**isDirectory()**

+ 参数：
  + 无
+ 如果是目录返回true

```javascript
!fs.statSync(filePath).isDirectory()
```

##### 创建目录

**fs.mkdirSync()**

+ 参数：
  + 要创建的目录
+ 如果已有会报错

```javascript
fs.mkdirSync('./dist')
```

##### 删除目录

**fs.rmdirSync()**

+ 参数：
  + 所要删除的目录
+ 如果不是空目录 会报错 只能删除空目录

```javascript
fs.rmdirSync('./dist')
```

##### 读取目录

**fs.readdirSync()**

+ 参数：
  + 所要读取的目录
+ 如果不是空目录 会报错 只能删除空目录
  + 返回值：该目录下内容文件名称组成的数组

```javascript
fs.readdirSync('./src')
```



------



### npm

> npm属于node的一个模块，node包管理器（node package manger）通过命令行使用

#### npm 常用的命令

##### npm init

> **通过命令npm init，初始化创建包的描述文件package.json**

```javascript
{
  "name": "npm",  //包名
  "version": "1.0.0",  //版本
  "description": "我的第一个npm包",  //描述
  "main": "index.js",  //入口文件
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "jiakaiqi",  //作者
  "license": "ISC"
}
```

##### 安装包：npm install 包名

> **安装包的命令 (npm install 包名,从npm的官方网站下载**

+ 全局安装
  +  npm intall 包 -g
+ 本地安装（生产环境`dependencies`)
  + npm intall 包 -S
  + npm intall 包 --save
+ 本地安装（开发环境`devDependencies`)
  + npm intall 包 --save-dev
  + npm intall 包 -D

##### 卸载包：npm uninstall 包 环境

> 卸载包的时候会把package.json 中对应的字段删除，并且把node_modules中对应的文件删除

+ 例如： npm uninstall swiper -S

##### 快速安装：npm install 

> a. 在有package.json的工作目录下执行
> b. 检测package.json中的 depdencies 和 devDepdencies两个字段，并且全部安装它们所保存的包

##### 设置和查看全局包的安装位置

> 有些全局包是一些使用的工具 
> cli-dict 字典功能 使用dict 单词、汉语
> Anywhere 以为工作目录为静态资源目录，创建服务器

+ 查看:npm config get prefix
+ 设置：npm config get prefix

##### 设置和查看下载源

+ 查看 npm config get registry
+ 设置 npm config set registry
  +  https://registry.npm.taobao.org/
+ 一般情况默认npm是国外网站，国内淘宝做了一份镜像
  + https://registry.npm.taobao.org/

#### node中的包

> 包就是把多个node模块集合在一起，但是要遵守相关的一些规则，一个集合了js文件的目录就是一个包

##### 包的初始化

+ 包相关的规则
  + 在目录的根部创建package.json,该文件中有众多属性，这些属性赋予了包额外的特性，一般使用 npm init创建。

##### 如何引入包

+ 通过包的路径
  + 通过包的路径引用包，默认查找index.js,如果没有，会找package.json中的main字段（入口文件）

```javascript
const swiper = require('./node_modules/swiper')
```

+ 直接引入入口文件

```javascript
const swiper = require('./node_modules/swiper/swiper.cjs')
```

+ 通过包名引入包
  +  必须存入node_modules
  + 包必须符合包的规范

```javascript
const swiper = require('swiper') //包名
```

##### 通过包名查找包的规则

+ 在当前目录下的node_modules下去查找包名的目录
+ 按照包的规则去加载包
+ 如果在当前目录的node_modules没找到对应的目录，继续向上一层按照该规则去查找，直到找到盘符的目录
+ 如果根目录也没有找到，那么就去全局的环境变量NODE_PATH所对应的目录

#### 关于路径

##### 相对路径

> 参照的是工作目录（工作目录不确定，易变）

nodejs 的相对路径参照的不是文件所在的位置，而是node当前的工作目录,而node的当前工作目录 是node命令运行的位置

##### 绝对路径

> 从盘符出发开始找

`C:\Users\lenovo\Desktop\2007-node`

##### __dirname

> node中提供了一个__dirname,指的是当前文件所在目录的绝对路径，与工作目录无关

`C:\Users\lenovo\Desktop\8.ajax`

##### path模块

> node中提供了path模块，这个模块可以拼接路径

`path.join(url,url......)`





------



### babel

#### 初识bable

##### 作用

+ babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。

##### 功能

+ 把新的写法转换成普通写法

```javascript
Const add=() => {} 转换成 var add=function(){}
```

+ 把一些新特性（新加的方法，新的属性）转换成 使用低版本模拟 

#### babel7

> babel7把各个功能拆分到了不同的包中

+ 我们的项目，开发完成要上传到服务器的时候，有些东西是不要的，比
  如说babel，我们使用es6写完之后，使用babel转化成es5，最终我们
  服务器上传的是es5部分，babel作为转换工具我们就不需要了，所以最
  后就不会往服务器上传

#### babel 安装命令

##### @babel/cli

> babel提供的内建的命令行工具，主要是提供babel这个命令来对js文件进行编译

`npm i @babel/cli -D`

报错：找不到@babel/core

##### @babel/core

> 这个包是babel功能实现的核心，也就是说babel核心的方法都在这个包里面

`npm i @babel/core -D`

成功输出babel版本就说明我们可以使用babel命令行工具了

##### 转码

> **npx babel index_es6.js -o index_es5.js**

babel7把各个功能拆分到了不同的包中，比如说吧箭头函数转化成普通函数，

**安装**

> **npm i @babel/plugin-transform-arrow-functions -D**

+ 使用插件：

  + **npx babel index_es6.js -o index_es5.js --plugins @babel/plugin-transform-arrow-functions**

    `如果我们在代码中大量的使用插件，依然避免不了在配置文件中大量填写插件信息，babel给我们提供了一个叫preset的概念，（预设），插件包`

**@babel/preset-env**

> **npm i @babel/preset-env -D**

**使用**

> 在.babelrc文件中配置

```javascript
{
   "presets": [
       "@babel/preset-env"
   ]
}
```

##### babel**编译文件**

> npx babel index_es6.js -o index_es5.js

+ -o是生成文件
+ -d 生成目录

**实时编译**

> npx babel es6 -d es5 -w

+ -w 实时编译

### es6模块

#### es6模块的使用

##### 普通导出

> 通过export关键字导出，在es中export属于关键字；

```javascript
export function add(){
    return a + b;
}

export function sub(){
    return a - b;
}
```

##### 集中导出

>   export {a,b,c}, 最后以对象的形式导出；

```javascript
function add(a, b) {
	return a + b
}
function dist(a, b) {
	return a - b
}

export { add, dist }
```

##### 修改导出名

> 通过as关键字，来给导出的内容修改导出名称；

```javascript
function add(a, b) {
	return a + b
}
function dist(a, b) {
	return a - b
}

export { add as addFun, dist }
```

```javascript
//导入
import {add as addFun, dist} from './module'
```



##### 默认导出

> export 导出的时候 需要 ｛｝去接
>
> export default 导出不需要｛｝，只能导出一个

```javascript
// 导出
function add(a, b) {
	return a + b
}
function dist(a, b) {
	return a - b
}
export(add,dist)
export default add
```

```javascript
//导入
import {add,dist} from './module'
import add from './module
```

##### 复杂导出

> c抛出，b导入c，b抛出c，a导入b

```javascript
export const obj = {name:'c'}
```

```javascript
import {obj} from './module'  //将导入的模块直接导出
```

```javascript
export {obj} from './documet' 
```

#### node环境下运行es6语法

##### 安装

> **npm install @babel/plugin-transform-modules-commonjs -S**
>
> **npm install @babel/register -S**

+ 快捷方式
  + npm install @babel/register @babel/plugin-transform-modules-commonjs -S
+ @babel/register的用法
  + 解决node不支持es6的问题

##### 配置

> 创建entry.js 

```javascript
 // 提前加载转码环境

require('@babel/register')({
    plugins: [
        "@babel/plugin-transform-modules-commonjs"
    ]
})
// 	加载目标文件
require('./index')
```

##### 运行

> **node entry.js**



------



### 服务器

#### url 地址详解

![1611630256744](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1611630256744.png)

#### 认识服务器

+ 服务器也是一台电脑，常年不关机，接入网络的设备

+ 每一个设备都有一个地址，根据这个地址，我们就能找到对应的服务器

+ 在浏览网页的时候在不停的向服务器发起请求，我们把写出来的网页，放在服务器上，我们根据服务器地
  址，就能看到页面



![1611630545557](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1611630545557.png)

> **服务器应用会处理并解析url，然后寻找对应的资源，返回给浏览器，我们使用node做的其实就是服务器的应用**

**服务器应用应该具备的功能**

>  接收并解析url的功能；查找对应的资源；把查找的资源返回给请求方

#### node-dev

> **文件被修改时，会自动重启node进程**

`npm install node-dev -g`

#### 搭建node环境

##### 初始化一个包

> npm init -y

##### 配置全局环境

> **npm install @babel/plugin-transform-modules-commonjs -S**
>
> **npm install @babel/register -S**

+ 快捷方式
  + npm install @babel/register @babel/plugin-transform-modules-commonjs -S

##### 配置entry.js

>  **创建entry.js** 

```javascript
 // 提前加载转码环境

require('@babel/register')({
    plugins: [
        "@babel/plugin-transform-modules-commonjs"//让插件支持es6模块
    ]
})
// 	加载目标文件
require('./index')
```

##### 执行entry.js

> **在entry.js文件内 （通过转义内容，）在后方指定当前环境所支持得环境 require（“./index”），执行entry.js**

+ **安装npm install node-dev -g**
  + node-dev entry.js(实时跟随服务)

##### 创建一个**index.js**

###### 引入http模块

>  import http from "http"

```javascript
import http from "http"
```

###### 创建服务器

>  在创建好index.js文件中，创建服务器

```javascript
//req 请求对象，res响应对象
let server = http.createServer((req,res)=>{
    req(req.url);
	res.end('响应的内容');
})
```

###### 监听端口

> 监听服务器，设置端口

```javascript
// 建议3000以上端口监听,3000是市场高使用区 避免重复使用
// 给服务器应用分配一个端口号
server.linsten(3000,()=>{
	console.log('zhixing');
})
```

#### url模块的使用

##### 解析url路径

> **引入模块**

+ const url = require('url');
+ import url from 'url'

> **使用模块**

+ const urlPath = url.parse(req.url)
+ 得到一个url对象

> 'http://140.143.201.230:8888/list/index.html?user=aaa&age=12#nav'

**cmder**

![1611632779570](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1611632779570.png)

**代码**

```javascript

import http from 'http'
import url from 'url';

let str="http://140.143.201.230:8888/list/index.html?user=aaa&age=12#nav"
let ourl = url.parse(str)
console.log(ourl)
```

##### 解析字符串参数

> querystring模块，把字符串解构成对象格式

+ 引入模块
  +  const qs = require('querystring');
  +  import qs from 'querystring'
+ 使用模块
  + const arg = qs.parse(urlPath.query); 

得到的arg是参数的对象，可以被使用:const {id,size} = arg;

![1611633228498](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1611633228498.png)

#### network面板

![1611632898438](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1611632898438.png)

> **控制台的功能**

![1611633631694](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1611633631694.png)

> **点击每条请求后**

![1611633661571](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1611633661571.png)



> **每天请求的报文和头信息的查看:**

![1611633688480](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1611633688480.png)

#### get请求和post请求

+  安全性post更好
+ 传递的数据量post更大 
+ 传递参数的方式不同
  + get：在url地址后面加查询字符串
  + post：通过请求体传送
+ 执行率get更高

##### 使用场景

​	get：单纯的提取数据

​	post：提交数据；修改服务器数据

#### **请求对象和响应对象常用的属性和方法**

##### 获取请求方法

>  **request.method**

`POST GET`

##### 获取请求头信息

> **request.headers**

` 返回的是 对象`

##### 获取最原始的所有请求头信息

> **request.rawHeaders**

`返回的是数组`

##### 设置状态码

> **response.statusCode=200;**

##### 设置状态信息

> **response.statusMssage=""**

##### 设置响应头

> **Response.writeHead**

```javascript
res.writeHead(200,'page not find',{
	'Location':"path"
})
```

##### 响应头操作方法

**设置**

>  **response.setHeader(name,value)**

`可以设置多次，不要和 writeHead一起使用`

**删除**

> **response.removeHeader(name,value)**

`只能删除setHeader设置的`

**查看**

> **response.getHeader(name)**

`只能查看setHeader设置的相应头`

**查看所有**

> **response.geHeaders**

##### 写入要发送给浏览器的数据

> **response.write()**

`接受的参数，只能是字符串或者buffer`

`write只是写入，可以以写入多次`

**把写入的数据发送**

> **response.end()**

#### 获取POST请求提交的数据

```javascript
// 获取post 传递过来的数据
let buf = Buffer.alloc(0);//创建一个buffer池
req.on('data', chunk => {
    // 拼接每次获取的buffer数据
    buf = Buffer.concat([buf, chunk])
})
// 数据接收成功
req.on('end', () => {// 异步
    
})
console.log(buf.toString())
```

#### 重定向

```javascript
export default function err_404(res) {
    res.writeHeader(301, 'page not find', {
        'Location': "./public/404.html"
    })
    res.end()
}
```

#### 浏览器可以发出http请求的方式

##### 在地址栏输入url地址

>  请求的资源类型一般为html，js，css，图片

+ 仅仅支持GET方式

##### link标签href属性

> 请求的资源类型只能是css：Content-type:text/css

+ 仅仅支持GET方式

##### a标签href属性

> 请求的资源类型只能是html：Content-type:text/html

+ 仅仅支持GET方式

##### img标签src属性

> 请求的资源只能是图片：Content-type：image/html
+ 仅仅支持GET方式

##### script 标签 src属性
> 请求的资源只能是js文件：Content-type:text/javascript
+ 仅仅支持GET方式

##### ajax
> 可以局部刷新
+ GET POST

##### form表单
> 每次提交，都会刷新页面

+ GET POST
  + **action：提交地址**
  + **method：设置请求方式**
  + **nput type=submit：提交表单**

##### 跨域与Jsonp

##### 什么是跨域

> 资源所在服务器地址与资源内发起请求的目标服务器地址不同源就是跨域

#####  同源的条件

> 同源：协议、域名、端口都一样

##### ajax跨域的方法

+ jsonp
+ 服务器代理 
+ 跨域资源共享

##### Jsonp的原理

+ 解决ajax跨域请求的一种方案
+ **请求的时候不再使用ajax，而是使用script标签来代替，通过src属性发送请求**
+ 可以灵活的创建
+ 可以灵活的设置输入层
+ **接受的是js代码（接收到的数据可以认为是js代码的一部分）**

##### 跟ajax比较

+ 仅仅能解决get方式的跨域问题，接收的数据单一

### express

#### 定义

> express可以快速搭建一个完整的服务器，可以让服务端的开发变得更加简单
>
> https://www.expressjs.com.cn/

#### 运行express

##### 安装

​	`npm install express -S`

##### 创建服务器

~~~javascript
import express from 'express';
const app = express()
~~~

##### 设置端口号

~~~javascript
app.listen(8080, () => {
    console.log(`server had run with express at http://localhost:8080`)
})
~~~

##### 响应静态资源

~~~javascript
app.use(
    express.static(path.join(__dirname, './public'))
)
~~~

#### express常用API

**express.static()**

**作用**：解析静态资源



**express.urlencoded()**

**作用**：处理post的传递的 `application/x-from-urlencoded` 格式数据

​			`key=val&key2=val2`



**express.json()**

**作用**：处理post传递的 application/json 格式的数据

##### 应用对象app

**app.use()**

>  **app.use()给应用添加一个函数（中间件），可以添加多个,添加的函数在接收到请求的时候，按照添加的顺序去执行，靠next去接力**

> **next 本质上是一个函数，这个函数的调用可以让中间件继续往下走如果没有调用next，要让应用继续往下走 ，就必须给一个响应**

~~~JavaScript
app.use((req,res,next) => {
    console.log('中间件1')
    next()
})

app.use((req,res,next) => {
    console.log('中间件2')
    next()
})
~~~

**app.get() app.post()**

> 和use的行为差不多，多接受一个路径参数，在每次接收到请求的时候执行，需要匹配路径和请求方法

~~~javascript
app.get('/login',(req,res,next)=>{
    console.log('请求到login参数')
    //req.query接受到get请求的参数
    //请求到请求之后的处理
    //响应浏览器
    res.send({
        code:'01',
        msg:'响应成功'
        data:req.query
    })
})

app.post('/register'.(req,res,next)=>{
    console.log('请求到register参数')
    console.log(req.body)
    res.send({
        code:'01',
        msg:'响应成功'
        data:req.query
    })
})
~~~

##### **请求对象**

---

**req.body** 

**作用：**接受post请求的参数

**req.query**

**作用：**接收get请求的参数

**req.originaurl**

**作用：**获取原始的url地址

**req.get** 

**作用：**获取请求头

---

##### **响应对象**

**res.set(key,value)** 

**作用：**设置响应头

**res.send()** 

**作用：**发送数据

**res.sendFile()** 

**作用：**发送文件

**res.download()** 

**作用：**下载文件

**res.redirect()** 

**作用：**重定向

**res.jsonp()** 

**作用：**以jsonp的方式返回数据

**res.cookie()** 

**作用：**让浏览器把数据存储到浏览器的cookie中

### gulp

#### 文档

##### gulp官方文档 

​		https://www.gulpjs.com.cn/docs/getting-started/quick-start/

##### npm仓库，可查询所有的包 

​		https://www.npmjs.com/

##### gulp插件列表 

​		https://gulpjs.com/plugins/

##### autoprefixer设置 

​		http://autoprefixer.github.io/

#### 定义

1. gulp是node的一个包（第三方包） 
2. **gulp提供了对文件系统的流式操作** 
3. 有自己的任务机制 
4. 对于实现不同的功能，有很多插件供我们使用 

#### 基本操作

##### 安装gulp

​		`npm install gulp -D` 

​		`npm install gulp-cli -D`

##### gulp的使用

 1. **在根目录创建gulpfile.js **

 2. **gulpfile.js中创建任务**

 3. ~~~js
    function fun(complate){
        console.log(`hello world`)
        complate()//表示任务完成
    }
    //注册任务
    module.exports = {fun}
    
    
    //老式创建注册任务 （不推荐）
    const gulp = require('gulp')
    gulp.task('oldfun',complate =>{
        console.log(`hello old`)
        complate()
    })
    ~~~

 4. 执行任务 nbx gulp 任务名

    `nbx gulp fun`

#### gulp插件

##### 文件合并与压缩（css,js）

~~~js
const gulp = require('gulp');
const concat = require('gulp-concat');//拼接文件
const cssMin = require('gulp-css'); //压缩(丑化)css
const uglyfly = require('gulp-uglyfly');//压缩(丑化)js

function concatCSS() {
    return gulp.src('src/*.css')
        .pipe(concat('all.css'))
        .pipe(cssMin())
        .pipe(gulp.dest('dist'))
}
function concatJS() {
    return gulp.src('src/*.js')
        .pipe(concat('all.js'))
        .pipe(uglyfly())
        .pipe(gulp.dest('dist'))
}
~~~

##### 清理目录

~~~js
const clean = require('gulp-clean');//清空文件夹
// 清空文件夹的任务
function clear() {
    return gulp.src('dist').pipe(clean())
}
~~~

##### es6转es5，并且使浏览器支持commonjs

~~~js
const babel = require('gulp-babel');// es6 =>es5
const browserify = require('gulp-browserify'); //让浏览器支持commonjs规范
function es6Toes5() {
    return gulp.src('src/*.js')
        .pipe(babel({
            presets: ['@babel/env']
        }))
        .pipe(gulp.dest('es5'))
}
function browIndex() {
    return gulp.src('es5/index.js')
        .pipe(browserify())
        .pipe(gulp.dest('dist'))
}

const es5 = gulp.series(es6Toes5, browIndex,es5)

module.exports = { concatCSS, concatJS, clear, es6Toes5, browIndex, es5 }
~~~

##### 给css添加私有前缀

~~~js
/* 
    结构化css gulp-postcss
    给css加私有前缀 autoprefixer
*/
const postcss = require('gulp-postcss')
const autoprefixer = require('autoprefixer')

function prefixcss() {
    return gulp.src('src/*.css')
        .pipe(concat('all.css'))
        .pipe(postcss([
            autoprefixer({
                overrideBrowserslist: ['last 50 version']
            })
        ]))
        .pipe(cssMin())
        .pipe(gulp.dest('dist'))
}
~~~

#### 常用的API

##### gulp.src()

> 接收一个能够匹配资源的字符串（批处理），返回一个流对象，该对象用来表示读取到的资源

##### gulp.dest()

> 接收流数据并把资源写到指定的目录

**.pipe():管道**

~~~js
const gulp = require('gulp')

function test（）{
    return gulp.src('src/*.css').pipe(gulp.dest('dist'))
}
module.exports = {test}
~~~

##### gulp.series() 

> 接收任务名，把任务组合成 一个大的任务，被组合的任务会按照顺序依次执行

##### gulp.parallel()

> 接收任务名，把任务组合成 一个大的任务，被组合的任务同时开始执行

~~~js
function test1(complase){
    console.log('test1开始执行')
    setTimeout(function(){
        console.log('test1执行完毕')
        complate()
    }.3000)
}
function test2(complase){
    console.log('test2执行完毕')
    complate()
}

const all = gulp.series(test1,test2)
const all_1 = gulp.series(test1,test2)
module.exports = {all,all_1}
~~~



