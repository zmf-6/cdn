目录

[JS相关：	](#_Toc1446)

[（1） 闭包	](#_Toc29471)

[（2） 说一下JS中的原型链的理解？	](#_Toc16955)

[（3）说一下JS继承（含ES6的）--或者人家这样问有两个类A和B,B怎么继承A？	](#_Toc21886)

[（3） 说一下JS原生事件如何绑定	](#_Toc1117)

[（4） 说一下JS原生常用dom操作方法？	](#_Toc15992)

[（6） (了解)JS设计模式有哪些(单例模式观察者模式等)	](#_Toc31218)

[（7） 说一下你对JS面像对象的理解	](#_Toc4179)

[（8） 说一下JS数组常用方法（至少6个）	](#_Toc8250)

[（9） 说一下JS数组内置遍历方法有哪些和区别	](#_Toc12054)

[（10） 说一下JS作用域和作用域链	](#_Toc24509)

[（11） 说一下从输入URL到页面加载完中间发生了什么？	](#_Toc11077)

[（12） 说一下JS事件代理（也称事件委托）是什么，及实现原理？	](#_Toc4261)

[（13） 说一下JS数据类型有哪些？	](#_Toc10061)

[（14） 说一下call,apply,bind区别	](#_Toc29421)

[git相关：	](#_Toc30069)

[跨域的解决方案目前有三种主流解决方案	](#_Toc16655)

[(6) 说一下你对同步和异步的理解	](#_Toc6748)

[(9) 说一下你对http状态码的了解多少？	](#_Toc30996)

[(10) 你上家公司项目是前后端分离的吗	](#_Toc64)

[(11) 深拷贝，浅拷贝	](#_Toc5939)

[Vue相关：	](#_Toc18851)

[（1） 说一下vue最大特点是什么或者说vue核心是什么	](#_Toc5735)

[（2） 说一下vue常用基本指令有哪些	](#_Toc26129)

[Vue 组件中 data 为什么必须是函数	](#_Toc28316)

[（3） 说一下v-if和v-show的区别	](#_Toc25104)

[（4） 说一下vue自定义指令如何实现的和适用场景？	](#_Toc17767)

[（6） 说一下vue生命周期钩子函数有哪些，分别什么时候触发	](#_Toc29562)

[（7） 说一下vue组件通讯（即传值）有哪几种形式，分别是如何实现的	](#_Toc28008)

[（8） 说一下vue封装组件中的slot作用	](#_Toc3547)

[（9） 说一下vue转场动画如何实现的	](#_Toc29121)

[（10） 说一下你对单向数据流的理解	](#_Toc26244)

[（11） 说一下vue双向数据绑定的原理	](#_Toc5707)

[（12） 说一下vue路由或前端路由实现原理	](#_Toc20083)

[（14） 说一下vue路由懒加载解决什么问题的?	](#_Toc14962)

[（15） 说一下如何解决vue首屏加载慢或白屏？	](#_Toc14403)

[（16） 说一下vue开发环境和线上环境如何切换	](#_Toc15319)

[（17） 说一下你们项目中vue如何跨域的	](#_Toc12984)

[（18） 说一下vue中methods,computed,watch的区别：	](#_Toc7982)

[（19） vue如何动态添加属性，实现数据响应？	](#_Toc9389)

[（20） vue中的http请求是如何管理的	](#_Toc14586)

[（22） 说一下vue和jquey的区别	](#_Toc15722)

[（23） 说一下vue如何实现局部样式的或者说如何实现组件之间样式不冲突的和实现原理是什么？	](#_Toc7427)

[（24） 说一下vue第三方ui样式库如何实现样式穿透的（ui库和less/sass穿透问题）  >>>   /deep/	](#_Toc25772)

[（25） vue目录结构（面试时可能会这样问说一下vue工程目录结构）	](#_Toc4808)

[（26） vue脚手架是你们公司搭建的，还是用的vue的脚本架？webpack了解多少？	](#_Toc4065)

[（27） 说一下你对vuex的理解：	](#_Toc32314)

[（28） vuex如何实现数据持久化（即刷新后数据还保留）？	](#_Toc20081)

[（29） 说一下nextTick的作用和使用场景	](#_Toc26490)

[v-for 与 v-if 的优先级	](#_Toc11519)

[vue中 keep-alive 组件的作用	](#_Toc24958)

[（1） css3新增特性有哪些	](#_Toc20492)

[（2） 如何实现一个div垂直居中（至少3种方法）	](#_Toc20151)

[（30） clearfix是解决什么问题的（另一种问法div塌陷问题如何解决的,或者说一下BFC）：	](#_Toc26724)

[（31） 说一下你对盒模型的理解(包括IE和w3c标准盒模型)	](#_Toc15424)

[（32） css3动画：	](#_Toc30777)

[（33） rem和em的区别：	](#_Toc3859)

[（3） 手机端如何做适配的：	](#_Toc21984)

[（34） vw和vh了解吗	](#_Toc23641)

[（35） cookie,localStorage和sessionStorage的区别	](#_Toc381)

[IE8如何支持语义化标签	](#_Toc19670)

[谷歌浏览器如何显示12px以下的字号	](#_Toc19758)

 

 

 

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps1.jpg)



 

##  

## ***\*JS相关：\****

### （1） **闭包**

答：闭包说的通俗一点就是可以在函数外部访问到函数内部的变量。正常情况下函数外部是访问不到函数内部作用域变量的，

表象判断是不是闭包:函数嵌套函数,内部函数被return  内部函数调用外层函数的局部变量

​		优点：可以隔离作用域，不造成全局污染

​	  缺点：由于闭包长期驻留内存，则长期这样会导致内存泄露

  如何解决内存泄露：将暴露在外部的闭包变量置为null

适用场景：封装组件，for循环和定时器结合使用,for循环和dom事件结合.可以在性能优化的过程中,节流防抖函数的使用,导航栏获取下标的使用

 

项目后期的时候进行了一定的性能优化.比方说:对级联菜单的功能,使用了节流防抖的方式,减少了http请求,

或者一个注册模块的时候,要实时(oninput)去后台验证用户名是否已注册给出相应的提示.

闭包的应用的时候,处理能够进行导航栏菜单获取当前下标.

巧妙的转嫁到节流防抖函数

提一下lodash函数库.(自愿) 

项目中比较满意的一个点:

### （2） **说一下JS中的原型链的理解？**

答：原型链是理解JS面向对象很重要的一点，这里主要涉及到两个点，一是_ _proto_ **，二是**prototype,举个例子吧，这样还好说点，例如：我用function创建一个Person类，然后用new Person创建一个对象的实例假如叫p1吧，在Person类的原型 prototype添加一个方法，例如：play方法,那对象实例p1如何查找到play这个方法呢，有一个查找过程，具体流程是这样的：

​		首先在p1对象实例上查找是否有有play方法，如果有则调用执行，如果没有则用p1.__proto__(_proto_是一个指向的作用,指向上一层的原型)往创建p1的类的原型上查找，也就是说往Person.prototype上查找，如果在Person.prototype找到play方法则执行，否则继续往上查找，则用Person.prototye.__proto__继续往上查找，找到Object.prototype，如果Object.prototype有play方法则执行之，否则用Object.prototype.__proto__继续再往上查找，但Object.prototpye.__proto__上一级是null,也就是原型链的顶级，结束原型链的查找，这是我对原型链的理解

​		

​	**（3）说一下JS继承（含ES6的）--或者人家这样问有两个类A和B,B怎么继承A？**

​		答：JS继承实现方式也很多，主要分ES5和ES6继承的实现

​			先说一下ES5是如何实现继承的

​			ES5实现继承主要是基于prototype来实现的，具体有三种方法

一是***\*原型链继承\****：即 B.prototype=new A()

二是借***\*用构造函数继承(call或者apply的方式继承)\****

  function B(name,age) {

   A.call(ths,name,age)

  }

 

三***\*是组合继承\****

 组合继承是结合第一种和第二种方式

 

​			再说一下ES6是如何实现继承的

 

​			ES6继承是目前比较新，并且主流的继承方式，用class定义类，用extends继承类，用super()表示父类,【下面代码部分只是熟悉，不用说课】

​			例如：创建A类

class  A ｛

  constructor() {

   //构造器代码，new时自动执行

  }

 

 方法1( ) { //A类的方法 }

 方法2( ) { //A类的方法 }

 

｝

 

创建B类并继承A类

class B extends A {

  constructor() {

   super()  //表示父类

  }

}

 

实例化B类： var b1=new B( )

​         b1.方法1( )

​      

 

### （3） **说一下JS原生事件如何绑定**

答：JS原生绑定事件主要为三种：

​		一是html事件处理程序

​		二是DOM0级事件处理程序

三是DOM2级事件处理程序

​    其中：html事件现在早已不用了，就是在html各种标签上直接添加事件，类似于css的行内样式，缺点是不好维护，因为散落在标签中,也就是耦合度太高

例如：<button onclick=”事件处理函数”>点我</button>

第二类是DOM0级事件，目前在PC端用的还是比较多的绑定事件方式，兼容性也好，主要是先获取dom元素，然后直接给dom元素添加事件

例如：var btn=document.getElementById(‘id元素’)

   btn.onclick=function() {

​     //要处理的事件逻辑

   }

 

  DOM0事件如何移除呢？很简单：btn.onclick=null;置为空就行

  优点：兼容性好

  缺点：只支持冒泡，不支持捕获

第三类是DOM2级事件，移动端用的比较多，也有很多优点，提供了专门的绑定和移除方法

例如： var btn=document.getElementById(‘id元素’)

​    //绑定事件

   btn.addEventListener(‘click’,绑定的事件处理函数名,false)

   //移除事件

   btn.removeEventListener(‘click’,要移除的事件处理函数名，false)

​		

​		优点：支持给个元素绑定多个相同事件，支持冒泡和捕获事件机制

### （4） **说一下JS原生常用dom操作方法？**

答：js原生dom操作方法有？

 查找：getElementByid,

​    getElementsByTagName,

​    querySelector,

querySelectorAll

​    插入：appendChild,insertBefore

​    删除：removeChild

​    克隆：cloneNode

​    设置和获取属性：setAttribute(“属性名”,”值”),getAttibute(“属性名”)

 

（5） **说****一下ES6新增特性?**

答：ES6新增特性常用的主要有：let/const,箭头函数，模板字符串，解构赋值，模块的导入(import)和导出(export default/export),Promise,还有一些数组字符串的新方法,其实有很多，我平时常用的就这些

### （6） **(了解)JS设计模式有哪些(单例模式观察者模式等)**

答：JS设计模式有很多，但我知道的有单例模式，观察者模式

 单例模式：就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。

 

观察者模式: 观察者的使用场合就是：当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。

总的来说，观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化

 

### （7） **说一下你对JS面试对象的理解**

答：JS面向对象主要基于function来实现的，通过function来模拟类，通过prototype来实现类方法的共享，跟其他语言有着本质的不同，自从有了ES6后，把面向对象类的实现更像后端语言的实现了，通过class来定义类，通过extends来继承父类，其实ES6类的实现本质上是一个语法糖，不过对于开发简单了好多。

### （8） **说一下JS数组常用方法（至少6个）**

答：在开发中，数组使用频率很频繁，JS数组常用方法有:push,pop,unshift,shift,splice,join,concat,forEach,filter,map,sort,some,every,includes reduce好多，不过都是平时开发中很常用的方法,大家可以补充一点儿es6的

 

### （9） **说一下JS数组内置遍历方法有哪些和区别**

答：JS数组内置遍历（遍历就是循环的意思）方法主要有：

​	  ***\*forEach:\****这个方法是为了取代for循环遍历数组的，返回值为undefined例如：

   let arrInfo=[4,6,6,8,5,7,87]

arrInfo.forEach((item,index,arr)=>{

  //遍历逻辑

})

其中：

 item代码遍历的每一项,

 index:代表遍历的每项的索引，

 arr代表数组本身

​	  ***\*filter:\****是一个过滤遍历的方法，如果返回条件为true，则返回满足条件为true的新数组

  let arrInfo=[4,16,6,8,45,7,87]

​       let  resultArr=arrInfo.filter((item,index,arr)=>{

  //例如返回数组每项值大于9的数组

  return item>9

})

 

***\*map:\****这个map方法主要对数组的复杂逻辑处理时用的多，特别是react中遍历数据，也经常用到，写法和forEach类似

***\*some:\****这个some方法用于只要数组中至少存在一个满足条件的结果，返回值就为true,否则返回fasel, 写法和forEach类似

***\*every:\****这个every方法用于数组中每一项都得满足条件时，才返回true，否则返回false, 写法和forEach类似

 

### （10） **说一下JS作用域和作用域链**

答：JS作用域也就是JS识别变量的范围，作用域链也就是JS查找变量的顺序

先说作用域，JS作用域主要包括全局作用域、局部作用域和ES6的块级作用域

全局作用域：也就是定义在window下的变量范围，在任何地方都可以访问，

局部作用域：是只在函数内部定义的变量范围

块级作用域：简单来说用let和const在任意的代码块中定义的变量都认为是块级作用域中的变量，例如在for循环中用let定义的变量，在if语句中用let定义的变量等等

注：尽量不要使用全局变量，因为容易导致全局的污染，命名冲突，对bug查找不利。

2️而所谓的作用域链就是由最内部的作用域往最外部,查找变量的过程.形成的链条就是作用域链

原型链往外层找,找到null

作用域链,从找到的地方外外层,一直找到window 

 

### （11） **说一下从输入URL到页面加载完中间发生了什么？**  

DOM树  构建一个样式表.组合成一颗render树,页面经过重绘(重塑)和回流的过程.

答：大致过程是这样的：

\1. DNS解析     

\2. TCP连接

\3. 发送HTTP请求

\4. 服务器处理请求并返回需要的数据

\5. 浏览器解析渲染页面

\6. 连接结束

输入了一个域名,域名要通过DNS解析找到这个域名对应的服务器地址(ip),通过TCP请求链接服务,通过WEB服务器(apache)返回数据,浏览器根据返回数据构建DOM树,再把css形成一个样式表.这两个东西结合,变成了render树.页面上通过重绘和回流的过程,渲染出页面来

### （12） **说一下JS事件代理（也称事件委托）是什么，及实现原理？ $(****“****ul****”****).on(****‘****click****’****,****’****li****’****,function(){})**

能够给动态添加的元素绑定事件

答：JS事件代理就是通过给父级元素（例如：ul）绑定事件，不给子级元素(例如：li)绑定事件，然后当点击子级元素时，通过事件冒泡机制在其绑定的父元素上触发事件处理函数，主要目的是为了提升性能，因为我不用给每个子级元素绑定事件，只给父级元素绑定一次就好了,在原生js里面是通过event对象的targe属性实现

var ul = document.querySelector("ul");

​	ul.onclick = function(e){//e指event,事件对象

​	var target = e.target || e.srcElement; //target获取触发事件的目标(li)

​		if(target.nodeName.toLowerCase() == 'li'){//目标(li)节点名转小写字母，不转的话是大写字母

​			alert(target.innerHTML)

​		}

​	}

jq方式实现相对而言简单 $(“ul”).on(“click”,“li”,function(){//事件逻辑})  其中第二个参数指的是触发事件的具体目标，***\*特别是给动态添加的元素绑定事件，这个特别起作用\****

 

### （13） **说一下JS数据类型有哪些？**

答：JS数据类型有：

基本数据类型：number,string,Boolean,null,undefined,symbol（ES6新增）

复合类型：Object,function



 

### （14） **说一下call,apply,bind区别**

答：call,apply,bind主要作用都是改变this指向的，但使用上略有区别，说一下区别:

  call和apply的主要区别是在传递参数上不同，***\*call后面传递的参数是以逗号的形式分开的，apply传递的参数是数组形式  [Apply是以A开头的,所以应该是跟Array(数组)形式的参数]\****

 bind返回的是一个函数形式，如果要执行，则后面要再加一个小括号 例如：bind(obj,参数1,参数2,)(),bind只能以逗号分隔形式，不能是数组形式

  

​		

### **git相关：**

（1） 你们公司项目是如何管理的？

答：主要通过git来进行项目版本控制的

（2） 说几个git常用命令？

答：我工作中常用的有git add ,git status,git commit –m,git push,git pull等

（3） 说一下多人操作同一个文件，如果出现冲突该如何解决？

答：当遇到多人协作修改同一个文件时出现冲突，我先将远程文件先git pull下来，手动修改冲突代码后，再git add ,git commit,git push再上传到远程仓库。如果pull也pull不下来提示冲突的话，可以先通过git stash暂存下来，然后再pull拉取，然后git  stash pop，取出原来写的，手动修改，然后提交

​	 

 

**Ajax相关：**

(1) 说一下你是如何与后端进行数据交互的

答：我和后端通过ajax来进行数据交互的，通过统一制定的接口文档，来实现前后端高效开发，如果接口文档不能详细说明，或者接口文档上的参数请求不出数据，我会主动和后端工程师沟通，直到完成跟接口相关的业务开发。当然这其中为了验证一些接口问题，会用到一些辅助工具，比方说，runapi这种在线测试工具

(2) 如果后端数据接口没有准备好，你是如何工作的

答：如果后端接口还没有准备好，我会和后端工程师沟通，通过制定接口返回数据的格式，然后前端通过一些mock数据的工具（上家公司使用的是easymock,贼简单）来批量生成假数据，可以让前端和后端同时开发，而无需等待后端数据接口写好再开发，这样提升项目整体的开发效率

(3) 说一下你对ajax的同源策略的理解

答：ajax同源策略是因为安全的考虑，ajax不允许访问不同域名下的资源即所谓同源策略的意思。

 

(4) 说一下什么情况下会产生跨域及产生跨域的解决方案和实现原理？

答：产生跨域的情况有：不同协议，不同域名，不同端口以及域名和ip地址的访问都会产生跨域。

​		**跨域的解决方案目前有三种主流解决方案**：

跨域是浏览器做出的限制,和后端没关系

一、 是jsonp

jsonp实现原理：主要是利用动态创建script标签请求后端接口地址，然后传递callback参数，后端接收callback，后端经过数据处理，返回callback函数调用的形式，callback中的参数就是json

二、 是代理（前端代理和后端代理）

前端代理我在vue中主要是通过vue脚手架中的config中的index文件来配置的，其中有个proxyTable来配置跨域的

三、 是CORS

CORS全称叫跨域资源共享，主要是后台工程师设置后端代码来达到前端跨域请求的

​      注：现在主流框架都是用代理和CORS跨域实现的

(5) 说一下原生ajax的交互过程（即流程）

答：交互流程：

​		 先创建XHR对象即XMLHttpRequest()

​	   然后open准备发送，open中有三个参数一是提交方式get和post,二是接口地址，三是同步和异步

​		 第三步是用send发送

​		 第四步再发送的过程中通过onreadystatechange来监听接收的回调函数，可以通过判断readyState＝＝4和status=＝200来判断是否成功返回，然后通过responseText接收成功返回的数据

### (6) **说一下你对同步和异步的理解**

答：同步即sync，形象的说就是代码一行行执行，前面代码和请求没有执行完，后面的代码和请求就不会被执行，

缺点：容易导致代码阻塞

优点：程序员容易理解（因为代码从上往下一行行执行，强调顺序）

 

异步：即async,形象的说就是代码可以在当前程序没有执行完，也可以执行后面的代码

缺点：程序员不易理解（因为不是按顺序执行的）

优点：可以解决代码阻塞问题，提升代码执行效率和性能

 

异步解决方案主要有三个：

\1. 回调函数

\2. promise（重点掌握）

\3. generator(了解)

\4. async和await（重点掌握）

那如果ajax请求.我想要用同步的方式来执行.怎么办?

Ajax原生的话,open方法的后面设置成false;jq里面有一个async参数设置成false

如果,我想同时执行多个ajax不管前后顺序,但是都执行完之后再做操作怎么办?

我想先执行完其中一个之后再执行,第二个怎么办?

 

(7) **ajax缓存如何解决？**

答：通过在文件名后面添加随机数（也称为文件指纹）来实现，主要原理是浏览器对访问过的文件，首先会检测第二次请求的文件url在浏览器是否缓存过，如果缓存过就使用，否则如果是一个新的文件url，则从服务器重新请求

(8) 说一下javaScript原生,jQuery,vue,react,小程序ajax与后台交互主要用的什么技术

答：javaScript原生Ajax：用的是XMLHttpRequest对象

jQuery中的Ajax: $.ajax(),$.getJSON(),$.get(),$.post()等

vue中的Ajax:vue-resource（vue1.x中用）,axios(主流)

微信小程序Ajax:用的是小程序内置的wx.request()写法和jquery的$.ajax()类似，参数url,success，data,method,fail等

### (9) **说一下你对http状态码的了解多少？**

答：

1xx（临时响应） 

表示临时响应并需要请求者继续执行操作的状态代码

2xx （成功） 

表示成功处理了请求的状态码。

​		常见的2开头的状态码有：200 – 服务器成功返回网页

3xx （重定向） 

表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向

常见的3字开头的状态码有：

***\*301  （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置。\**** ***\*
\*******\*302  （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\**** ***\*
\****304  （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 

4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。

常见的4字开头的状态有：404 – 请求的网页不存在

5xx（服务器错误） 

这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

常见的以5开头的状态码有：
500  （服务器内部错误） 服务器遇到错误，无法完成请求。 
503  （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。

 

 

### (10) **你上家公司项目是前后端分离的吗**

答：对，是前后端分离的项目，但开始不是，开始前后端代码混在一起写的，后来重构成前后端分离的项目，方便前端和后端自己维护的代码

 注：所谓前后端分离就是前后端职责明晰：后端只提供数据接口地址返回json数据，前端用ajax请求json数据，页面的所有业务逻辑都是前端来写，让前端控制力更强，并且减轻后端逻辑处理压力。

### (11) **深拷贝，浅拷贝**

用es6的Object.assign({},{})进行对象合并，如果是数组可以用es6的Array.from，或是es6的扩展运算符...arr，如果使用es5需要用循环来做浅拷贝，如果是深拷贝需要用递归的形式来实现.当然也可以使用JSON.parse(JSON.stringify(对象))的方式实现深拷贝

 

我觉得深拷贝和浅拷贝就是对一个数据类型的操作吧,因为在工作的过程中,我们经常要去操作一些复杂数据类型,当我们对一个数据类型拷贝出一个副本来,修改了副本之后,原数据对象发送改变,就是浅拷贝,原来的数据类型不发生改变,就是深拷贝.其实这个地方就是涉及一个堆栈内存的问题.因为引用数据类型是存储在堆内存里面的,保存的是一个内存地址的指针指向..浅拷贝就是指针指向相同.所以修改了其中一个,另一个也是访问的堆内存里面的相同位置.所以都会发生变换.深拷贝相当于把里面的引用类型,重新在堆内存里面开辟了一块空间.有了新的一个地址指针的指向.就相互不影响了.项目里面的时候,我经常使用JSON.parse(JSON.stringify())的方式来实现吧.也可以用一个递归的方式.来实现,用的多的话.封装成一个函数,放到utils.js中,在引用的地方导入调用.
补充一下引申问题(不用主动回答的):JSON.parse方式有没有什么缺点. 一般情况下都没问题.但是你像函数,正则,时间对象,undefined null拷贝是有问题的.. 怎么解决?如果包含了一些无法拷贝的情况时,可以使用递归的方式,
就是进去对一些对应的类型做检测. 数组对象重新拓展一份,其它类型都返回原来的.然后如果值是引用类型,继续递归调用..当时里面还引用了lodash js库,直接调用里面的方法.

 

## ***\*Vue相关：\****

### （1） **说一下vue最大特点是什么或者说vue核心是什么**

答：vue最大特点我感觉就是“组件化“和”数据驱动“

  组件化就是可以将页面和页面中可复用的元素都看做成组件，写页面的过程，就是写组件，然后页面是由这些组件“拼接“起来的组件树

  数据驱动就是让我们只关注数据层，只要数据变化，页面（即视图层）会自动更新，至于如何操作dom，完全交由vue去完成，咱们只关注数据，数据变了，页面自动同步变化了，很方便

 

### （2） **说一下vue常用基本指令有哪些**

v-if：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。

v-show：根据表达式之真假值，切换元素的 display CSS 属性。

v-for：循环指令，基于一个数组或者对象渲染一个列表，vue 2.0以上必须需配合 key值 使用。

v-bind：动态地绑定一个或多个特性，或一个组件 prop 到表达式。

v-on：用于监听指定元素的DOM事件，比如点击事件。绑定事件监听器。

v-model：实现表单输入和应用状态之间的双向绑定

v-pre：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。

v-once：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。

 

***\*（3）Vue常用指令以及作用\****

v-if（条件渲染）：根据是否买足条件来决定是否对相应的dom、vue的自定义单文件组件（xxx.vue，后期以.vue代替单文件组件）进行渲染，已渲染的dom、.vue则决定是否删除

配合使用的v-else,v-else-if

v-show（条件展示）：根据是否满足条件来决定相对应的dom、.vue的display的值

v-bind(绑定属性)：可以将dom、.vue中的属性（attribute）与vue实例中的property保持一致（简写“:”）

v-for（循环）：使dom、.vue直接在html页面上循环

v-on（添加事件监听器，简单理解为绑定事件）：为dom、.vue添加一个事件监听器，通过此监听器可以跳用vue实例中的方法（简写“@”）

v-model（双向数据绑定）：本身是指令，实际为v-bind:value和v-on:change的语法糖

v-text（设置标签的文本）

v-html（设置标签的innerHTML）

 

 

1.4、**Vue常用的修饰符**

v-on 指令常用修饰符：

.stop - 调用 event.stopPropagation()，禁止事件冒泡。

.prevent - 调用 event.preventDefault()，阻止事件默认行为。

.capture - 添加事件侦听器时使用 capture 模式。

.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。

.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。

.native - 监听组件根元素的原生事件。

.once - 只触发一次回调。

.left - (2.2.0) 只当点击鼠标左键时触发。

.right - (2.2.0) 只当点击鼠标右键时触发。

.middle - (2.2.0) 只当点击鼠标中键时触发。

.passive - (2.3.0) 以 { passive: true } 模式添加侦听器

注意： 如果是在自己封装的组件或者是使用一些第三方的UI库时，会发现并不起效果，这时就需要用`·.native修饰符了，如：

//使用示例：

<el-input

 v-model="inputName"

 placeholder="搜索你的文件"

 @keyup.enter.native="searchFile(params)"

 \>

</el-input>

v-bind 指令常用修饰符：

.prop - 被用于绑定 DOM 属性 (property)。(差别在哪里？)

.camel - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)

.sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。

v-model 指令常用修饰符：

.lazy - 取代 input 监听 change 事件

.number - 输入字符串转为数字

.trim - 输入首尾空格过滤

### **Vue 组件中 data 为什么必须是函数**

问题一：Vue 组件中 data 为什么必须是函数？

简单回答

//为什么data函数里面要return一个对象

<script>

  export default {

​    data() {

​      return {  // 返回一个唯一的对象，不要和其他组件共用一个对象进行返回

​        menu: MENU.data,

​        poi: POILIST.data

​      }

​    }

  }

</script>

因为一个组件是可以共享的，但他们***\*的data是私有的，所以每个组件都要return一个新的data对象，返回一个唯一的对象，不要和其他组件共用一个对象\****。

 

### （3） **说一下v-if和v-show的区别**

答：v-if和v-show都可以显示和隐藏一个元素，但有本质区别

v-if是惰性的，只是值为false就不会加载对应元素，为true才动态加载对应元素

v-show:是无论为true和为false都会加载对应html代码，但为false时用display:none隐藏不在页面显示，但为true时页面上用display:block显示其效果

 

适用场景：切换频繁的场合用v-show,切换不频繁的场合用v-if

 

### （4） **说一下vue自定义指令如何实现的和适用场景？**

答：哦，这个问题是这样的，vue除有了v-for,v-if等自带vue指令外,但不能满足所有的开发需求，有时需要自定义指令，自定义指令创建有全局自定义指令和局部自定义指令

 全局自定义指令：Vue.directive(‘指令名’,{ inserted(el) {  }  })

 局部自定义指令：directives:{  }

（5） **说一下vue过滤器做什么的(vue1.x和vue2.x这块的区别)**

答：**vue过滤器主要用于对渲染出来的数据进行格式化处理**。例如：后台返回的数据性别用0和1表示，但渲染到页面上不能是0和1我得转换为“男“和”女”，这时就会用到过滤器，还有商品价格读取出来的是普通数值，例如：230035,但我要在前面加个货币符号和千分分隔等，例如变成：￥230，035,都得需要vue过滤器

 

如何创建过滤器呢，跟创建自定义指令类似，也有全局和局部过滤器的形式

 

**全局过滤器**：Vue.filter(‘过滤器名’,function(参数1,参数2,…) {

 

   //………..

   return 要返回的数据格式

})

 

**局部过滤器**：在组件内部添加filters属性来定义过滤器

fitlers:{

  过滤器名(参数1,参数2,,…参数n) {

​    //………..

   return 要返回的数据格式

 

  }

}

 

 

### （6） **说一下vue生命周期钩子函数有哪些，分别什么时候触发**

答：vue生命周期即为一个组件从出生到死亡的一个完整周期，主要包括以下**4个阶段：创建，挂载，更新，销毁**

  创建前：beforeCreate,  创建后:created

  挂载前：beforeMount,  挂载后：mounted

  更新前：beforeUpdate,  更新后：updated

  销毁前：beforeDestroy, 销毁后：destroyed 

我平时用的比较多的钩了是created和mounted，created用于获取后台数据，mounted用于dom挂载完后做一些dom操作,以及初始化插件等.beforeDestroy用户清除定时器以及解绑事件等,

另外还新增了使用内置组件 keep-alive 来缓存实例，而不是频繁创建和销毁(开销大)
actived 实例激活
deactived 实例失效

以下为详解版,大家理解就ok:

生命周期钩子函数（11个）Function（类型），标注蓝色的那个是属于类型的意思。

beforeCreate	Function	在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。

created	Function	在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，  属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。

beforeMount	Function	在挂载开始之前被调用：相关的 render 函数首次被调用。

mounted	Function	el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。

beforeUpdate	Function	数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。

updated	Function	由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。

activated	Function	keep-alive 组件激活时调用。该钩子在服务器端渲染期间不被调用。

deactivated	Function	keep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用。

beforeDestroy	Function	实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。

destroyed	Function	Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。

errorCaptured（2.5.0+ 新增）	(err: Error, vm: Component, info: string) => ?boolean	当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。

  

### （7） **说一下vue组件通讯（即传值）有哪几种形式，分别是如何实现的**

答：vue组件通讯大致有三种：父传子，子传父，还有兄弟之间通讯

 

  **第一种：父传子：主要通过props来实现的**

​			具体实现：父组件通过import引入子组件，并注册，在子组件标签上添加要传递的属性，子组件通过props接收，接收有两种形式一是通过数组形式[‘要接收的属性’ ]，二是通过对象形式{  }来接收，对象形式可以设置要传递的数据类型和默认值，而数组只是简单的接收

 

  **第二种：子传父：主要通过$emit来实现**

​		  具体实现：子组件通过通过绑定事件触发函数，在其中设置this.$emit(‘要派发的自定义事件’，要传递的值)，$emit中有两个参数一是要派发的自定义事件，第二个参数是要传递的值

然后父组件中,在这个子组件身上@派发的自定义事件,绑定事件触发的methods中的方法接受的默认值,就是传递过来的参数

 

  **第三种：兄弟之间传值有两种方法：**

​			 方法一：通过event bus实现

​		具体实现:创建一个空的vue并暴露出去，这个作为公共的bus,即当作两个组件的桥梁，在两个兄弟组件中分别引入刚才创建的bus，在组件A中通过bus.$emit（’自定义事件名’，要发送的值）发送数据，在组件B中通过bus.$on（‘自定义事件名‘,function(v) { //v即为要接收的值 }）接收数据

 

​     方法二：通过vuex实现

​		具体实现：vuex是一个状态管理工具，主要解决大中型复杂项目的数据共享问题，主要包括state,actions,mutations,getters和modules 5个要素，主要流程：组件通过dispatch到 actions，actions是异步操作，再actions中通过commit到mutations，mutations再通过逻辑操作改变state，从而同步到组件，更新其数据状态

 

### （8） **说一下vue中是如何封装组件的**

答：vue封装组件涉及三个知识点:

一是事件(v-on,$emit)，

二是传参通过props

三是slot：slot作用主要是可以实现内容分发，组件标签内嵌套内容，可通过<slot></slot>来定义占位的内容

分为具名的slot和匿名的slot

在编写可复用组件的时候，时刻考虑组件是否可复用是有好处的。一次性组件跟其他组件紧密耦合没关系，但是可复用组件一定要定义一个清晰的公开接口。

 

Vue.js组件 API 来自 三部分：prop、事件、slot：

***\*prop 允许外部环境传递数据给组件\****，在vue-cli工程中也可以使用vuex等传递数据。

***\*事件允许组件触发外部环境的 action(就是行为,也就是方法的意思)\****

***\*slot 允许外部环境将内容插入到组件的视图结构内。\****

### （9） **说一下vue转场动画如何实现的**

答：vue转场动画主要通过vue中的提供的transition组件实现的，例如；

​		<transition name=”名称”>

​    <router-view></router-view>

</transition>

其中name为转场的名称，自己定义，可通过定义进入和离开两种转场动画，格式为：

.名称-enter ｛  ｝  //将要进入动画

.名称-enter-active {  }  //定义进入的过程动画

.名称-leave {   }  //将要离开的动画

.名称-leave-active {  }  //定义离开过程中的动画

 

### （10） **说一下你对单向数据流的理解**

答：***\*单向数据流\****主要是vue 组件间传递数据是单向的，即数据总是由父组件传递给子组件，子组件在其内部维护自己的数据，但它无权修改父组件传递给它的数据，当开发者尝试这样做的时候，vue 将会报错。这样做是为了组件间更好的维护。

在开发中可能有多个子组件依赖于父组件的某个数据，假如子组件可以修改父组件数据的话，一个子组件变化会引发所有依赖这个数据的子组件发生变化，所以 vue 不推荐子组件修改父组件的数据

### （11） **说一下vue双向数据绑定的原理**

答：核心主要利用ES5中的Object.defineProperty实现的，然后利用里面的getter和setter来实现双向数据绑定的，大致就这些，其实要实现起来比这个要复杂一些，不过我大致了解过。

### （12） **说一下vue路由或前端路由实现原理**

答：前端路由实现原理主要通过以下两种技术实现的

  第一种：利用H5的history API实现

主要通过history.pushState 和 history.replaceState来实现，不同之处在于，pushState会增加一条新的历史记录，而replaceState则会替换当前的历史记录[发布项目时,需要配置下apache]

 

  第二种：利用url的hash实现

我们经常在 url 中看到 #，这个 # 有两种情况，一个是我们所谓的锚点，路由里的 # 不叫锚点，我们称之为 hash，我们说的就是hash,主要利用监听哈希值的变化来触发事件 —— hashchange 事件来做页面局部更新

 

​    总结：hash 方案兼容性好，而H5的history主要针对高级浏览器。

以下为具体的API的区别:

this.$router.push(location, onComplete?, onAbort?)	这个方法会向 history 	栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。并且点击 <router-link :to="...">等同于调用 router.push(...)。

​	this.$router.replace(location, onComplete?, onAbort?)	这个方法不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录，所以，当用	户点击浏览器后退按钮时，并不会回到之前的 URL。

​	this.$router.go(n)	这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。

以上也可能会形成一个新的面试题:***\*replace和push的区别\****

***\*可以说,以前在一个项目里面配置了一个二级路由,里面有tab切换部分(详情,评价,说明),因为返回上一页的时候,不能在这几个选项卡之间来回切换.所以我使用了this.$router.replace方法,不计入history记录中,所以不会出现,反复切换的bug\****

 

（13） **说一下vue路由钩子（或称vue路由守卫）的理解**

什么场景下用到

答：vue路由钩子是在路由跳转过程中拦截当前路由和要跳转的路由的信息，有三种路由钩子：

  第一种：全局路由钩子 beforeEach(to,from,next) {  }

  第二种：路由独享的钩子

​			beforeEnter(to,from,next) {

 

 

​    }

  第三种：组件内的钩子

beforeRouteEnter(to,from,next) { 

  //…因为当钩子执行前，组件实例还没被创建 

}

beforeRouteUpdate(to,from,next) {

 //…在当前路由改变，但是该组件被复用时调用

}

 

beforeRouteLeave(to,from,next) {

  //…导航离开该组件的对应路由时调用

}

 

 

 适用场景：动态设置页面标题，判断用户登录权限等:代码示例:

//全局路由导航守卫

vueRouter.beforeEach(function (to, from, next) {

  const nextRoute = [ 'detail'];

  const auth = sessionStorage.getItem("username");   

  let FROMPATH = from.path;

  //跳转至上述3个页面

  if (nextRoute.indexOf(to.name) >= 0) {

  	//上述数组中的路径，是相当于有权限的页面，访问数组列表中的页面就应该是在登陆状态下

​    if (!auth) {

​			let params = Object.assign({frompath:FROMPATH},from.query);

​			next({path: '/newlogin',query:params});

​    }

  }

  //已登录的情况再去登录页，跳转至首页

  if (to.name === 'newlogin') {

​    if (auth) {

//      vueRouter.push({name: 'index'});

 		next({path: '/'});  

​    }

  }

  next();

});

 

### （14） **说一下vue路由懒加载解决什么问题的?**

答：vue路由懒加载主要解决打包后文件过大的问题，事件触发才加载对应组件中的js

### （15） **说一下如何解决vue首屏加载慢或白屏？**

答： 1.路由懒加载

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps2.jpg) 

2.开启Gzip压缩

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps3.jpg) 

\3. 使用webpack的externals属性把不需要打包的库文件分离出去，减少打包后文件的大小

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps4.jpg) 

\4. 使用vue的服务端渲染(SSR) 

 

### （16） **说一下vue开发环境和线上环境如何切换**

答：主要通过检测process.env.NODE_ENV===”production”和process.env.NODE_ENV===”development”环境，来设置线上和线下环境地址，从而实现线上和线下环境地址的切换

### （17） **说一下你们项目中vue如何跨域的**

答：跨域前端和后端都可以实现，如果只针对vue,vue本身可以通过代理的方式可以实现，具体实现：

在config中的index.js中配置proxy来实现：

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps5.jpg) 

### （18） **说一下vue中methods,computed,watch的区别：**

答：methods中都是封装好的函数，无论是否有变化只要触发就会执行

  computed:是vue独有的特性计算属性，可以对data中的依赖项再重新计算，得到一个新值，应用到视图中，和methods本质区别是computed是可缓存的，也就是说computed中的依赖项没有变化，则computed中的值就不会重新计算，而methods中的函数是没有缓存的。Watch是监听data和计算属性中的新旧变化。

vue用什么绑定事件，用什么绑定属性

答：用v-on绑定事件，简称：@,用v-bind来绑定属性，简称：:属性

 

### （19） **vue如何动态添加属性，实现数据响应？**

答：vue主要通过用this.$set(对象，‘属性‘，值)实现动态添加属性，以实现数据的响应注意是添加,我记忆中如果是修改引用类型属性的值,是可以自动渲染的.

### （20） **vue中的http请求是如何管理的**

答：vue中的http请求如果散落在vue各种组件中，不便于后期维护与管理，所以项目中通常将业务需求统一存放在一个目录下管理，例如src下的API文件夹，这里面放入组件中用到的所有封装好的http请求并导出，再其他用到的组件中导入调用。如下面封装的HTTP请求

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps6.jpg) 

（21） 说一下你对axios拦截器的理解：

答：axios拦截器可以让我们在项目中对后端http请求和响应自动拦截处理，减少请求和响应的代码量，提升开发效率同时也方便项目后期维护

例如：

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps7.jpg) 

 

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps8.jpg) 

或者对公共的数据做操作

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps9.jpg) 

### （22） **说一下vue和jquey的区别**

答：jquery主要是玩dom操作的“神器“，强大的选择器,封装了好多好用的dom操作方法和如何获取ajax方法 例如：$.ajax（）非常好用

  vue:主要用于数据驱动和组件化，很少操作dom，当然vue可能通过ref来选择一个dom或组件

### （23） **说一下vue如何实现局部样式的或者说如何实现组件之间样式不冲突的和实现原理是什么？**

答：css没有局部样式的概念，vue脚手架通过实现了，即在style标签上添加scoped

  ![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps10.jpg)

 scoped的实现原理：vue通过postcss给每个dom元素添加一个以data-开头的随机自定义属性实现的

 

### （24） **说一下vue第三方ui样式库如何实现样式穿透的****（ui库和less/sass穿透问题）  >>>   /deep/**

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps11.jpg) 

（25） **vue目录结构（面试时可能会这样问说一下vue工程目录结构）**：这个了解下就可以

答：统一的目录结构可以方便团队协作和职责明晰，也方便项目后期维护和管理，具体vue项目目录结构包括：

  build:项目构建目录

  config:项目配置，包括代理配置，线上和线下环境配置

  node_modules:node包目录，npm install安装的包都在这个目录

  src:平时开发时的目录

static:存入一些静态资源资源目录，我们可以把一些图片，字体，json数据放在这里。

.eslintrc.js：Eslint代码检查配置文件

.babelrc:ES6配置

.gitignore:忽略提交到远程仓库的配置

 

  

  

### （26） **vue脚手架是你们公司搭建的，还是用的vue的脚本架？webpack了解多少？**

答：我们公司用的vue官方的脚手架（vue-cli）,vue-cli版本有3.0和2.9.x版本

​		webpack是一个前端模块化打包构建工具，vue脚手架本身就用的webpack来构建的，webpack本身需要的入口文件通过entry来指定，出口通过output来指定(这颜色是2.0版本的cli特性)，默认只支持js文件，其他文件类型需要通过对应的loader来转换，例如：less需要less,less-loader,sass需要sass-loader,css需要style-loader,css-loader来实现。当然本身还有一些内置的插件来对文件进行压缩合并等操作

当时开发时候,需要实现一个1px边框,因为涉及到dpr值的不同.所以需要单独实现.当时是用了一个sass的minxins 当时就配置了sass-loader

还配置了plugins:

配置GZIP.后期进行项目的性能优化,时候配置了plugins是.

配置了路径别名.

Cli3.0之后所有的配置都到了vue.config.js中

大约在19年的11 12月左右出来了3.0脚手架

.跨域代理也是webpack里面的.

开发环境生产环境配置..env.development .env.production

拓展:有没有自己配置webpack.没有.自己配置公司里面都是在官方脚手架基础上进行适合的修改的.因为官方的兼容性就挺好,更新也很及时.公司里面耗费人力物力配置出来,还没有官方的好,而且还需要不停的版本迭代升级.所以有点儿意义不大.公司没有单独配置.后期为了自己技术的提升,自己配置一下

Vue

 

### （27） **说一下你对vuex的理解：**

答：vuex是一个状态管理工具，主要解决大中型复杂项目的数据共享问题，主要包括state,actions,mutations,getters和modules 5个要素，主要流程：组件通过dispatch到 actions，actions是异步操作，再actions中通过commit到mutations，mutations再通过逻辑操作改变state，从而同步到组件，更新其数据状态,而getters相当于组件的计算属性，他是对组件中获取到的数据做提前处理的.再说到辅助函数的作用.

模块化以及namespase

我个人感觉模块化一个是为了合作开发是更加方便，不容易产生git冲突，在一个，就是为了让项目代码更加清晰合理，便于管理

另外一个命名空间的问题，就是为了让当前vuex模块里面的状态名，函数名不和其他的空间，相互命名冲突。但是在调用的时候需要加上模块名字

### （28） **vuex如何实现数据持久化（即刷新后数据还保留）？**

答：因为vuex中的state是存储在内存中的，一刷新就没了，例如登录状态，解决方案有：

  第一种：利用H5的本地存储(localStorage,sessionStorage)

  第二种：利用第三方封装好的插件，例如：vuex-persistedstate

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps12.jpg) 

（29） **说一下nextTick的作用和使用场景**？

答：vue中的nextTick主要用于处理数据动态变化后，DOM还未及时更新的问题，用nextTick就可以获取数据更新后最新DOM的变化

适用场景：

  		第一种：有时需要根据数据动态的为页面某些dom元素添加事件，这就要求在dom元素渲染完毕时去设置，但是created与mounted函数执行时一般dom并没有渲染完毕，所以就会出现获取不到，添加不了事件的问题，这回就要用到nextTick处理

​			第二种：在使用某个第三方插件时 ，希望在vue生成的某些dom动态发生变化时重新应用该插件，也会用到该方法，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法，例如:应用滚动插件better-scroll时

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps13.jpg) 

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps14.jpg) 

​    第三种：数据改变后获取焦点

***\*再来看以下解析:\****

何为$nextTick？

简单回答：

因为Vue的异步更新队列，$nextTick是用来知道什么时候DOM更新完成的。

详细解读：



------



我们先来看这样一个场景：有一个div，默认用 v-if 将它隐藏，点击一个按钮后，改变 v-if 的值，让它显示出来，同时拿到这个div的文本内容。如果v-if的值是 false，直接去获取div内容是获取不到的，因为此时div还没有被创建出来，那么应该在点击按钮后，改变v-if的值为 true，div才会被创建，此时再去获取，示例代码如下：

<div id="app">

    <div id="div" v-if="showDiv">这是一段文本</div>

  <button @click="getText">获取div内容</button>

</div>

<script>

var app = new Vue({

  el : "#app",

  data:{

​    showDiv : false

  },

  methods:{

​    getText:function(){

​      this.showDiv = true;

​      var text = document.getElementById('div').innnerHTML;

​       console.log(text);

​    }

  }

})

</script>

这段代码并不难理解，但是运行后在控制台会抛出一个错误：Cannot read property 'innnerHTML of null，意思就是获取不到div元素。这里就涉及Vue一个重要的概念：异步更新队列。

异步更新队列

***\*Vue在观察到数据变化时并不是直接更新DOM，而是开启一个队列，并缓冲在同一个事件循环中发生的所以数据改变。在缓冲时会去除重复数据，从而避免不必要的计算和DOM操作。然后，在下一个事件循环\*******\*tick\*******\*中，Vue刷新队列并执行实际（已去重的）工作\****。所以如果你用一个for循环来动态改变数据100次，其实它只会应用最后一次改变，如果没有这种机制，DOM就要重绘100次，这固然是一个很大的开销。



------



Vue会根据当前浏览器环境优先使用原生的Promise.then和MutationObserver，如果都不支持，就会采用setTimeout代替。
知道了Vue异步更新DOM的原理，上面示例的报错也就不难理解了。事实上，在执行this.showDiv = true时，div仍然还是没有被创建出来，直到下一个vue事件循环时，才开始创建。***\*$nextTick\*******\*就是用来知道什么时候DOM更新完成的\****，所以上面的示例代码需要修改为：

<div id="app">

    <div id="div" v-if="showDiv">这是一段文本</div>

  <button @click="getText">获取div内容</button>

</div>

<script>

var app = new Vue({

  el : "#app",

  data:{

​    showDiv : false

  },

  methods:{

​    getText:function(){

​      this.showDiv = true;

​      this.$nextTick(function(){

​         var text = document.getElementById('div').innerHTML;

​         console.log(text);  

​      });

​    }

  }

})

</script>

这时再点击事件，控制台就打印出div的内容“这是一段文本“了。
理论上，我们应该不用去主动操作DOM，因为Vue的核心思想就是数据驱动DOM，但在很多业务里，我们避免不了会使用一些第三方库，比如 popper.js、swiper等，这些基于原生javascript的库都有创建和更新及销毁的完整生命周期，与Vue配合使用时，就要利用好$nextTick。

 

 **v-for 与 v-if 的优先级**

 

当它们处于同一节点，***\*v-for的优先级比v-if更高\****，这意味着 v-if将分别重复运行于每个 v-for循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用，如下：

 

<li v-for="todo in todos" v-if="!todo.isComplete">

 {{ todo }}

</li>

上面的代码只传递了未完成的 todos。

而如果你的目的是有条件地跳过循环的执行，那么可以***\*将 v-if 置于外层元素 (或** 

### **vue中 keep-alive 组件的作用**

 

***\*keep-alive：主要用于保留组件状态或避免重新渲染。\****

 

比如： 有一个列表页面和一个 详情页面，那么用户就会经常执行打开详情=>返回列表=>打开详情这样的话 列表 和 详情 都是一个频率很高的页面，那么就可以对列表组件使用<keep-alive></keep-alive>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染。

 

1、属性：

 

include:字符串或正则表达式。只有匹配的组件会被缓存。

 

exclude：字符串或正则表达式。任何匹配的组件都不会被缓存。

 

2、用法：

 

包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <transition>相似，<keep-alive>是一个抽象组件：它自身不会渲染一DOM 元素，也不会出现在父组件链中。

 

当组件在<keep-alive> 内被切换，在 2.2.0 及其更高版本中，***\*activated 和 deactivated生命周期 将会在 树内的所有嵌套组件中触发\****。

 

**CSS相关：**

### （1） **css3新增特性有哪些**

答：css3比css2多了好多针对移动端的特性，比如：圆角：border-radius,盒阴影：box-shadow,还有动画：transition(过渡),transform（实现位移，倾斜，旋转，绽放）,animation（关键帧动画）等

另外还新增了一些选择器,nth-child选择器以及@media 和flex弹性盒子

### （2） **如何实现一个div垂直居中（至少3种方法）**

答：其实实现水平垂直剧中方法有很多：

  第一种：定位：

第一种思路：通过给div设置绝对定位，并且left,right,top,bottom设置为0,margin:auto即可以水平垂直居中

第二种思路：通过给div设置绝对定位，left为50%,top为50%,再给div设置距左是自身的一半即：margin-left:自身宽度/2,margin-top:自身高度/2。

第三种思路：通过给div设置绝对定位，left为50%,top为50%，再给div设置跨左和跟上是自身的一半：transform:translate3d(-50%,-50%,0)

  第四种：flex布局:

​		  思路：有两个div，父级div和子级div，给父级div设置display:flex,并且设置父级div的水平居中justify-content:center，并且给父级div设置垂直居中align-items:center即可

### （30） **clearfix是解决什么问题的（另一种问法div塌陷问题如何解决的,或者说一下BFC）：**

答：解决的方法有很多，主要目的是让父级元素有高度

 方法一：给父级元素设置绝对定位：position:absolute

 方法二：给父级元素设置overflow:hidden;

 方法三：通过伪对象来实现

 .clearfix:after {

​         content: " ";

​          display: block;

​          clear: both;

​          height: 0; 

 }

 

### （31） **说一下你对盒模型的理解(包括IE和w3c标准盒模型)**

答：哦，盒模型其实就是浏览器把一个个标签都看一个形象中的盒子，那每个盒子（即标签）都会有内容(width,height)，边框(border)，以及内容和边框中间的缝隙（即内间距padding），还有盒子与盒子之间的外间距（即margin）,用图表示为：

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps15.jpg) 

 

当然盒模型包括两种：IE盒模型和w3c标准盒模型

  ***\*IE盒模型=设置的width宽度+margin的值\****,其中,width值包含了padding和border;

  ***\*标准盒模型＝width+padding+border+margin\****

那如何在IE盒模型宽度和标准盒模型总宽度之间切换呢，可以通过box-sizing:border-box或设置成content-box来切换

  其中：box-sizing：border-box  //IE盒模型

​     box-sizing：content-box   //w3c盒模型

### （32） **css3动画：**

答：哦，您问的css3动画啊，css3动画大致上包括两种：

​       第一种：过渡动画：主要通过transition来实现，通过设置过渡属性，运动时间，延迟时间和运动速度实现。

 

​      第二种：关键帧动画：主要通过animation配合@keyframes实现

​			transition动画和animation动画的主要区别有两点：

第一点transition动画需要事件来触发，animation不需要

第二点:transition只要开始结束两种状态，而animation可以实现多种状态，并且animation是可以做循环次数甚至是无限运动

### （33） **rem和em的区别：**

答：rem和em都是相对单位，主要参考的标签不同：

rem是相对于根字号，即相对于<html>标签的font-size实现的，浏览器默认字号是font-size:16px

em:是相对于父元素标签的字号，和百分比%类似，%也是相对于父级的，只不过是%相对于父级宽度的，而em相对于父级字号的

### （3） **手机端如何做适配的：**

答：前端做适配没有最好的方法，只有适合的方法，目前前端主要做适配的方法有：百分比，em,rem,媒体查询(即media query),flex布局（即弹性盒），vw,vh等

目前我在项目中用的多的是rem，flex布局，有时会用到媒体查询，在做pc响应式布局时用

主要是用了一个手淘的js库[flexible.js](http://caibaojian.com/t/flexible-js),在页面变化时,检测页面宽度,除以10份,动态的赋值给font-size.属性.;而页面的布局我是通过rem来进行布局的,所以就可以适配所有的移动端设备了

 

 

### （34） **vw和vh了解吗**

答：vw和vh是最近2年才慢慢火起来的css布局单位，现在已经被一些公司在使用，

vw和vh分别相对于屏幕宽度和屏幕高度的，1vw相当于屏幕宽度的1%,100vw相当于满屏宽度100%,

vh和vh类似，只不过是相对于屏幕高度的，1vh相当于屏幕高度的1%,100vh相当于满屏高度的100%,

 

 

你平时怎么写css（或者说佻用过css预处理器吗，用过Less和SASS吗？）

​	答：一般咱们说我平时写css用less，可以定义变量，嵌套，混入等功能，sass语法和less类似都是css预处理器，方便开发人员写快速高效写css

H5相关：

### （35） **cookie,localStorage和sessionStorage的区别**

答：cookie可以设置失效时间，但没有自己的存取取的方法，需要时封装，每次请求时跟随请求发送,而localStorage和sessionStorage可以有自己存取的方法例如：setItem(),getItem(),removeItem(),clear() 如：localStorage.setItem(‘属性’，值) ![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps16.jpg)

（1） autio,video

答：H5提供的音频和视频组件，可以实现视频播放，我以前用它做过音乐播放器，不过好久没用了，里面有play,pause还有获取当前时间和总时间的方法，得看一下audio,video的API，用时我也能很快上手的

（2） 基它

**兼容性相关**:

(1) pc端：

a) 一般是IE兼容的问题，例如：利用css hack来解决 * ，_,等

b) JS有特性匹配来解决某个JS方法是否存在

(2) 手机端：主要遇到过移动端300ms延迟和点透问题，可以通过fastclick插件解决

性能优化相关：

​	答：性能优化是一个很大的一个话题：优化的方面有很多，1是网络加载方面的优化：例如：减少http请求（合并文件，css雪碧图，图片懒加载），减少dom操作（dom缓存），代码封装，第三方库用cdn加载，gzip压缩等

### **IE8如何支持语义化标签**

一个库 html5shiv.js,直接引入就ok,大家可以百度下这个的文件,原理就是把语义化标签在低版本浏览器转化成了块级元素,让浏览器可以解析

 

### **谷歌浏览器如何显示12px以下的字号**

中文版的chrome有个12px字体限制的问题，就是当字体小于12px时候都以12px来显示，这个问题在中文网站中并不突出，因为中文字体为了显示清晰一般都定义为大于或等于12px，但如果是一些英文网站那就不好说了，这时12px的限制就会破坏页面的美感，甚至因为文字变大而导致页面变形。

以前有个属性#chrome10px{ -webkit-text-size-adjust:none; font-size:10px; },但是新版谷歌已经不起作用了.我们可以通过css3的缩放来实现这个问题,比方说我要展示10px的文字,我可以通过设置字体20px,然后scale(0.5); 

 

 

**常用算法相关**：排序，去重，地址栏解析成对象，深拷贝和浅拷贝。。。

 

一、数组排序：

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps17.jpg) 

二、数组去重：

​	答：第一种：利用ES6的set来实现 例如：[...***\*new\**** Set(arr)] 

第二种：借用临时对象的方式

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps18.jpg) 

 

三、地址栏解析成对象：

答：![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps19.jpg)

四、对象深拷贝，浅拷贝的解理：

答：对象浅拷贝可以理解为改变一个对象属性值，另一个对象属性也会发生改变，即互相影响，

  对象深拷贝即就是说改变一个对象属性，另一个对象属性值不会发生改变，可以通过多种方法来实现对象深拷贝，

 第一种方法：通过JSON.stringify和JSON.parse来实现

  var obj={name:’1610A’}

  var obj2=JSON.parse(JSON.stringify(obj))

第二种方法：通过递归来实现  

Object.assign  是浅拷贝  

Lodash

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps20.jpg) 

 

同学们可以参照以下代码,看下函数兼容性处理,以及封装

*var* EventUtil={

​	

  [addHandler](#addHandler):*function*(*element*,*type*,*handler*){ //添加事件

   if(element.addEventListener){ 

​     element.addEventListener(type,handler,false);  //使用DOM2级方法添加事件

   }else if(element.attachEvent){           //使用IE方法添加事件

​     element.attachEvent("on"+type,handler);

   }else{

​     element["on"+type]=handler;      //使用DOM0级方法添加事件

   }

  },  

 

  [removeHandler](#removeHandler):*function*(*element*,*type*,*handler*){  //取消事件

   if(element.removeEventListener){

​     element.removeEventListener(type,handler,false);

   }else if(element.detachEvent){

​     element.detachEvent("on"+type,handler);

   }else{

​     element["on"+type]=null;

   }

  },

 

  [getEvent](#getEvent):*function*(*event*){  //使用这个方法跨浏览器取得event对象

   return *event*?*event*:*window*.*event*;

  },

​	

  [getTarget](#getTarget):*function*(*event*){  //返回事件的实际目标

   return *event*.target||*event*.srcElement;

  },

​	

  [preventDefault](#preventDefault):*function*(*event*){  //阻止事件的默认行为

   if(*event*.preventDefault){

​     *event*.preventDefault(); 

   }else{

​     *event*.returnValue=false;

   }

  },

 

  [stopPropagation](#stopPropagation):*function*(*event*){  //立即停止事件在DOM中的传播

​                   //避免触发注册在document.body上面的事件处理程序

   if(*event*.stopPropagation){

​     *event*.stopPropagation();

   }else{

​     *event*.cancelBubble=true;

   }

  }

}

 

 

**自我成长相关：**

平时怎么学习新技术的？

答：上官网看文档，上github上找相关开源项目练手，上技术社区博客园，csdn,51cto,掘金，简书参加技术问题讨论，上知乎，通过专业书籍（例如：高程三，javascript权威指南即犀牛书）系统学习，加入相关技术群参考讨论，

未来的职业规划是什么？

答：2年内先做好技术，小有所成后，其他机会也就慢慢来了

 

 

分三步:

第一个是页面初始化时,传进去当前服务器的数据

用户在组件内部操作时,对传进来的数据进行加加减减操作(但这只是操作的本地)

通过triggerEvent事件传递出来一个标志.根据标志请求不同的接口.接口的调用流程.

 

 

为了组件的重用性,我一般是不把请求放到组件中的.而是把需要的数据传递进去

考虑到外部父组件不知道用户当前操作的到底是点赞还是取消点赞状态.所以需要在子组件中传递出来一个是否点赞的标志.根据标志操作服务器数据

在操作数据库的过程中.我项目中的接口都是模块化统一管理的.***\*在model文件夹下面有一个对应的js文件.项目中所有的请求都在这儿统一控制.页面中的请求调用对应js文件中的请求方法\****,而model中的方法是继承了我统一封装的一个http请求

 

 

 

 

***\*虚拟dom的理解\****

 

我大体说下对虚拟dom的理解吧,正是virtual(喂车额奥) DOM这一个特性,让现代这些流行的框架,能够性能更高,才得以市场率占有这么高的.比方说,vue react 阿瓦隆.这些框架都是虚拟dom的.

在传统的jq中,操作的都是真实的DOM,.而一个真实dom的渲染过程,要经过渲染引擎构建DOM树.构建样式表.组建成render(渲染)树,的过程,要经过不断的重绘回流才能够展示给用户.

那么在直接js操作dom的过程中,比方说一个循环10次插入dom元素,其实每一次都会经历上面的过程..经历大量的重绘回流.代价特别大.性能低下.所以出现了虚拟dom

虚拟dom其实就是提前使用js的方式表示出dom结构树来.存储在内存里面.同样的循环.只会最终合并执行一次,大大的提高了性能.(这个地方有点儿像js中的createElementFragment文档碎片)

而在对比的过程中.通过diff算法进行比较差异.这个比较在我理解而言就是***\*同层比较.\****降低了时间复杂度空间复杂度一些什么玩意儿.最终把差异同步到真实dom上去.这就是我理解的虚拟dom

 

离职原因

\1. 公司资金链断裂.两个月发不出工资.领导让我出来找工作的

\2. 行业整体不怎么景气.公司这边.浮动工资(绩效工资)占比增大.

\3. 公司这边需要长期外派出差,我个人的一些朋友人脉都在北京这边,所以不想出去.

\4. 公司项目完成了.剩下的都是一些维护的工作.公司新招了两个大学生.我带了他们查不多两个月,

\5. 待定.....

 

 

 

 

 

 

 

### **小程序**

***\*小程序中,页面与组件间的通信:\****

页面向组件中传值时,在组件上直接写上要传递的,变量名=”{{要传递的值}}”

 

组件中,如何接收, properties中接收传递的值,如果要对这个值进行操作类似计算属性,是触发的observers  这个东西有点儿类似于vue里面的computed计算属性,能够取到最新的值,

组件中如何向外层传递数据

This.triggerEvent(“自定义事件名字”,{要传递的值,以及配置是否冒泡})

页面中,bind自定义事件名 = 要触发的方法名,方法名中的details属性,就是传递的数据.

注意:组件中的方法要写到methods中.而页面中的是和声明周期同级,不需要写到methods中.

 



 

 

如何实现一个1像素边框:

物理像素:    在视网膜屏下面, 显示的实际的像素颗粒

设备独立像素:  可以认为成就是设备的宽度,css设置的像素

 

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps21.jpg) 

最大的dpr()值是3  也有事单位像素内能显示3个物理像素单位   人的肉眼最多只能感受到这个范围.再大爷没有意义了

如果dpr的值是2的话  在苹果6手机上,像素边框看起来就有点儿宽如何变成一半  

解决方式,第一种:

通过媒体查询方式:

.border { border: 1px solid #999 }

@media screen and (-webkit-min-device-pixel-ratio: 2) {

  .border { border: 0.5px solid #999 }

}

@media screen and (-webkit-min-device-pixel-ratio: 3) {

  .border { border: 0.333333px solid #999 }

}

 

##### **# 6.5 媒体查询 + transfrom 对方案1的优化** **(****最常用的方式****)**

/* 2倍屏 */

@media only screen and (-webkit-min-device-pixel-ratio: 2.0) {

  .border-bottom::after {

​    -webkit-transform: scaleY(0.5);

​    transform: scaleY(0.5);

  }

}

/* 3倍屏 */

@media only screen and (-webkit-min-device-pixel-ratio: 3.0) {

  .border-bottom::after {

​    -webkit-transform: scaleY(0.33);

​    transform: scaleY(0.33);

  }

}

 

总结话术: 这个问题我有过了解.就是手机的显示分成了.物理像素和设备独立像素.他们之间的比值,形成了一个叫做dpr设备像素比的东西,这个值越大,画质显示的会越细腻.一般的话会存在设备像素比是2或者三的情况,但是在苹果手机上,显示的就有点儿宽了..我一般采用的解决方式是这样的...通过媒体查询检测一个属性.当属性值是2的时候,使用transform 进行scale 0.5倍,  当dpr的属性值是3的时候,进行transform scale 0.33倍.就能解决这个问题.

### **Promise在项目中的实际使用**

在项目里面的时候promise封装了axios请求.抛出了post get put delete方法,里面return了一个promise实例,请求成功之后,将返回结果传递给了resolve()  当时使用在组件中是结合async await使用的

组件中 async定义methods中的方法 然后const result = await getList()方法  getlist是API层里面的.调用的封装的promise方法

 

 

垃圾回收机制有没有了解

.一般问闭包的问题会问题会问道.  闭包内部的变量被常驻内存.一直被引用

所以不被垃圾回收机制回收,占用内存.影响想能

我了解过垃圾回收机制,看过高程三我记得里面是有一个叫标记清除的方式

就是给每一个变量打上标识.没有被引用无法访问的.就会被统一清除.js引擎在进行垃圾标识的时候,为了提高性能,有一些处理方式,

我记得好像能分代清除(哪些不常活跃,就不检查)

另一个叫空闲时间回收

增量回收,我的理解就是分开,类似异步的检测来理解,是否放开

这几天面试.被问到了小程序

Uni  

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

# **必须要会的 50 个React 面试题**

## **基本知识**

### **1. 区分Real DOM和Virtual DOM**

| **Real DOM**                   | **Virtual DOM**                |
| ------------------------------ | ------------------------------ |
| 1. 更新缓慢。                  | 1. 更新更快。                  |
| 2. 可以直接更新 HTML。         | 2. 无法直接更新 HTML。         |
| 3. 如果元素更新，则创建新DOM。 | 3. 如果元素更新，则更新 JSX 。 |
| 4. DOM操作代价很高。           | 4. DOM 操作非常简单。          |
| 5. 消耗的内存较多。            | 5. 很少的内存消耗。            |

### **2. 什么是React？**

· React 是 Facebook 在 2011 年开发的前端 JavaScript 库。

· 它遵循基于组件的方法，有助于构建可重用的UI组件。

· 它用于开发复杂和交互式的 Web 和移动 UI。

· 尽管它仅在 2015 年开源，但有一个很大的支持社区。

### **3. React有什么特点？**

React的主要功能如下：

\1. 它使用**虚拟DOM **而不是真正的DOM。

\2. 它可以用**服务器端渲染**。

\3. 它遵循**单向数据流**或数据绑定。

### **4. 列出React的一些主要优点。**

React的一些主要优点是：

\1. 它提高了应用的性能

\2. 可以方便地在客户端和服务器端使用

\3. 由于 JSX，代码的可读性很好

\4. React 很容易与 Meteor，Angular 等其他框架集成

\5. 使用React，编写UI测试用例变得非常容易

### **5. React有哪些限制？**

React的限制如下：

\1. React 只是一个库，而不是一个完整的框架

\2. 它的库非常庞大，需要时间来理解

\3. 新手程序员可能很难理解

\4. 编码变得复杂，因为它使用内联模板和 JSX

### **6. 什么是JSX？**

JSX 是J avaScript XML 的简写。是 React 使用的一种文件，它利用 JavaScript 的表现力和类似 HTML 的模板语法。这使得 HTML 文件非常容易理解。此文件能使应用非常可靠，并能够提高其性能。下面是JSX的一个例子：

render(){

  return(    

        <div>

​      <h1> Hello World from Edureka!!</h1>

​    </div>

  );}

### **7. 你了解 Virtual DOM 吗？解释一下它的工作原理。**

Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。

Virtual DOM 工作过程有三个简单的步骤。

\1. 

每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。

\2. 

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps22.png) 

\3. 

Virtual DOM 1

\4. 

\1. 

然后计算之前 DOM 表示与新表示的之间的差异。

\2. 

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps23.png) 

\3. 

Virtual DOM 2

\4. 

\1. 

完成计算后，将只用实际更改的内容更新 real DOM。

\2. 

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps24.png) 

\3. 

Virtual DOM 3

\4. 

### **8. 为什么浏览器无法读取JSX？**

浏览器只能处理 JavaScript 对象，而不能读取常规 JavaScript 对象中的 JSX。所以为了使浏览器能够读取 JSX，首先，需要用像 Babel 这样的 JSX 转换器将 JSX 文件转换为 JavaScript 对象，然后再将其传给浏览器。

### **9. 与 ES5 相比，React 的 ES6 语法有何不同？**

以下语法是 ES5 与 ES6 中的区别：

\1. require 与 import

// ES5

var React = require('react');

 

// ES6

import React from 'react';

\1. export 与 exports

// ES5

module.exports = Component;

 

// ES6

export default Component;

\1. component 和 function

// ES5

var MyComponent = React.createClass({

  render: function() {

​    return

​      <h3>Hello Edureka!</h3>;

  }

});

 

// ES6

class MyComponent extends React.Component {

  render() {

​    return

​      <h3>Hello Edureka!</h3>;

  }

}

\1. props

// ES5

var App = React.createClass({

  propTypes: { name: React.PropTypes.string },

  render: function() {

​    return

​      <h3>Hello, {this.props.name}!</h3>;

  }

});

 

// ES6

class App extends React.Component {

  render() {

​    return

​      <h3>Hello, {this.props.name}!</h3>;

  }

}

\1. state

// ES5

var App = React.createClass({

  getInitialState: function() {

​    return { name: 'world' };

  },

  render: function() {

​    return

​      <h3>Hello, {this.state.name}!</h3>;

  }

});

 

// ES6

class App extends React.Component {

  constructor() {

​    super();

​    this.state = { name: 'world' };

  }

  render() {

​    return

​      <h3>Hello, {this.state.name}!</h3>;

  }

}

### **10. React与Angular有何不同？**

| **主题**        | **React**          | **Angular**   |
| --------------- | ------------------ | ------------- |
| **1. 体系结构** | 只有 MVC 中的 View | 完整的 MVC    |
| **2. 渲染**     | 可以在服务器端渲染 | 客户端渲染    |
| **3. DOM**      | 使用 virtual DOM   | 使用 real DOM |
| **4. 数据绑定** | 单向数据绑定       | 双向数据绑定  |
| **5. 调试**     | 编译时调试         | 运行时调试    |
| **6. 作者**     | Facebook           | Google        |

## **React 组件**

### **11. 你理解“在React中，一切都是组件”这句话。**

组件是 React 应用 UI 的构建块。这些组件将整个 UI 分成小的独立并可重用的部分。每个组件彼此独立，而不会影响 UI 的其余部分。

### **12. 解释 React 中 render() 的目的。**

每个React组件强制要求必须有一个 **render()**。它返回一个 React 元素，是原生 DOM 组件的表示。如果需要渲染多个 HTML 元素，则必须将它们组合在一个封闭标记内，例如 <form>、<group>、<div> 等。此函数必须保持纯净，即必须每次调用时都返回相同的结果。

### **13. 如何将两个或多个组件嵌入到一个组件中？**

可以通过以下方式将组件嵌入到一个组件中：

class MyComponent extends React.Component{

  render(){

​    return(      

            <div>

​        <h1>Hello</h1>

​        <Header/>

​      </div>

​    );

  }

}

class Header extends React.Component{

  render(){

​    return

​      <h1>Header Component</h1>  

  };

}

ReactDOM.render(

  <MyComponent/>, document.getElementById('content')

);

### **14. 什么是 Props?**

Props 是 React 中属性的简写。它们是只读组件，必须保持纯，即不可变。它们总是在整个应用中从父组件传递到子组件。子组件永远不能将 prop 送回父组件。这有助于维护单向数据流，通常用于呈现动态生成的数据。

### **15. React中的状态是什么？它是如何使用的？**

状态是 React 组件的核心，是数据的来源，必须尽可能简单。基本上状态是确定组件呈现和行为的对象。与props 不同，它们是可变的，并创建动态和交互式组件。可以通过 this.state() 访问它们。

### **16. 区分状态和 props**

| **条件**                | **State** | **Props** |      |
| ----------------------- | --------- | --------- | ---- |
| 1. 从父组件中接收初始值 | Yes       | Yes       |      |
| 2. 父组件可以改变值     | No        | Yes       |      |
| 3. 在组件中设置默认值   | Yes       | Yes       |      |
| 4. 在组件的内部变化     | Yes       | No        |      |
| 5. 设置子组件的初始值   | Yes       | Yes       |      |
| 6. 在子组件的内部更改   | No        | Yes       |      |

### **17. 如何更新组件的状态？**

可以用 this.setState()更新组件的状态。

class MyComponent extends React.Component {

  constructor() {

​    super();

​    this.state = {

​      name: 'Maxx',

​      id: '101'

​    }

  }

  render()

​    {

​      setTimeout(()=>{this.setState({name:'Jaeha', id:'222'})},2000)

​      return (        

                <div>

​          <h1>Hello {this.state.name}</h1>

​          <h2>Your Id is {this.state.id}</h2>

​        </div>

​      );

​    }}

ReactDOM.render(<MyComponent/>, document.getElementById('content'));

### **18. React 中的箭头函数是什么？怎么用？**

箭头函数（**=>**）是用于编写函数表达式的简短语法。这些函数允许正确绑定组件的上下文，因为在 ES6 中默认下不能使用自动绑定。使用高阶函数时，箭头函数非常有用。

//General way

render() {   

  return(

​    <MyInput onChange = {this.handleChange.bind(this) } />

  );

}

//With Arrow Function

render() {  

  return(

​    <MyInput onChange = { (e)=>this.handleOnChange(e) } />

  );

}

### **19. 区分有状态和无状态组件。**

| **有状态组件**                                               | **无状态组件**                                  |
| ------------------------------------------------------------ | ----------------------------------------------- |
| 1. 在内存中存储有关组件状态变化的信息                        | 1. 计算组件的内部的状态                         |
| 2. 有权改变状态                                              | 2. 无权改变状态                                 |
| 3. 包含过去、现在和未来可能的状态变化情况                    | 3. 不包含过去，现在和未来可能发生的状态变化情况 |
| 4. 接受无状态组件状态变化要求的通知，然后将 props 发送给他们。 | 4.从有状态组件接收 props 并将其视为回调函数。   |

### **20. React组件生命周期的阶段是什么？**

React 组件的生命周期有三个不同的阶段：

*1.* **初始渲染阶段：**这是组件即将开始其生命之旅并进入 DOM 的阶段。

*2.* **更新阶段：**一旦组件被添加到 DOM，它只有在 prop 或状态发生变化时才可能更新和重新渲染。这些只发生在这个阶段。

*3.* **卸载阶段：**这是组件生命周期的最后阶段，组件被销毁并从 DOM 中删除。

### **21. 详细解释 React 组件的生命周期方法。**

一些最重要的生命周期方法是：

\1. ***componentWillMount\**\**\*()** – 在渲染之前执行，在客户端和服务器端都会执行。

\2. ***componentDidMount\**\**\*()** – 仅在第一次渲染后在客户端执行。

\3. ***componentWillReceiveProps\**\**\*()** – 当从父类接收到 props 并且在调用另一个渲染器之前调用。

\4. **shouldComponentUpdate\**\**\*()** **– 根据特定条件返回 true 或 false。如果你希望更新组件，请返回true*** 否则返回 **false**。默认情况下，它返回 false。

\5. ***componentWillUpdate\**\**\*()** – 在 DOM 中进行渲染之前调用。

\6. ***componentDidUpdate\**\**\*()** – 在渲染发生后立即调用。

\7. ***componentWillUnmount\**\**\*()** – 从 DOM 卸载组件后调用。用于清理内存空间。

### **22. React中的事件是什么？**

在 React 中，事件是对鼠标悬停、鼠标单击、按键等特定操作的触发反应。处理这些事件类似于处理 DOM 元素中的事件。但是有一些语法差异，如：

\1. 用驼峰命名法对事件命名而不是仅使用小写字母。

\2. 事件作为函数而不是字符串传递。

事件参数重包含一组特定于事件的属性。每个事件类型都包含自己的属性和行为，只能通过其事件处理程序访问。

### **23. 如何在React中创建一个事件？**

class Display extends React.Component({   

  show(evt) {

​    // code  

  },  

  render() {    

​    // Render the div with an onClick prop (value is a function)     

​    return (       

            <div onClick={this.show}>Click Me!</div>

​    );   

  }

});

### **24. React中的合成事件是什么？**

合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象。它们将不同浏览器的行为合并为一个 API。这样做是为了确保事件在不同浏览器中显示一致的属性。

### **25. 你对 React 的 refs 有什么了解？**

Refs 是 React 中引用的简写。它是一个有助于存储对特定的 React 元素或组件的引用的属性，它将由组件渲染配置函数返回。用于对 render() 返回的特定元素或组件的引用。当需要进行 DOM 测量或向组件添加方法时，它们会派上用场。

 

 

class ReferenceDemo extends React.Component{

   display() {

​     const name = this.inputDemo.value;

​     document.getElementById('disp').innerHTML = name;

   }

render() {

  return(     

          <div>

​      Name: <input type="text" ref={input => this.inputDemo = input} />

​      <button name="Click" onClick={this.display}>Click</button>       

​      <h2>Hello <span id="disp"></span> !!!</h2>

​     </div>

  );

  }

 }

### **26. 列出一些应该使用 Refs 的情况。**

以下是应该使用 refs 的情况：

· 需要管理焦点、选择文本或媒体播放时

· 触发式动画

· 与第三方 DOM 库集成

### **27. 如何模块化 React 中的代码？**

可以使用 export 和 import 属性来模块化代码。它们有助于在不同的文件中单独编写组件。

 

//ChildComponent.jsx

export default class ChildComponent extends React.Component {

  render() {

​    return(      

              <div>

​        <h1>This is a child component</h1>

​       </div>

​    );

  }

}

 

//ParentComponent.jsx

import ChildComponent from './childcomponent.js';

class ParentComponent extends React.Component {   

  render() {     

​    return(      

             <div>               

​        <App />      

​       </div>    

​    );  

  }

}

### **28. 如何在 React 中创建表单**

React 表单类似于 HTML 表单。但是在 React 中，状态包含在组件的 state 属性中，并且只能通过 setState() 更新。因此元素不能直接更新它们的状态，它们的提交是由 JavaScript 函数处理的。此函数可以完全访问用户输入到表单的数据。

 

 

handleSubmit(event) {

  alert('A name was submitted: ' + this.state.value);

  event.preventDefault();

}

 

render() {

  return (     

​    <form onSubmit={this.handleSubmit}>

​      <label>

​        Name:

​        <input type="text" value={this.state.value} onChange={this.handleSubmit} />

​      </label>

​      <input type="submit" value="Submit" />

​    </form>

  );

}

### **29. 你对受控组件和非受控组件了解多少？**

| **受控组件**                                   | **非受控组件**           |
| ---------------------------------------------- | ------------------------ |
| 1. 没有维持自己的状态                          | 1. 保持着自己的状态      |
| 2.数据由父组件控制                             | 2.数据由 DOM 控制        |
| 3. 通过 props 获取当前值，然后通过回调通知更改 | 3. Refs 用于获取其当前值 |

### **30. 什么是高阶组件（HOC）？**

高阶组件是重用组件逻辑的高级方法，是一种源于 React 的组件模式。 HOC 是自定义组件，在它之内包含另一个组件。它们可以接受子组件提供的任何动态，但不会修改或复制其输入组件中的任何行为。你可以认为 HOC 是“纯（Pure）”组件。

### **31. 你能用HOC做什么？**

HOC可用于许多任务，例如：

· 代码重用，逻辑和引导抽象

· 渲染劫持

· 状态抽象和控制

· Props 控制

### **32. 什么是纯组件？**

**纯（Pure）** 组件是可以编写的最简单、最快的组件。它们可以替换任何只有 **render()** 的组件。这些组件增强了代码的简单性和应用的性能。

### **33. React 中 key 的重要性是什么？**

key 用于识别唯一的 Virtual DOM 元素及其驱动 UI 的相应数据。它们通过回收 DOM 中当前所有的元素来帮助 React 优化渲染。这些 key 必须是唯一的数字或字符串，React 只是重新排序元素而不是重新渲染它们。这可以提高应用程序的性能。

## **React Redux**

### **34. MVC框架的主要问题是什么？**

以下是MVC框架的一些主要问题：

· 对 DOM 操作的代价非常高

· 程序运行缓慢且效率低下

· 内存浪费严重

· 由于循环依赖性，组件模型需要围绕 models 和 views 进行创建

### **35. 解释一下 Flux**

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps25.png) 

flux

 

Flux 是一种强制单向数据流的架构模式。它控制派生数据，并使用具有所有数据权限的中心 store 实现多个组件之间的通信。整个应用中的数据更新必须只能在此处进行。 Flux 为应用提供稳定性并减少运行时的错误。

### **36. 什么是Redux？**

Redux 是当今最热门的前端开发库之一。它是 JavaScript 程序的可预测状态容器，用于整个应用的状态管理。使用 Redux 开发的应用易于测试，可以在不同环境中运行，并显示一致的行为。

### **37. Redux遵循的三个原则是什么？**

*1.* **单一事实来源：**整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。

*2.* **状态是只读的：**改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。

*3.* **使用纯函数进行更改：**为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps26.png) 

Store

### **38. 你对“单一事实来源”有什么理解？**

Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。

### **39. 列出 Redux 的组件。**

Redux 由以下组件组成：

\1. **Action** – 这是一个用来描述发生了什么事情的对象。

\2. **Reducer** – 这是一个确定状态将如何变化的地方。

\3. **Store** – 整个程序的状态/对象树保存在Store中。

\4. **View** – 只显示 Store 提供的数据。

### **40. 数据如何通过 Redux 流动？**

![img](file:///C:\Users\HP\AppData\Local\Temp\ksohtml14964\wps27.png) 

Data Flow in Redux

### **41. 如何在 Redux 中定义 Action？**

React 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。在 Redux 中，action 被名为 Action Creators 的函数所创建。以下是 Action 和Action Creator 的示例：

function addTodo(text) {

​    return {

​        type: ADD_TODO,   

​         text

  }

}

### **42. 解释 Reducer 的作用。**

Reducers 是纯函数，它规定应用程序的状态怎样因响应 ACTION 而改变。Reducers 通过接受先前的状态和 action 来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。如果不需要完成任务，它会返回原来的状态。

### **43. Store 在 Redux 中的意义是什么？**

Store 是一个 JavaScript 对象，它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器。应用程序的整个状态/对象树保存在单一存储中。因此，Redux 非常简单且是可预测的。我们可以将中间件传递到 store 来处理数据，并记录改变存储状态的各种操作。所有操作都通过 reducer 返回一个新状态。

### **44. Redux与Flux有何不同？**

| **Flux**                           | **Redux**                        |
| ---------------------------------- | -------------------------------- |
| 1. Store 包含状态和更改逻辑        | 1. Store 和更改逻辑是分开的      |
| 2. 有多个 Store                    | 2. 只有一个 Store                |
| 3. 所有 Store 都互不影响且是平级的 | 3. 带有分层 reducer 的单一 Store |
| 4. 有单一调度器                    | 4. 没有调度器的概念              |
| 5. React 组件订阅 store            | 5. 容器组件是有联系的            |
| 6. 状态是可变的                    | 6. 状态是不可改变的              |

### **45. Redux 有哪些优点？**

Redux 的优点如下：

· **结果的可预测性 -** 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。

· **可维护性 -** 代码变得更容易维护，具有可预测的结果和严格的结构。

· **服务器端渲染 -** 你只需将服务器上创建的 store 传到客户端即可。这对初始渲染非常有用，并且可以优化应用性能，从而提供更好的用户体验。

· **开发人员工具 -** 从操作到状态更改，开发人员可以实时跟踪应用中发生的所有事情。

· **社区和生态系统 -** Redux 背后有一个巨大的社区，这使得它更加迷人。一个由才华横溢的人组成的大型社区为库的改进做出了贡献，并开发了各种应用。

· **易于测试 -** Redux 的代码主要是小巧、纯粹和独立的功能。这使代码可测试且独立。

· **组织 -** Redux 准确地说明了代码的组织方式，这使得代码在团队使用时更加一致和简单。

## **React 路由**

### **46. 什么是React 路由？**

React 路由是一个构建在 React 之上的强大的路由库，它有助于向应用程序添加新的屏幕和流。这使 URL 与网页上显示的数据保持同步。它负责维护标准化的结构和行为，并用于开发单页 Web 应用。 React 路由有一个简单的API。

### **47. 为什么React Router v4中使用 switch 关键字 ？**

虽然 <div> ***\* 用于封装 Router 中的多个路由，当你想要仅显示要在多个定义的路线中呈现的单个路线时，可以使用 “switch” 关键字。使用时，**<switch>** 标记会按顺序将已定义的 URL 与已定义的路由进行匹配。找到第一个匹配项后，它将渲染指定的路径。从而绕过其它路线。

### **48. 为什么需要 React 中的路由？**

Router 用于定义多个路由，当用户定义特定的 URL 时，如果此 URL 与 Router 内定义的任何 “路由” 的路径匹配，则用户将重定向到该特定路由。所以基本上我们需要在自己的应用中添加一个 Router 库，允许创建多个路由，每个路由都会向我们提供一个独特的视图

<switch>

  <route exact path=’/’ component={Home}/>

  <route path=’/posts/:id’ component={Newpost}/>

  <route path=’/posts’  component={Post}/>

</switch>

### **49. 列出 React Router 的优点。**

几个优点是：

\1. 就像 React 基于组件一样，在 React Router v4 中，API 是 **'All About Components'**。可以将 Router 可视化为单个根组件（<BrowserRouter>），其中我们将特定的子路由（<route>）包起来。

\2. 无需手动设置历史值：在 React Router v4 中，我们要做的就是将路由包装在 <BrowserRouter> 组件中。

\3. 包是分开的：共有三个包，分别用于 Web、Native 和 Core。这使我们应用更加紧凑。基于类似的编码风格很容易进行切换。

### **50. React Router与常规路由有何不同？**

| **主题**       | **常规路由**                                    | **React 路由**                   |
| -------------- | ----------------------------------------------- | -------------------------------- |
| **参与的页面** | 每个视图对应一个新文件                          | 只涉及单个HTML页面               |
| **URL 更改**   | HTTP 请求被发送到服务器并且接收相应的 HTML 页面 | 仅更改历史记录属性               |
| **体验**       | 用户实际在每个视图的不同页面切换                | 用户认为自己正在不同的页面间切换 |

希望这套 React 面试题和答案能帮你准备面试。祝一切顺利！





 

 

 

 

 

 

 

 